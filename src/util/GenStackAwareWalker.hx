package util;

#if macro
import haxe.macro.Context;
import haxe.macro.Expr;
import haxe.macro.Type;
using haxe.macro.Tools;

class GenStackAwareWalker {
    static function gen() {
        var root = Context.getType("hxParser.ParseTree.File");
        var fields = new Map();
        var nodekinds = new Map();
        genWalk(root, root, fields, nodekinds, null);

        var walkerTD = macro class StackAwareWalker {
            function walkToken(token:Token, stack:WalkStack) {}

            function walkArray<T>(elems:Array<T>, stack:WalkStack, walk:T->WalkStack->Void) {
                for (i in 0...elems.length)
                    walk(elems[i], Element(i, stack));
            }

            function walkCommaSeparated<T>(elems:CommaSeparated<T>, stack:WalkStack, walk:T->WalkStack->Void) {
                walk(elems.arg, Element(0, stack));
                var i = 1;
                for (el in elems.args) {
                    walkToken(el.comma, Edge("comma", stack));
                    walk(el.arg, Element(i, stack));
                    i++;
                }
            }

            function walkCommaSeparatedTrailing<T>(elems:CommaSeparatedAllowTrailing<T>, stack:WalkStack, walk:T->WalkStack->Void) {
                walk(elems.arg, Element(0, stack));
                var i = 1;
                for (el in elems.args) {
                    walkToken(el.comma, Edge("comma", stack));
                    walk(el.arg, Element(i, stack));
                    i++;
                }
                if (elems.comma != null)
                    walkToken(elems.comma, Edge("commaTrailing", stack));
            }
        };

        for (field in fields) {
            walkerTD.fields.push(field);
        }

        var nodeKindTD:TypeDefinition = {
            pos: null,
            pack: [],
            name: "NodeKind",
            kind: TDEnum,
            fields: [],
        };

        var nodeKinds = Lambda.array(nodekinds);
        nodeKinds.sort(function(a, b) return Reflect.compare(a.name, b.name));
        for (field in nodeKinds) {
            nodeKindTD.fields.push(field);
        }

        var parts = [
            "// This file is autogenerated from ParseTree data structures\n" +
            "// Use build-walker.hxml to re-generate!",
            "package hxParser;",
            "import hxParser.ParseTree;"
        ];

        var printer = new haxe.macro.Printer();

        parts.push(printer.printTypeDefinition(walkerTD));

        sys.io.File.saveContent("src/hxParser/StackAwareWalker.hx", parts.join("\n\n"));

        var parts = [
            "// This file is autogenerated from ParseTree data structures\n" +
            "// Use build-walker.hxml to re-generate!",
            "package hxParser;",
            "import hxParser.ParseTree;",
            printer.printTypeDefinition(nodeKindTD),
        ];
        sys.io.File.saveContent("src/hxParser/NodeKind.hx", parts.join("\n\n"));
    }

    static function genWalk(type:Type, origType, fields:Map<String,Field>, nodeKinds:Map<String,Field>, name:Null<String>):Expr {
        switch (type) {
            case TInst(_.get() => {pack: ["hxParser"], name: "Token"}, _):
                return macro walkToken;

            case TInst(_.get() => {pack: [], name: "Array"}, [elemT]) if (name != null):
                return genSequenceWalk(elemT, origType, name, macro walkArray, fields, nodeKinds);

            case TType(_.get() => dt, params):
                switch [dt, params] {
                    case [{pack: ["hxParser"], name: "CommaSeparated"}, [elemT]] if (name != null):
                        return genSequenceWalk(elemT, origType, name, macro walkCommaSeparated, fields, nodeKinds);

                    case [{pack: ["hxParser"], name: "CommaSeparatedAllowTrailing"}, [elemT]] if (name != null):
                        return genSequenceWalk(elemT, origType, name, macro walkCommaSeparatedTrailing, fields, nodeKinds);

                    case [{pack: [], name: "Null"}, _]:
                        throw "Null<T> should be handled elsewhere!";

                    default:
                        return genWalk(dt.type.applyTypeParameters(dt.params, params), origType, fields, nodeKinds, dt.name);
                }

            case TEnum(_.get() => en, _):
                return genEnumWalk(en, origType, fields, nodeKinds);

            case TAnonymous(_.get() => anon) if (name != null):
                return genAnonWalk(anon, origType, fields, nodeKinds, name);

            default:
        }
        throw 'TODO: ${type.toString()}';
    }

    static function genSequenceWalk(elemT:Type, origType:Type, name:String, walkFn:Expr, fields:Map<String,Field>, nodeKinds:Map<String,Field>):Expr {
        var walkName = 'walk$name';
        if (!fields.exists(name)) {
            fields[name] = null;

            var visExpr = genWalk(elemT, elemT, fields, nodeKinds, name + "_elem");

            fields.set(name, {
                pos: null,
                name: walkName,
                kind: FFun({
                    args: [
                        {name: "elems", type: extractTypeName(origType)},
                        {name: "stack", type: macro : WalkStack},
                    ],
                    ret: null,
                    expr: macro { $walkFn(elems, stack, $visExpr); }
                })
            });

        }
        return macro $i{walkName};
    }

    static function genEnumWalk(en:EnumType, origType:Type, fields:Map<String,Field>, nodeKinds:Map<String,Field>):Expr {
        var visName = "walk" + en.name;
        if (!fields.exists(en.name)) {
            fields.set(en.name, null); // TODO: this sucks

            var cases = [];
            for (ctor in en.constructs) {
                switch (ctor.type) {
                    case TFun(args, _):
                        var patternArgs = [];
                        var exprs = [];
                        for (arg in args) {
                            var local = macro $i{arg.name};
                            patternArgs.push(local);

                            var newStack = macro Edge($v{arg.name}, stack);
                            var expr = switch(getNullType(arg.t)) {
                                case None:
                                    var walk = genWalk(arg.t, arg.t, fields, nodeKinds, en.name + "_" + ctor.name + "_" + arg.name);
                                    macro $walk($local, $newStack);
                                case Some(realT):
                                    var walk = genWalk(realT, realT, fields, nodeKinds, en.name + "_" + ctor.name + "_" + arg.name);
                                    macro if ($local != null) $walk($local, $newStack);
                            }

                            exprs.push(expr);
                        }

                        var ctorHandlerName = visName + "_" + ctor.name;
                        var args = args.map(function(a) return ({name: a.name, type: extractTypeName(a.t)} : FunctionArg));
                        var kindName = en.name + "_" + ctor.name;

                        nodeKinds.set(kindName, {
                            pos: en.pos,
                            name: kindName,
                            kind: FFun({args: args, ret: null, expr: null})
                        });

                        fields.set(kindName, {
                            pos: en.pos,
                            name: ctorHandlerName,
                            kind: FFun({
                                args: args.concat([{name: "stack", type: macro : WalkStack}]),
                                ret: null,
                                expr: macro {
                                    stack = Node($i{kindName}($a{patternArgs}), stack);
                                    $b{exprs};
                                }
                            })
                        });

                        cases.push({
                            values: [macro $i{ctor.name}($a{patternArgs})],
                            expr: macro $i{ctorHandlerName}($a{patternArgs.concat([macro stack])})
                        });

                    case TEnum(_):
                        cases.push({
                            values: [macro $i{ctor.name}],
                            expr: macro {},
                        });

                    default: throw false;
                }
            }

            var expr = {expr: ESwitch(macro node, cases, null), pos: en.pos};

            fields.set(en.name, {
                pos: en.pos,
                name: visName,
                kind: FFun({
                    args: [
                        {name: "node", type: extractTypeName(origType)},
                        {name: "stack", type: macro : WalkStack}
                    ],
                    ret: null,
                    expr: expr
                })
            });
        }
        return macro $i{visName};
    }

    static function genAnonWalk(anon:AnonType, origType:Type, fields:Map<String,Field>, nodeKinds:Map<String,Field>, name:String):Expr {
        var visName = 'walk$name';
        if (!fields.exists(name)) {
            fields.set(name, null); // TODO: this sucks

            var exprs = [];

            anon.fields.sort(function(a,b) return Context.getPosInfos(a.pos).min - Context.getPosInfos(b.pos).min);
            for (field in anon.fields) {
                var fname = field.name;

                var newStack = macro Edge($v{fname}, stack);
                var expr = switch(getNullType(field.type)) {
                    case None:
                        var walk = genWalk(field.type, field.type, fields, nodeKinds, name + "_" + fname);
                        macro $walk(node.$fname, $newStack);
                    case Some(realT):
                        var walk = genWalk(realT, realT, fields, nodeKinds, name + "_" + fname);
                        macro if (node.$fname != null) $walk(node.$fname, $newStack);
                }

                exprs.push(expr);
            }

            var ct = extractTypeName(origType);

            var pos = Context.currentPos();
            nodeKinds.set(name, {
                pos: pos,
                name: name,
                kind: FFun({args: [{name: "node", type: ct}], ret: null, expr: null})
            });

            fields.set(name, {
                pos: pos,
                name: visName,
                kind: FFun({
                    args: [
                        {name: "node", type: ct},
                        {name: "stack", type: macro : WalkStack}
                    ],
                    ret: null,
                    expr: macro {
                        stack = Node($i{name}(node), stack);
                        $b{exprs};
                    }
                })
            });
        }
        return macro $i{visName};
    }

    public static function getNullType(t:Type):haxe.ds.Option<Type> {
        return switch (t) {
            case TType(_.get() => {pack: [], name: "Null"}, [realT]): Some(realT);
            default: None;
        }
    }

    public static function extractTypeName(t:Type) {
        function mapParam(t:TypeParam, f):TypeParam return switch (t) {
            case TPExpr(_): t;
            case TPType(t): TPType(f(t));
        }

        function loop(t:ComplexType):ComplexType return switch (t) {
            case TPath({pack: ["hxParser"], name:"ParseTree", sub: sub, params: params}):
                TPath({pack: [], name: sub, params: [for (p in params) mapParam(p, loop)]});
            case TPath({pack: [], name: "StdTypes", sub: "Null", params: [TPType(ct)]}):
                TPath({pack: [], name: "Null", params: [TPType(loop(ct))]});
            case TPath({pack: pack, name: name, sub: sub, params: params}):
                TPath({pack: pack, name: name, sub: sub, params: [for (p in params) mapParam(p, loop)]});
            case ct:
                ct;
        }

        return loop(t.toComplexType());
    }
}
#end
