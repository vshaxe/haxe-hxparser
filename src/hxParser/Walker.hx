// This file is autogenerated from ParseTree data structures
// Use build-walker.hxml to re-generate!

package hxParser;

import hxParser.ParseTree;

class Walker {
	function walkToken(token:Token) { }
	function walkArray<T>(elems:Array<T>, walk:T -> Void) {
		for (el in elems) walk(el);
	}
	function walkCommaSeparated<T>(elems:NCommaSeparated<T>, walk:T -> Void) {
		walk(elems.arg);
		for (el in elems.args) {
			walkToken(el.comma);
			walk(el.arg);
		};
	}
	function walkCommaSeparatedTrailing<T>(elems:NCommaSeparatedAllowTrailing<T>, walk:T -> Void) {
		walk(elems.arg);
		for (el in elems.args) {
			walkToken(el.comma);
			walk(el.arg);
		};
		if (elems.comma != null) walkToken(elems.comma);
	}
	function walkNBlockElement_PVar_vl(elems:NCommaSeparated<NVarDeclaration>) {
		walkCommaSeparated(elems, walkNVarDeclaration);
	}
	function walkNObjectFieldName_PString(string:NString) {
		walkNString(string);
	}
	function walkNExpr_PArrayDecl_el(elems:NCommaSeparatedAllowTrailing<NExpr>) {
		walkCommaSeparatedTrailing(elems, walkNExpr);
	}
	function walkDecl_ClassDecl(annotations:NAnnotations, flags:Array<NCommonFlag>, classDecl:ClassDecl) {
		walkNAnnotations(annotations);
		walkDecl_ClassDecl_flags(flags);
		walkClassDecl(classDecl);
	}
	function walkNObjectFieldName(node:NObjectFieldName) switch node {
		case PString(string):walkNObjectFieldName_PString(string);
		case PIdent(ident):walkNObjectFieldName_PIdent(ident);
	};
	function walkDecl_AbstractDecl_relations(elems:Array<NAbstractRelation>) {
		walkArray(elems, walkNAbstractRelation);
	}
	function walkNTypeHint(node:NTypeHint) {
		walkToken(node.colon);
		walkNComplexType(node.type);
	}
	function walkNString_PString2(s:Token) {
		walkToken(s);
	}
	function walkNExpr_PVar(_var:Token, d:NVarDeclaration) {
		walkToken(_var);
		walkNVarDeclaration(d);
	}
	function walkNDotIdent_PDotIdent(name:Token) {
		walkToken(name);
	}
	function walkNExpr_PDo(_do:Token, e1:NExpr, _while:Token, popen:Token, e2:NExpr, pclose:Token) {
		walkToken(_do);
		walkNExpr(e1);
		walkToken(_while);
		walkToken(popen);
		walkNExpr(e2);
		walkToken(pclose);
	}
	function walkNFieldExpr_PBlockFieldExpr(e:NExpr) {
		walkNExpr(e);
	}
	function walkNMacroExpr_PVar_v(elems:NCommaSeparated<NVarDeclaration>) {
		walkCommaSeparated(elems, walkNVarDeclaration);
	}
	function walkNTypePathParameter_PConstantTypePathParameter(constant:NLiteral) {
		walkNLiteral(constant);
	}
	function walkNEnumFieldArgs(node:NEnumFieldArgs) {
		walkToken(node.popen);
		if (node.args != null) walkNEnumFieldArgs_args(node.args);
		walkToken(node.pclose);
	}
	function walkNPath_idents(elems:Array<NDotIdent>) {
		walkArray(elems, walkNDotIdent);
	}
	function walkNMacroExpr_PClass(c:ClassDecl) {
		walkClassDecl(c);
	}
	function walkNExpr_PBlock(braceOpen:Token, elems:Array<NBlockElement>, braceClose:Token) {
		walkToken(braceOpen);
		walkNExpr_PBlock_elems(elems);
		walkToken(braceClose);
	}
	function walkNModifier_PModifierPrivate(token:Token) {
		walkToken(token);
	}
	function walkNClassRelation_PExtends(_extends:Token, path:NTypePath) {
		walkToken(_extends);
		walkNTypePath(path);
	}
	function walkNExpr_PUnsafeCast(_cast:Token, e:NExpr) {
		walkToken(_cast);
		walkNExpr(e);
	}
	function walkNTypePathParameter(node:NTypePathParameter) switch node {
		case PArrayExprTypePathParameter(bkopen, el, bkclose):walkNTypePathParameter_PArrayExprTypePathParameter(bkopen, el, bkclose);
		case PConstantTypePathParameter(constant):walkNTypePathParameter_PConstantTypePathParameter(constant);
		case PTypeTypePathParameter(type):walkNTypePathParameter_PTypeTypePathParameter(type);
	};
	function walkNConst_PConstLiteral(literal:NLiteral) {
		walkNLiteral(literal);
	}
	function walkClassDecl(node:ClassDecl) {
		walkToken(node.kind);
		walkToken(node.name);
		if (node.params != null) walkNTypeDeclParameters(node.params);
		walkClassDecl_relations(node.relations);
		walkToken(node.braceOpen);
		walkClassDecl_fields(node.fields);
		walkToken(node.braceClose);
	}
	function walkNExpr_PMetadata(metadata:NMetadata, e:NExpr) {
		walkNMetadata(metadata);
		walkNExpr(e);
	}
	function walkImportMode(node:ImportMode) switch node {
		case IIn(inKeyword, ident):walkImportMode_IIn(inKeyword, ident);
		case INormal:{ };
		case IAll(dotstar):walkImportMode_IAll(dotstar);
		case IAs(asKeyword, ident):walkImportMode_IAs(asKeyword, ident);
	};
	function walkFile(node:File) {
		if (node.pack != null) walkPackage(node.pack);
		walkFile_decls(node.decls);
		walkToken(node.eof);
	}
	function walkDecl_ImportDecl(importKeyword:Token, path:NPath, mode:ImportMode, semicolon:Token) {
		walkToken(importKeyword);
		walkNPath(path);
		walkImportMode(mode);
		walkToken(semicolon);
	}
	function walkNDotIdent_PDot(_dot:Token) {
		walkToken(_dot);
	}
	function walkNMetadata_PMetadataWithArgs_el(elems:NCommaSeparated<NExpr>) {
		walkCommaSeparated(elems, walkNExpr);
	}
	function walkNAnonymousTypeFields_PAnonymousShortFields(fields:Null<NCommaSeparatedAllowTrailing<NAnonymousTypeField>>) {
		if (fields != null) walkNAnonymousTypeFields_PAnonymousShortFields_fields(fields);
	}
	function walkNClassField_PPropertyField_modifiers(elems:Array<NModifier>) {
		walkArray(elems, walkNModifier);
	}
	function walkNExpr_PSwitch_cases(elems:Array<NCase>) {
		walkArray(elems, walkNCase);
	}
	function walkNExpr_PSafeCast(_cast:Token, popen:Token, e:NExpr, comma:Token, ct:NComplexType, pclose:Token) {
		walkToken(_cast);
		walkToken(popen);
		walkNExpr(e);
		walkToken(comma);
		walkNComplexType(ct);
		walkToken(pclose);
	}
	function walkDecl_AbstractDecl_flags(elems:Array<NCommonFlag>) {
		walkArray(elems, walkNCommonFlag);
	}
	function walkNExpr(node:NExpr) switch node {
		case PVar(_var, d):walkNExpr_PVar(_var, d);
		case PConst(const):walkNExpr_PConst(const);
		case PDo(_do, e1, _while, popen, e2, pclose):walkNExpr_PDo(_do, e1, _while, popen, e2, pclose);
		case PMacro(_macro, e):walkNExpr_PMacro(_macro, e);
		case PWhile(_while, popen, e1, pclose, e2):walkNExpr_PWhile(_while, popen, e1, pclose, e2);
		case PIntDot(int, dot):walkNExpr_PIntDot(int, dot);
		case PBlock(braceOpen, elems, braceClose):walkNExpr_PBlock(braceOpen, elems, braceClose);
		case PFunction(_function, f):walkNExpr_PFunction(_function, f);
		case PSwitch(_switch, e, braceOpen, cases, braceClose):walkNExpr_PSwitch(_switch, e, braceOpen, cases, braceClose);
		case PReturn(_return):walkNExpr_PReturn(_return);
		case PArrayDecl(bkopen, el, bkclose):walkNExpr_PArrayDecl(bkopen, el, bkclose);
		case PDollarIdent(ident):walkNExpr_PDollarIdent(ident);
		case PIf(_if, popen, e1, pclose, e2, elseExpr):walkNExpr_PIf(_if, popen, e1, pclose, e2, elseExpr);
		case PReturnExpr(_return, e):walkNExpr_PReturnExpr(_return, e);
		case PArray(e1, bkopen, e2, bkclose):walkNExpr_PArray(e1, bkopen, e2, bkclose);
		case PContinue(_continue):walkNExpr_PContinue(_continue);
		case PParenthesis(popen, e, pclose):walkNExpr_PParenthesis(popen, e, pclose);
		case PTry(_try, e, catches):walkNExpr_PTry(_try, e, catches);
		case PBreak(_break):walkNExpr_PBreak(_break);
		case PCall(e, el):walkNExpr_PCall(e, el);
		case PUnaryPostfix(e, op):walkNExpr_PUnaryPostfix(e, op);
		case PBinop(e1, op, e2):walkNExpr_PBinop(e1, op, e2);
		case PSafeCast(_cast, popen, e, comma, ct, pclose):walkNExpr_PSafeCast(_cast, popen, e, comma, ct, pclose);
		case PUnaryPrefix(op, e):walkNExpr_PUnaryPrefix(op, e);
		case PMacroEscape(ident, braceOpen, e, braceClose):walkNExpr_PMacroEscape(ident, braceOpen, e, braceClose);
		case PIn(e1, _in, e2):walkNExpr_PIn(e1, _in, e2);
		case PMetadata(metadata, e):walkNExpr_PMetadata(metadata, e);
		case PUnsafeCast(_cast, e):walkNExpr_PUnsafeCast(_cast, e);
		case PCheckType(popen, e, colon, type, pclose):walkNExpr_PCheckType(popen, e, colon, type, pclose);
		case PUntyped(_untyped, e):walkNExpr_PUntyped(_untyped, e);
		case PField(e, ident):walkNExpr_PField(e, ident);
		case PIs(popen, e, _is, path, pclose):walkNExpr_PIs(popen, e, _is, path, pclose);
		case PTernary(e1, questionmark, e2, colon, e3):walkNExpr_PTernary(e1, questionmark, e2, colon, e3);
		case PObjectDecl(braceOpen, fl, braceClose):walkNExpr_PObjectDecl(braceOpen, fl, braceClose);
		case PNew(_new, path, el):walkNExpr_PNew(_new, path, el);
		case PThrow(_throw, e):walkNExpr_PThrow(_throw, e);
		case PFor(_for, popen, e1, pclose, e2):walkNExpr_PFor(_for, popen, e1, pclose, e2);
	};
	function walkNCallArgs(node:NCallArgs) {
		walkToken(node.popen);
		if (node.args != null) walkNCallArgs_args(node.args);
		walkToken(node.pclose);
	}
	function walkNEnumFieldArgs_args(elems:NCommaSeparated<NEnumFieldArg>) {
		walkCommaSeparated(elems, walkNEnumFieldArg);
	}
	function walkDecl_AbstractDecl(annotations:NAnnotations, flags:Array<NCommonFlag>, abstractKeyword:Token, name:Token, params:Null<NTypeDeclParameters>, underlyingType:Null<NUnderlyingType>, relations:Array<NAbstractRelation>, braceOpen:Token, fields:Array<NClassField>, braceClose:Token) {
		walkNAnnotations(annotations);
		walkDecl_AbstractDecl_flags(flags);
		walkToken(abstractKeyword);
		walkToken(name);
		if (params != null) walkNTypeDeclParameters(params);
		if (underlyingType != null) walkNUnderlyingType(underlyingType);
		walkDecl_AbstractDecl_relations(relations);
		walkToken(braceOpen);
		walkDecl_AbstractDecl_fields(fields);
		walkToken(braceClose);
	}
	function walkPackage(node:Package) {
		walkToken(node.packageKeyword);
		if (node.path != null) walkNPath(node.path);
		walkToken(node.semicolon);
	}
	function walkNConstraints_PMultipleConstraints(colon:Token, popen:Token, types:NCommaSeparated<NComplexType>, pclose:Token) {
		walkToken(colon);
		walkToken(popen);
		walkNConstraints_PMultipleConstraints_types(types);
		walkToken(pclose);
	}
	function walkNExpr_PObjectDecl_fl(elems:NCommaSeparatedAllowTrailing<NObjectField>) {
		walkCommaSeparatedTrailing(elems, walkNObjectField);
	}
	function walkNExpr_PConst(const:NConst) {
		walkNConst(const);
	}
	function walkNExpr_PParenthesis(popen:Token, e:NExpr, pclose:Token) {
		walkToken(popen);
		walkNExpr(e);
		walkToken(pclose);
	}
	function walkNComplexType(node:NComplexType) switch node {
		case PFunctionType(type1, arrow, type2):walkNComplexType_PFunctionType(type1, arrow, type2);
		case PStructuralExtension(braceOpen, types, fields, braceClose):walkNComplexType_PStructuralExtension(braceOpen, types, fields, braceClose);
		case PParenthesisType(popen, ct, pclose):walkNComplexType_PParenthesisType(popen, ct, pclose);
		case PAnonymousStructure(braceOpen, fields, braceClose):walkNComplexType_PAnonymousStructure(braceOpen, fields, braceClose);
		case PTypePath(path):walkNComplexType_PTypePath(path);
		case POptionalType(questionmark, type):walkNComplexType_POptionalType(questionmark, type);
	};
	function walkNComplexType_PStructuralExtension_types(elems:Array<NStructuralExtension>) {
		walkArray(elems, walkNStructuralExtension);
	}
	function walkNMacroExpr_PExpr(e:NExpr) {
		walkNExpr(e);
	}
	function walkNExpr_PBreak(_break:Token) {
		walkToken(_break);
	}
	function walkNModifier_PModifierInline(token:Token) {
		walkToken(token);
	}
	function walkNClassField_PVariableField(annotations:NAnnotations, modifiers:Array<NModifier>, _var:Token, name:Token, typeHint:Null<NTypeHint>, assignment:Null<NAssignment>, semicolon:Token) {
		walkNAnnotations(annotations);
		walkNClassField_PVariableField_modifiers(modifiers);
		walkToken(_var);
		walkToken(name);
		if (typeHint != null) walkNTypeHint(typeHint);
		if (assignment != null) walkNAssignment(assignment);
		walkToken(semicolon);
	}
	function walkNTypeDeclParameters_params(elems:NCommaSeparated<NTypeDeclParameter>) {
		walkCommaSeparated(elems, walkNTypeDeclParameter);
	}
	function walkNMacroExpr_PTypeHint(type:NTypeHint) {
		walkNTypeHint(type);
	}
	function walkNExpr_PArrayDecl(bkopen:Token, el:Null<NCommaSeparatedAllowTrailing<NExpr>>, bkclose:Token) {
		walkToken(bkopen);
		if (el != null) walkNExpr_PArrayDecl_el(el);
		walkToken(bkclose);
	}
	function walkNAssignment(node:NAssignment) {
		walkToken(node.assign);
		walkNExpr(node.e);
	}
	function walkNComplexType_POptionalType(questionmark:Token, type:NComplexType) {
		walkToken(questionmark);
		walkNComplexType(type);
	}
	function walkNComplexType_PAnonymousStructure(braceOpen:Token, fields:NAnonymousTypeFields, braceClose:Token) {
		walkToken(braceOpen);
		walkNAnonymousTypeFields(fields);
		walkToken(braceClose);
	}
	function walkNCase_PDefault_el(elems:Array<NBlockElement>) {
		walkArray(elems, walkNBlockElement);
	}
	function walkNCallArgs_args(elems:NCommaSeparated<NExpr>) {
		walkCommaSeparated(elems, walkNExpr);
	}
	function walkNAbstractRelation(node:NAbstractRelation) switch node {
		case PFrom(_from, type):walkNAbstractRelation_PFrom(_from, type);
		case PTo(_to, type):walkNAbstractRelation_PTo(_to, type);
	};
	function walkNExpr_PObjectDecl(braceOpen:Token, fl:NCommaSeparatedAllowTrailing<NObjectField>, braceClose:Token) {
		walkToken(braceOpen);
		walkNExpr_PObjectDecl_fl(fl);
		walkToken(braceClose);
	}
	function walkNCatch(node:NCatch) {
		walkToken(node._catch);
		walkToken(node.popen);
		walkToken(node.ident);
		walkNTypeHint(node.type);
		walkToken(node.pclose);
		walkNExpr(node.e);
	}
	function walkNAbstractRelation_PTo(_to:Token, type:NComplexType) {
		walkToken(_to);
		walkNComplexType(type);
	}
	function walkNTypeDeclParameter(node:NTypeDeclParameter) {
		walkNAnnotations(node.annotations);
		walkToken(node.name);
		walkNConstraints(node.constraints);
	}
	function walkNExpr_PIntDot(int:Token, dot:Token) {
		walkToken(int);
		walkToken(dot);
	}
	function walkNComplexType_PParenthesisType(popen:Token, ct:NComplexType, pclose:Token) {
		walkToken(popen);
		walkNComplexType(ct);
		walkToken(pclose);
	}
	function walkImportMode_IAs(asKeyword:Token, ident:Token) {
		walkToken(asKeyword);
		walkToken(ident);
	}
	function walkNModifier(node:NModifier) switch node {
		case PModifierStatic(token):walkNModifier_PModifierStatic(token);
		case PModifierOverride(token):walkNModifier_PModifierOverride(token);
		case PModifierMacro(token):walkNModifier_PModifierMacro(token);
		case PModifierDynamic(token):walkNModifier_PModifierDynamic(token);
		case PModifierInline(token):walkNModifier_PModifierInline(token);
		case PModifierPrivate(token):walkNModifier_PModifierPrivate(token);
		case PModifierPublic(token):walkNModifier_PModifierPublic(token);
	};
	function walkNFieldExpr(node:NFieldExpr) switch node {
		case PNoFieldExpr(semicolon):walkNFieldExpr_PNoFieldExpr(semicolon);
		case PBlockFieldExpr(e):walkNFieldExpr_PBlockFieldExpr(e);
		case PExprFieldExpr(e, semicolon):walkNFieldExpr_PExprFieldExpr(e, semicolon);
	};
	function walkNCase_PDefault(_default:Token, colon:Token, el:Array<NBlockElement>) {
		walkToken(_default);
		walkToken(colon);
		walkNCase_PDefault_el(el);
	}
	function walkNMetadata_PMetadataWithArgs(name:Token, el:NCommaSeparated<NExpr>, pclose:Token) {
		walkToken(name);
		walkNMetadata_PMetadataWithArgs_el(el);
		walkToken(pclose);
	}
	function walkNCommonFlag(node:NCommonFlag) switch node {
		case PExtern(token):walkNCommonFlag_PExtern(token);
		case PPrivate(token):walkNCommonFlag_PPrivate(token);
	};
	function walkNModifier_PModifierDynamic(token:Token) {
		walkToken(token);
	}
	function walkNClassField_PFunctionField_modifiers(elems:Array<NModifier>) {
		walkArray(elems, walkNModifier);
	}
	function walkNExpr_PArray(e1:NExpr, bkopen:Token, e2:NExpr, bkclose:Token) {
		walkNExpr(e1);
		walkToken(bkopen);
		walkNExpr(e2);
		walkToken(bkclose);
	}
	function walkNBlockElement_PVar(_var:Token, vl:NCommaSeparated<NVarDeclaration>, semicolon:Token) {
		walkToken(_var);
		walkNBlockElement_PVar_vl(vl);
		walkToken(semicolon);
	}
	function walkNTypePathParameter_PArrayExprTypePathParameter(bkopen:Token, el:Null<NCommaSeparatedAllowTrailing<NExpr>>, bkclose:Token) {
		walkToken(bkopen);
		if (el != null) walkNTypePathParameter_PArrayExprTypePathParameter_el(el);
		walkToken(bkclose);
	}
	function walkClassDecl_relations(elems:Array<NClassRelation>) {
		walkArray(elems, walkNClassRelation);
	}
	function walkNPath(node:NPath) {
		walkToken(node.ident);
		walkNPath_idents(node.idents);
	}
	function walkNAnonymousTypeFields_PAnonymousClassFields_fields(elems:Array<NClassField>) {
		walkArray(elems, walkNClassField);
	}
	function walkNTypePathParameter_PArrayExprTypePathParameter_el(elems:NCommaSeparatedAllowTrailing<NExpr>) {
		walkCommaSeparatedTrailing(elems, walkNExpr);
	}
	function walkNClassField(node:NClassField) switch node {
		case PPropertyField(annotations, modifiers, _var, name, popen, get, comma, set, pclose, typeHint, assignment):walkNClassField_PPropertyField(annotations, modifiers, _var, name, popen, get, comma, set, pclose, typeHint, assignment);
		case PVariableField(annotations, modifiers, _var, name, typeHint, assignment, semicolon):walkNClassField_PVariableField(annotations, modifiers, _var, name, typeHint, assignment, semicolon);
		case PFunctionField(annotations, modifiers, _function, name, params, popen, args, pclose, typeHint, e):walkNClassField_PFunctionField(annotations, modifiers, _function, name, params, popen, args, pclose, typeHint, e);
	};
	function walkNModifier_PModifierOverride(token:Token) {
		walkToken(token);
	}
	function walkNClassRelation(node:NClassRelation) switch node {
		case PExtends(_extends, path):walkNClassRelation_PExtends(_extends, path);
		case PImplements(_implements, path):walkNClassRelation_PImplements(_implements, path);
	};
	function walkNExpr_PContinue(_continue:Token) {
		walkToken(_continue);
	}
	function walkNStructuralExtension(node:NStructuralExtension) {
		walkToken(node.gt);
		walkNTypePath(node.path);
		walkToken(node.comma);
	}
	function walkNVarDeclaration(node:NVarDeclaration) {
		walkToken(node.name);
		if (node.type != null) walkNTypeHint(node.type);
		if (node.assignment != null) walkNAssignment(node.assignment);
	}
	function walkNClassField_PFunctionField(annotations:NAnnotations, modifiers:Array<NModifier>, _function:Token, name:Token, params:Null<NTypeDeclParameters>, popen:Token, args:Null<NCommaSeparated<NFunctionArgument>>, pclose:Token, typeHint:Null<NTypeHint>, e:Null<NFieldExpr>) {
		walkNAnnotations(annotations);
		walkNClassField_PFunctionField_modifiers(modifiers);
		walkToken(_function);
		walkToken(name);
		if (params != null) walkNTypeDeclParameters(params);
		walkToken(popen);
		if (args != null) walkNClassField_PFunctionField_args(args);
		walkToken(pclose);
		if (typeHint != null) walkNTypeHint(typeHint);
		if (e != null) walkNFieldExpr(e);
	}
	function walkNModifier_PModifierStatic(token:Token) {
		walkToken(token);
	}
	function walkDecl_EnumDecl_flags(elems:Array<NCommonFlag>) {
		walkArray(elems, walkNCommonFlag);
	}
	function walkNObjectField(node:NObjectField) {
		walkNObjectFieldName(node.name);
		walkToken(node.colon);
		walkNExpr(node.e);
	}
	function walkNLiteral_PLiteralString(s:NString) {
		walkNString(s);
	}
	function walkNExpr_PBinop(e1:NExpr, op:Token, e2:NExpr) {
		walkNExpr(e1);
		walkToken(op);
		walkNExpr(e2);
	}
	function walkNBlockElement_PExpr(e:NExpr, semicolon:Token) {
		walkNExpr(e);
		walkToken(semicolon);
	}
	function walkNAnnotations_meta(elems:Array<NMetadata>) {
		walkArray(elems, walkNMetadata);
	}
	function walkNComplexType_PFunctionType(type1:NComplexType, arrow:Token, type2:NComplexType) {
		walkNComplexType(type1);
		walkToken(arrow);
		walkNComplexType(type2);
	}
	function walkNMetadata_PMetadata(name:Token) {
		walkToken(name);
	}
	function walkNLiteral(node:NLiteral) switch node {
		case PLiteralString(s):walkNLiteral_PLiteralString(s);
		case PLiteralFloat(token):walkNLiteral_PLiteralFloat(token);
		case PLiteralRegex(token):walkNLiteral_PLiteralRegex(token);
		case PLiteralInt(token):walkNLiteral_PLiteralInt(token);
	};
	function walkNExpr_PFunction(_function:Token, f:NFunction) {
		walkToken(_function);
		walkNFunction(f);
	}
	function walkNCase_PCase_patterns(elems:NCommaSeparated<NExpr>) {
		walkCommaSeparated(elems, walkNExpr);
	}
	function walkNLiteral_PLiteralRegex(token:Token) {
		walkToken(token);
	}
	function walkNExpr_PNew(_new:Token, path:NTypePath, el:NCallArgs) {
		walkToken(_new);
		walkNTypePath(path);
		walkNCallArgs(el);
	}
	function walkNExpr_PThrow(_throw:Token, e:NExpr) {
		walkToken(_throw);
		walkNExpr(e);
	}
	function walkDecl_EnumDecl_fields(elems:Array<NEnumField>) {
		walkArray(elems, walkNEnumField);
	}
	function walkNConst(node:NConst) switch node {
		case PConstLiteral(literal):walkNConst_PConstLiteral(literal);
		case PConstIdent(ident):walkNConst_PConstIdent(ident);
	};
	function walkNCommonFlag_PExtern(token:Token) {
		walkToken(token);
	}
	function walkDecl_UsingDecl(usingKeyword:Token, path:NPath, semicolon:Token) {
		walkToken(usingKeyword);
		walkNPath(path);
		walkToken(semicolon);
	}
	function walkDecl_AbstractDecl_fields(elems:Array<NClassField>) {
		walkArray(elems, walkNClassField);
	}
	function walkNTypePathParameters(node:NTypePathParameters) {
		walkToken(node.lt);
		walkNTypePathParameters_parameters(node.parameters);
		walkToken(node.gt);
	}
	function walkNClassField_PVariableField_modifiers(elems:Array<NModifier>) {
		walkArray(elems, walkNModifier);
	}
	function walkClassDecl_fields(elems:Array<NClassField>) {
		walkArray(elems, walkNClassField);
	}
	function walkNExpr_PTry(_try:Token, e:NExpr, catches:Array<NCatch>) {
		walkToken(_try);
		walkNExpr(e);
		walkNExpr_PTry_catches(catches);
	}
	function walkNExpr_PCall(e:NExpr, el:NCallArgs) {
		walkNExpr(e);
		walkNCallArgs(el);
	}
	function walkNFunctionArgument(node:NFunctionArgument) {
		walkNAnnotations(node.annotations);
		if (node.questionmark != null) walkToken(node.questionmark);
		walkToken(node.name);
		if (node.typeHint != null) walkNTypeHint(node.typeHint);
		if (node.assignment != null) walkNAssignment(node.assignment);
	}
	function walkNExpr_PTernary(e1:NExpr, questionmark:Token, e2:NExpr, colon:Token, e3:NExpr) {
		walkNExpr(e1);
		walkToken(questionmark);
		walkNExpr(e2);
		walkToken(colon);
		walkNExpr(e3);
	}
	function walkNTypeDeclParameters(node:NTypeDeclParameters) {
		walkToken(node.lt);
		walkNTypeDeclParameters_params(node.params);
		walkToken(node.gt);
	}
	function walkNConst_PConstIdent(ident:Token) {
		walkToken(ident);
	}
	function walkNExpr_PUnaryPrefix(op:Token, e:NExpr) {
		walkToken(op);
		walkNExpr(e);
	}
	function walkNExpr_PUntyped(_untyped:Token, e:NExpr) {
		walkToken(_untyped);
		walkNExpr(e);
	}
	function walkNConstraints(node:NConstraints) switch node {
		case PMultipleConstraints(colon, popen, types, pclose):walkNConstraints_PMultipleConstraints(colon, popen, types, pclose);
		case PSingleConstraint(colon, type):walkNConstraints_PSingleConstraint(colon, type);
		case PNoConstraints:{ };
	};
	function walkNCase(node:NCase) switch node {
		case PCase(_case, patterns, guard, colon, el):walkNCase_PCase(_case, patterns, guard, colon, el);
		case PDefault(_default, colon, el):walkNCase_PDefault(_default, colon, el);
	};
	function walkNConstraints_PSingleConstraint(colon:Token, type:NComplexType) {
		walkToken(colon);
		walkNComplexType(type);
	}
	function walkNComplexType_PTypePath(path:NTypePath) {
		walkNTypePath(path);
	}
	function walkNFieldExpr_PExprFieldExpr(e:NExpr, semicolon:Token) {
		walkNExpr(e);
		walkToken(semicolon);
	}
	function walkDecl_ClassDecl_flags(elems:Array<NCommonFlag>) {
		walkArray(elems, walkNCommonFlag);
	}
	function walkNString(node:NString) switch node {
		case PString(s):walkNString_PString(s);
		case PString2(s):walkNString_PString2(s);
	};
	function walkNAbstractRelation_PFrom(_from:Token, type:NComplexType) {
		walkToken(_from);
		walkNComplexType(type);
	}
	function walkNAnnotations(node:NAnnotations) {
		if (node.doc != null) walkToken(node.doc);
		walkNAnnotations_meta(node.meta);
	}
	function walkNLiteral_PLiteralFloat(token:Token) {
		walkToken(token);
	}
	function walkNExpr_PIf(_if:Token, popen:Token, e1:NExpr, pclose:Token, e2:NExpr, elseExpr:Null<NExprElse>) {
		walkToken(_if);
		walkToken(popen);
		walkNExpr(e1);
		walkToken(pclose);
		walkNExpr(e2);
		if (elseExpr != null) walkNExprElse(elseExpr);
	}
	function walkNDotIdent(node:NDotIdent) switch node {
		case PDotIdent(name):walkNDotIdent_PDotIdent(name);
		case PDot(_dot):walkNDotIdent_PDot(_dot);
	};
	function walkNExpr_PCheckType(popen:Token, e:NExpr, colon:Token, type:NComplexType, pclose:Token) {
		walkToken(popen);
		walkNExpr(e);
		walkToken(colon);
		walkNComplexType(type);
		walkToken(pclose);
	}
	function walkNExpr_PUnaryPostfix(e:NExpr, op:Token) {
		walkNExpr(e);
		walkToken(op);
	}
	function walkNFieldExpr_PNoFieldExpr(semicolon:Token) {
		walkToken(semicolon);
	}
	function walkNTypePathParameter_PTypeTypePathParameter(type:NComplexType) {
		walkNComplexType(type);
	}
	function walkDecl_TypedefDecl(annotations:NAnnotations, flags:Array<NCommonFlag>, typedefKeyword:Token, name:Token, params:Null<NTypeDeclParameters>, assign:Token, type:NComplexType, semicolon:Null<Token>) {
		walkNAnnotations(annotations);
		walkDecl_TypedefDecl_flags(flags);
		walkToken(typedefKeyword);
		walkToken(name);
		if (params != null) walkNTypeDeclParameters(params);
		walkToken(assign);
		walkNComplexType(type);
		if (semicolon != null) walkToken(semicolon);
	}
	function walkNTypePathParameters_parameters(elems:NCommaSeparated<NTypePathParameter>) {
		walkCommaSeparated(elems, walkNTypePathParameter);
	}
	function walkNExpr_PMacro(_macro:Token, e:NMacroExpr) {
		walkToken(_macro);
		walkNMacroExpr(e);
	}
	function walkDecl_TypedefDecl_flags(elems:Array<NCommonFlag>) {
		walkArray(elems, walkNCommonFlag);
	}
	function walkImportMode_IIn(inKeyword:Token, ident:Token) {
		walkToken(inKeyword);
		walkToken(ident);
	}
	function walkNModifier_PModifierPublic(token:Token) {
		walkToken(token);
	}
	function walkNExpr_PBlock_elems(elems:Array<NBlockElement>) {
		walkArray(elems, walkNBlockElement);
	}
	function walkNFunction_args(elems:NCommaSeparated<NFunctionArgument>) {
		walkCommaSeparated(elems, walkNFunctionArgument);
	}
	function walkNModifier_PModifierMacro(token:Token) {
		walkToken(token);
	}
	function walkNConstraints_PMultipleConstraints_types(elems:NCommaSeparated<NComplexType>) {
		walkCommaSeparated(elems, walkNComplexType);
	}
	function walkNLiteral_PLiteralInt(token:Token) {
		walkToken(token);
	}
	function walkNBlockElement_PInlineFunction(_inline:Token, _function:Token, f:NFunction, semicolon:Token) {
		walkToken(_inline);
		walkToken(_function);
		walkNFunction(f);
		walkToken(semicolon);
	}
	function walkNCase_PCase_el(elems:Array<NBlockElement>) {
		walkArray(elems, walkNBlockElement);
	}
	function walkNExpr_PIn(e1:NExpr, _in:Token, e2:NExpr) {
		walkNExpr(e1);
		walkToken(_in);
		walkNExpr(e2);
	}
	function walkNClassField_PPropertyField(annotations:NAnnotations, modifiers:Array<NModifier>, _var:Token, name:Token, popen:Token, get:Token, comma:Token, set:Token, pclose:Token, typeHint:Null<NTypeHint>, assignment:Null<NAssignment>) {
		walkNAnnotations(annotations);
		walkNClassField_PPropertyField_modifiers(modifiers);
		walkToken(_var);
		walkToken(name);
		walkToken(popen);
		walkToken(get);
		walkToken(comma);
		walkToken(set);
		walkToken(pclose);
		if (typeHint != null) walkNTypeHint(typeHint);
		if (assignment != null) walkNAssignment(assignment);
	}
	function walkNAnonymousTypeFields_PAnonymousClassFields(fields:Array<NClassField>) {
		walkNAnonymousTypeFields_PAnonymousClassFields_fields(fields);
	}
	function walkNAnonymousTypeField(node:NAnonymousTypeField) {
		if (node.questionmark != null) walkToken(node.questionmark);
		walkToken(node.name);
		walkNTypeHint(node.typeHint);
	}
	function walkNUnderlyingType(node:NUnderlyingType) {
		walkToken(node.popen);
		walkNComplexType(node.type);
		walkToken(node.pclose);
	}
	function walkFile_decls(elems:Array<Decl>) {
		walkArray(elems, walkDecl);
	}
	function walkDecl(node:Decl) switch node {
		case ClassDecl(annotations, flags, classDecl):walkDecl_ClassDecl(annotations, flags, classDecl);
		case TypedefDecl(annotations, flags, typedefKeyword, name, params, assign, type, semicolon):walkDecl_TypedefDecl(annotations, flags, typedefKeyword, name, params, assign, type, semicolon);
		case EnumDecl(annotations, flags, enumKeyword, name, params, braceOpen, fields, braceClose):walkDecl_EnumDecl(annotations, flags, enumKeyword, name, params, braceOpen, fields, braceClose);
		case UsingDecl(usingKeyword, path, semicolon):walkDecl_UsingDecl(usingKeyword, path, semicolon);
		case AbstractDecl(annotations, flags, abstractKeyword, name, params, underlyingType, relations, braceOpen, fields, braceClose):walkDecl_AbstractDecl(annotations, flags, abstractKeyword, name, params, underlyingType, relations, braceOpen, fields, braceClose);
		case ImportDecl(importKeyword, path, mode, semicolon):walkDecl_ImportDecl(importKeyword, path, mode, semicolon);
	};
	function walkNGuard(node:NGuard) {
		walkToken(node._if);
		walkToken(node.popen);
		walkNExpr(node.e);
		walkToken(node.pclose);
	}
	function walkNMacroExpr(node:NMacroExpr) switch node {
		case PVar(_var, v):walkNMacroExpr_PVar(_var, v);
		case PTypeHint(type):walkNMacroExpr_PTypeHint(type);
		case PClass(c):walkNMacroExpr_PClass(c);
		case PExpr(e):walkNMacroExpr_PExpr(e);
	};
	function walkNEnumField(node:NEnumField) {
		walkNAnnotations(node.annotations);
		walkToken(node.name);
		if (node.params != null) walkNTypeDeclParameters(node.params);
		if (node.args != null) walkNEnumFieldArgs(node.args);
		if (node.type != null) walkNTypeHint(node.type);
		walkToken(node.semicolon);
	}
	function walkNBlockElement(node:NBlockElement) switch node {
		case PVar(_var, vl, semicolon):walkNBlockElement_PVar(_var, vl, semicolon);
		case PExpr(e, semicolon):walkNBlockElement_PExpr(e, semicolon);
		case PInlineFunction(_inline, _function, f, semicolon):walkNBlockElement_PInlineFunction(_inline, _function, f, semicolon);
	};
	function walkNExpr_PSwitch(_switch:Token, e:NExpr, braceOpen:Token, cases:Array<NCase>, braceClose:Token) {
		walkToken(_switch);
		walkNExpr(e);
		walkToken(braceOpen);
		walkNExpr_PSwitch_cases(cases);
		walkToken(braceClose);
	}
	function walkNExpr_PField(e:NExpr, ident:NDotIdent) {
		walkNExpr(e);
		walkNDotIdent(ident);
	}
	function walkNExpr_PFor(_for:Token, popen:Token, e1:NExpr, pclose:Token, e2:NExpr) {
		walkToken(_for);
		walkToken(popen);
		walkNExpr(e1);
		walkToken(pclose);
		walkNExpr(e2);
	}
	function walkDecl_EnumDecl(annotations:NAnnotations, flags:Array<NCommonFlag>, enumKeyword:Token, name:Token, params:Null<NTypeDeclParameters>, braceOpen:Token, fields:Array<NEnumField>, braceClose:Token) {
		walkNAnnotations(annotations);
		walkDecl_EnumDecl_flags(flags);
		walkToken(enumKeyword);
		walkToken(name);
		if (params != null) walkNTypeDeclParameters(params);
		walkToken(braceOpen);
		walkDecl_EnumDecl_fields(fields);
		walkToken(braceClose);
	}
	function walkNEnumFieldArg(node:NEnumFieldArg) {
		if (node.questionmark != null) walkToken(node.questionmark);
		walkToken(node.name);
		walkNTypeHint(node.typeHint);
	}
	function walkNMetadata(node:NMetadata) switch node {
		case PMetadata(name):walkNMetadata_PMetadata(name);
		case PMetadataWithArgs(name, el, pclose):walkNMetadata_PMetadataWithArgs(name, el, pclose);
	};
	function walkNClassRelation_PImplements(_implements:Token, path:NTypePath) {
		walkToken(_implements);
		walkNTypePath(path);
	}
	function walkNTypePath(node:NTypePath) {
		walkNPath(node.path);
		if (node.params != null) walkNTypePathParameters(node.params);
	}
	function walkNExpr_PIs(popen:Token, e:NExpr, _is:Token, path:NTypePath, pclose:Token) {
		walkToken(popen);
		walkNExpr(e);
		walkToken(_is);
		walkNTypePath(path);
		walkToken(pclose);
	}
	function walkNExpr_PWhile(_while:Token, popen:Token, e1:NExpr, pclose:Token, e2:NExpr) {
		walkToken(_while);
		walkToken(popen);
		walkNExpr(e1);
		walkToken(pclose);
		walkNExpr(e2);
	}
	function walkNCase_PCase(_case:Token, patterns:NCommaSeparated<NExpr>, guard:Null<NGuard>, colon:Token, el:Array<NBlockElement>) {
		walkToken(_case);
		walkNCase_PCase_patterns(patterns);
		if (guard != null) walkNGuard(guard);
		walkToken(colon);
		walkNCase_PCase_el(el);
	}
	function walkNObjectFieldName_PIdent(ident:Token) {
		walkToken(ident);
	}
	function walkNExpr_PReturnExpr(_return:Token, e:NExpr) {
		walkToken(_return);
		walkNExpr(e);
	}
	function walkNExpr_PTry_catches(elems:Array<NCatch>) {
		walkArray(elems, walkNCatch);
	}
	function walkNMacroExpr_PVar(_var:Token, v:NCommaSeparated<NVarDeclaration>) {
		walkToken(_var);
		walkNMacroExpr_PVar_v(v);
	}
	function walkNAnonymousTypeFields(node:NAnonymousTypeFields) switch node {
		case PAnonymousClassFields(fields):walkNAnonymousTypeFields_PAnonymousClassFields(fields);
		case PAnonymousShortFields(fields):walkNAnonymousTypeFields_PAnonymousShortFields(fields);
	};
	function walkNAnonymousTypeFields_PAnonymousShortFields_fields(elems:NCommaSeparatedAllowTrailing<NAnonymousTypeField>) {
		walkCommaSeparatedTrailing(elems, walkNAnonymousTypeField);
	}
	function walkNCommonFlag_PPrivate(token:Token) {
		walkToken(token);
	}
	function walkNString_PString(s:Token) {
		walkToken(s);
	}
	function walkNClassField_PFunctionField_args(elems:NCommaSeparated<NFunctionArgument>) {
		walkCommaSeparated(elems, walkNFunctionArgument);
	}
	function walkNFunction(node:NFunction) {
		if (node.ident != null) walkToken(node.ident);
		if (node.params != null) walkNTypeDeclParameters(node.params);
		walkToken(node.popen);
		if (node.args != null) walkNFunction_args(node.args);
		walkToken(node.pclose);
		if (node.type != null) walkNTypeHint(node.type);
		walkNExpr(node.e);
	}
	function walkImportMode_IAll(dotstar:Token) {
		walkToken(dotstar);
	}
	function walkNExpr_PMacroEscape(ident:Token, braceOpen:Token, e:NExpr, braceClose:Token) {
		walkToken(ident);
		walkToken(braceOpen);
		walkNExpr(e);
		walkToken(braceClose);
	}
	function walkNExpr_PReturn(_return:Token) {
		walkToken(_return);
	}
	function walkNExpr_PDollarIdent(ident:Token) {
		walkToken(ident);
	}
	function walkNComplexType_PStructuralExtension(braceOpen:Token, types:Array<NStructuralExtension>, fields:NAnonymousTypeFields, braceClose:Token) {
		walkToken(braceOpen);
		walkNComplexType_PStructuralExtension_types(types);
		walkNAnonymousTypeFields(fields);
		walkToken(braceClose);
	}
	function walkNExprElse(node:NExprElse) {
		walkToken(node._else);
		walkNExpr(node.e);
	}
}