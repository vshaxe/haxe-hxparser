// This file is autogenerated from ParseTree data structures
// Use build-walker.hxml to re-generate!

package hxParser;

import hxParser.ParseTree;

class Walker {
	function walkToken(token:Token) { }
	function walkArray<T>(elems:Array<T>, walk:T -> Void) {
		for (el in elems) walk(el);
	}
	function walkCommaSeparated<T>(elems:NCommaSeparated<T>, walk:T -> Void) {
		walk(elems.arg);
		for (el in elems.args) {
			walkToken(el.comma);
			walk(el.arg);
		};
	}
	function walkCommaSeparatedTrailing<T>(elems:NCommaSeparatedAllowTrailing<T>, walk:T -> Void) {
		walk(elems.arg);
		for (el in elems.args) {
			walkToken(el.comma);
			walk(el.arg);
		};
		if (elems.comma != null) walkToken(elems.comma);
	}
	function walkNFile(node:NFile) {
		if (node.pack != null) walkNPackage(node.pack);
		walkArray(node.decls, function(el) walkNDecl(el));
		walkToken(node.eof);
	}
	function walkNPackage(node:NPackage) {
		walkToken(node._package);
		if (node.path != null) walkNPath(node.path);
		walkToken(node.semicolon);
	}
	function walkNImportMode(node:NImportMode) switch node {
		case PAsMode(_as, ident):{
			walkToken(_as);
			walkToken(ident);
		};
		case PNormalMode:{ };
		case PInMode(_in, ident):{
			walkToken(_in);
			walkToken(ident);
		};
		case PAllMode(dotstar):{
			walkToken(dotstar);
		};
	};
	function walkNLiteral(node:NLiteral) switch node {
		case PLiteralString(s):{
			walkNString(s);
		};
		case PLiteralFloat(token):{
			walkToken(token);
		};
		case PLiteralRegex(token):{
			walkToken(token);
		};
		case PLiteralInt(token):{
			walkToken(token);
		};
	};
	function walkNAssignment(node:NAssignment) {
		walkToken(node.assign);
		walkNExpr(node.e);
	}
	function walkNObjectFieldName(node:NObjectFieldName) switch node {
		case PString(string):{
			walkNString(string);
		};
		case PIdent(ident):{
			walkToken(ident);
		};
	};
	function walkNAbstractRelation(node:NAbstractRelation) switch node {
		case PFrom(_from, type):{
			walkToken(_from);
			walkNComplexType(type);
		};
		case PTo(_to, type):{
			walkToken(_to);
			walkNComplexType(type);
		};
	};
	function walkNTypeHint(node:NTypeHint) {
		walkToken(node.colon);
		walkNComplexType(node.type);
	}
	function walkNClassDecl(node:NClassDecl) {
		walkToken(node.kind);
		walkToken(node.name);
		if (node.params != null) walkNTypeDeclParameters(node.params);
		walkArray(node.relations, function(el) walkNClassRelation(el));
		walkToken(node.bropen);
		walkArray(node.fields, function(el) walkNClassField(el));
		walkToken(node.brclose);
	}
	function walkNCatch(node:NCatch) {
		walkToken(node._catch);
		walkToken(node.popen);
		walkToken(node.ident);
		walkNTypeHint(node.type);
		walkToken(node.pclose);
		walkNExpr(node.e);
	}
	function walkNTypeDeclParameter(node:NTypeDeclParameter) {
		walkNAnnotations(node.annotations);
		walkToken(node.name);
		walkNConstraints(node.constraints);
	}
	function walkNConst(node:NConst) switch node {
		case PConstLiteral(literal):{
			walkNLiteral(literal);
		};
		case PConstIdent(ident):{
			walkToken(ident);
		};
	};
	function walkNTypePathParameters(node:NTypePathParameters) {
		walkToken(node.lt);
		walkCommaSeparated(node.parameters, function(el) walkNTypePathParameter(el));
		walkToken(node.gt);
	}
	function walkNModifier(node:NModifier) switch node {
		case PModifierStatic(token):{
			walkToken(token);
		};
		case PModifierOverride(token):{
			walkToken(token);
		};
		case PModifierMacro(token):{
			walkToken(token);
		};
		case PModifierDynamic(token):{
			walkToken(token);
		};
		case PModifierInline(token):{
			walkToken(token);
		};
		case PModifierPrivate(token):{
			walkToken(token);
		};
		case PModifierPublic(token):{
			walkToken(token);
		};
	};
	function walkNFieldExpr(node:NFieldExpr) switch node {
		case PNoFieldExpr(semicolon):{
			walkToken(semicolon);
		};
		case PBlockFieldExpr(e):{
			walkNExpr(e);
		};
		case PExprFieldExpr(e, semicolon):{
			walkNExpr(e);
			walkToken(semicolon);
		};
	};
	function walkNCommonFlag(node:NCommonFlag) switch node {
		case PExtern(token):{
			walkToken(token);
		};
		case PPrivate(token):{
			walkToken(token);
		};
	};
	function walkNEnumFieldArgs(node:NEnumFieldArgs) {
		walkToken(node.popen);
		if (node.args != null) walkCommaSeparated(node.args, function(el) walkNEnumFieldArg(el));
		walkToken(node.pclose);
	}
	function walkNFunctionArgument(node:NFunctionArgument) {
		walkNAnnotations(node.annotations);
		if (node.questionmark != null) walkToken(node.questionmark);
		walkToken(node.name);
		if (node.typeHint != null) walkNTypeHint(node.typeHint);
		if (node.assignment != null) walkNAssignment(node.assignment);
	}
	function walkNAnonymousTypeField(node:NAnonymousTypeField) {
		if (node.questionmark != null) walkToken(node.questionmark);
		walkToken(node.name);
		walkNTypeHint(node.typeHint);
	}
	function walkNUnderlyingType(node:NUnderlyingType) {
		walkToken(node.popen);
		walkNComplexType(node.type);
		walkToken(node.pclose);
	}
	function walkNTypePathParameter(node:NTypePathParameter) switch node {
		case PArrayExprTypePathParameter(bkopen, el, bkclose):{
			walkToken(bkopen);
			if (el != null) walkCommaSeparatedTrailing(el, function(el) walkNExpr(el));
			walkToken(bkclose);
		};
		case PConstantTypePathParameter(constant):{
			walkNLiteral(constant);
		};
		case PTypeTypePathParameter(type):{
			walkNComplexType(type);
		};
	};
	function walkNTypeDeclParameters(node:NTypeDeclParameters) {
		walkToken(node.lt);
		walkCommaSeparated(node.params, function(el) walkNTypeDeclParameter(el));
		walkToken(node.gt);
	}
	function walkNGuard(node:NGuard) {
		walkToken(node._if);
		walkToken(node.popen);
		walkNExpr(node.e);
		walkToken(node.pclose);
	}
	function walkNMacroExpr(node:NMacroExpr) switch node {
		case PVar(_var, v):{
			walkToken(_var);
			walkCommaSeparated(v, function(el) walkNVarDeclaration(el));
		};
		case PTypeHint(type):{
			walkNTypeHint(type);
		};
		case PClass(c):{
			walkNClassDecl(c);
		};
		case PExpr(e):{
			walkNExpr(e);
		};
	};
	function walkNEnumField(node:NEnumField) {
		walkNAnnotations(node.annotations);
		walkToken(node.name);
		if (node.params != null) walkNTypeDeclParameters(node.params);
		if (node.args != null) walkNEnumFieldArgs(node.args);
		if (node.type != null) walkNTypeHint(node.type);
		walkToken(node.semicolon);
	}
	function walkNPath(node:NPath) {
		walkToken(node.ident);
		walkArray(node.idents, function(el) walkNDotIdent(el));
	}
	function walkNDecl(node:NDecl) switch node {
		case PClassDecl(annotations, flags, c):{
			walkNAnnotations(annotations);
			walkArray(flags, function(el) walkNCommonFlag(el));
			walkNClassDecl(c);
		};
		case PTypedefDecl(annotations, flags, _typedef, name, params, assign, type, semicolon):{
			walkNAnnotations(annotations);
			walkArray(flags, function(el) walkNCommonFlag(el));
			walkToken(_typedef);
			walkToken(name);
			if (params != null) walkNTypeDeclParameters(params);
			walkToken(assign);
			walkNComplexType(type);
			if (semicolon != null) walkToken(semicolon);
		};
		case PUsingDecl(_using, path, semicolon):{
			walkToken(_using);
			walkNPath(path);
			walkToken(semicolon);
		};
		case PImportDecl(_import, importPath, semicolon):{
			walkToken(_import);
			walkNImport(importPath);
			walkToken(semicolon);
		};
		case PAbstractDecl(annotations, flags, _abstract, name, params, underlyingType, relations, bropen, fields, brclose):{
			walkNAnnotations(annotations);
			walkArray(flags, function(el) walkNCommonFlag(el));
			walkToken(_abstract);
			walkToken(name);
			if (params != null) walkNTypeDeclParameters(params);
			if (underlyingType != null) walkNUnderlyingType(underlyingType);
			walkArray(relations, function(el) walkNAbstractRelation(el));
			walkToken(bropen);
			walkArray(fields, function(el) walkNClassField(el));
			walkToken(brclose);
		};
		case PEnumDecl(annotations, flags, _enum, name, params, bropen, fields, brclose):{
			walkNAnnotations(annotations);
			walkArray(flags, function(el) walkNCommonFlag(el));
			walkToken(_enum);
			walkToken(name);
			if (params != null) walkNTypeDeclParameters(params);
			walkToken(bropen);
			walkArray(fields, function(el) walkNEnumField(el));
			walkToken(brclose);
		};
	};
	function walkNConstraints(node:NConstraints) switch node {
		case PMultipleConstraints(colon, popen, types, pclose):{
			walkToken(colon);
			walkToken(popen);
			walkCommaSeparated(types, function(el) walkNComplexType(el));
			walkToken(pclose);
		};
		case PSingleConstraint(colon, type):{
			walkToken(colon);
			walkNComplexType(type);
		};
		case PNoConstraints:{ };
	};
	function walkNBlockElement(node:NBlockElement) switch node {
		case PVar(_var, vl, semicolon):{
			walkToken(_var);
			walkCommaSeparated(vl, function(el) walkNVarDeclaration(el));
			walkToken(semicolon);
		};
		case PExpr(e, semicolon):{
			walkNExpr(e);
			walkToken(semicolon);
		};
		case PInlineFunction(_inline, _function, f, semicolon):{
			walkToken(_inline);
			walkToken(_function);
			walkNFunction(f);
			walkToken(semicolon);
		};
	};
	function walkNClassField(node:NClassField) switch node {
		case PPropertyField(annotations, modifiers, _var, name, popen, get, comma, set, pclose, typeHint, assignment):{
			walkNAnnotations(annotations);
			walkArray(modifiers, function(el) walkNModifier(el));
			walkToken(_var);
			walkToken(name);
			walkToken(popen);
			walkToken(get);
			walkToken(comma);
			walkToken(set);
			walkToken(pclose);
			if (typeHint != null) walkNTypeHint(typeHint);
			if (assignment != null) walkNAssignment(assignment);
		};
		case PVariableField(annotations, modifiers, _var, name, typeHint, assignment, semicolon):{
			walkNAnnotations(annotations);
			walkArray(modifiers, function(el) walkNModifier(el));
			walkToken(_var);
			walkToken(name);
			if (typeHint != null) walkNTypeHint(typeHint);
			if (assignment != null) walkNAssignment(assignment);
			walkToken(semicolon);
		};
		case PFunctionField(annotations, modifiers, _function, name, params, popen, args, pclose, typeHint, e):{
			walkNAnnotations(annotations);
			walkArray(modifiers, function(el) walkNModifier(el));
			walkToken(_function);
			walkToken(name);
			if (params != null) walkNTypeDeclParameters(params);
			walkToken(popen);
			if (args != null) walkCommaSeparated(args, function(el) walkNFunctionArgument(el));
			walkToken(pclose);
			if (typeHint != null) walkNTypeHint(typeHint);
			if (e != null) walkNFieldExpr(e);
		};
	};
	function walkNClassRelation(node:NClassRelation) switch node {
		case PExtends(_extends, path):{
			walkToken(_extends);
			walkNTypePath(path);
		};
		case PImplements(_implements, path):{
			walkToken(_implements);
			walkNTypePath(path);
		};
	};
	function walkNCase(node:NCase) switch node {
		case PCase(_case, patterns, guard, colon, el):{
			walkToken(_case);
			walkCommaSeparated(patterns, function(el) walkNExpr(el));
			if (guard != null) walkNGuard(guard);
			walkToken(colon);
			walkArray(el, function(el) walkNBlockElement(el));
		};
		case PDefault(_default, colon, el):{
			walkToken(_default);
			walkToken(colon);
			walkArray(el, function(el) walkNBlockElement(el));
		};
	};
	function walkNStructuralExtension(node:NStructuralExtension) {
		walkToken(node.gt);
		walkNTypePath(node.path);
		walkToken(node.comma);
	}
	function walkNEnumFieldArg(node:NEnumFieldArg) {
		if (node.questionmark != null) walkToken(node.questionmark);
		walkToken(node.name);
		walkNTypeHint(node.typeHint);
	}
	function walkNMetadata(node:NMetadata) switch node {
		case PMetadata(name):{
			walkToken(name);
		};
		case PMetadataWithArgs(name, el, pclose):{
			walkToken(name);
			walkCommaSeparated(el, function(el) walkNExpr(el));
			walkToken(pclose);
		};
	};
	function walkNVarDeclaration(node:NVarDeclaration) {
		walkToken(node.name);
		if (node.type != null) walkNTypeHint(node.type);
		if (node.assignment != null) walkNAssignment(node.assignment);
	}
	function walkNTypePath(node:NTypePath) {
		walkNPath(node.path);
		if (node.params != null) walkNTypePathParameters(node.params);
	}
	function walkNString(node:NString) switch node {
		case PString(s):{
			walkToken(s);
		};
		case PString2(s):{
			walkToken(s);
		};
	};
	function walkNAnnotations(node:NAnnotations) {
		if (node.doc != null) walkToken(node.doc);
		walkArray(node.meta, function(el) walkNMetadata(el));
	}
	function walkNExpr(node:NExpr) switch node {
		case PVar(_var, d):{
			walkToken(_var);
			walkNVarDeclaration(d);
		};
		case PConst(const):{
			walkNConst(const);
		};
		case PDo(_do, e1, _while, popen, e2, pclose):{
			walkToken(_do);
			walkNExpr(e1);
			walkToken(_while);
			walkToken(popen);
			walkNExpr(e2);
			walkToken(pclose);
		};
		case PMacro(_macro, e):{
			walkToken(_macro);
			walkNMacroExpr(e);
		};
		case PWhile(_while, popen, e1, pclose, e2):{
			walkToken(_while);
			walkToken(popen);
			walkNExpr(e1);
			walkToken(pclose);
			walkNExpr(e2);
		};
		case PIntDot(int, dot):{
			walkToken(int);
			walkToken(dot);
		};
		case PBlock(bropen, elems, brclose):{
			walkToken(bropen);
			walkArray(elems, function(el) walkNBlockElement(el));
			walkToken(brclose);
		};
		case PFunction(_function, f):{
			walkToken(_function);
			walkNFunction(f);
		};
		case PSwitch(_switch, e, bropen, cases, brclose):{
			walkToken(_switch);
			walkNExpr(e);
			walkToken(bropen);
			walkArray(cases, function(el) walkNCase(el));
			walkToken(brclose);
		};
		case PReturn(_return):{
			walkToken(_return);
		};
		case PArrayDecl(bkopen, el, bkclose):{
			walkToken(bkopen);
			if (el != null) walkCommaSeparatedTrailing(el, function(el) walkNExpr(el));
			walkToken(bkclose);
		};
		case PIf(_if, popen, e1, pclose, e2, elseExpr):{
			walkToken(_if);
			walkToken(popen);
			walkNExpr(e1);
			walkToken(pclose);
			walkNExpr(e2);
			if (elseExpr != null) walkNExprElse(elseExpr);
		};
		case PReturnExpr(_return, e):{
			walkToken(_return);
			walkNExpr(e);
		};
		case PArray(e1, bkopen, e2, bkclose):{
			walkNExpr(e1);
			walkToken(bkopen);
			walkNExpr(e2);
			walkToken(bkclose);
		};
		case PContinue(_continue):{
			walkToken(_continue);
		};
		case PParenthesis(popen, e, pclose):{
			walkToken(popen);
			walkNExpr(e);
			walkToken(pclose);
		};
		case PTry(_try, e, catches):{
			walkToken(_try);
			walkNExpr(e);
			walkArray(catches, function(el) walkNCatch(el));
		};
		case PBreak(_break):{
			walkToken(_break);
		};
		case PCall(e, el):{
			walkNExpr(e);
			walkNCallArgs(el);
		};
		case PUnaryPostfix(e, op):{
			walkNExpr(e);
			walkToken(op);
		};
		case PBinop(e1, op, e2):{
			walkNExpr(e1);
			walkToken(op);
			walkNExpr(e2);
		};
		case PSafeCast(_cast, popen, e, comma, ct, pclose):{
			walkToken(_cast);
			walkToken(popen);
			walkNExpr(e);
			walkToken(comma);
			walkNComplexType(ct);
			walkToken(pclose);
		};
		case PUnaryPrefix(op, e):{
			walkToken(op);
			walkNExpr(e);
		};
		case PMacroEscape(ident, bropen, e, brclose):{
			walkToken(ident);
			walkToken(bropen);
			walkNExpr(e);
			walkToken(brclose);
		};
		case PIn(e1, _in, e2):{
			walkNExpr(e1);
			walkToken(_in);
			walkNExpr(e2);
		};
		case PMetadata(metadata, e):{
			walkNMetadata(metadata);
			walkNExpr(e);
		};
		case PUnsafeCast(_cast, e):{
			walkToken(_cast);
			walkNExpr(e);
		};
		case PCheckType(popen, e, colon, type, pclose):{
			walkToken(popen);
			walkNExpr(e);
			walkToken(colon);
			walkNComplexType(type);
			walkToken(pclose);
		};
		case PUntyped(_untyped, e):{
			walkToken(_untyped);
			walkNExpr(e);
		};
		case PField(e, ident):{
			walkNExpr(e);
			walkNDotIdent(ident);
		};
		case PIs(popen, e, _is, path, pclose):{
			walkToken(popen);
			walkNExpr(e);
			walkToken(_is);
			walkNTypePath(path);
			walkToken(pclose);
		};
		case PTernary(e1, questionmark, e2, colon, e3):{
			walkNExpr(e1);
			walkToken(questionmark);
			walkNExpr(e2);
			walkToken(colon);
			walkNExpr(e3);
		};
		case PObjectDecl(bropen, fl, brclose):{
			walkToken(bropen);
			walkCommaSeparatedTrailing(fl, function(el) walkNObjectField(el));
			walkToken(brclose);
		};
		case PNew(_new, path, el):{
			walkToken(_new);
			walkNTypePath(path);
			walkNCallArgs(el);
		};
		case PThrow(_throw, e):{
			walkToken(_throw);
			walkNExpr(e);
		};
		case PFor(_for, popen, e1, pclose, e2):{
			walkToken(_for);
			walkToken(popen);
			walkNExpr(e1);
			walkToken(pclose);
			walkNExpr(e2);
		};
	};
	function walkNAnonymousTypeFields(node:NAnonymousTypeFields) switch node {
		case PAnonymousClassFields(fields):{
			walkArray(fields, function(el) walkNClassField(el));
		};
		case PAnonymousShortFields(fields):{
			if (fields != null) walkCommaSeparatedTrailing(fields, function(el) walkNAnonymousTypeField(el));
		};
	};
	function walkNCallArgs(node:NCallArgs) {
		walkToken(node.popen);
		if (node.args != null) walkCommaSeparated(node.args, function(el) walkNExpr(el));
		walkToken(node.pclose);
	}
	function walkNDotIdent(node:NDotIdent) switch node {
		case PDotIdent(name):{
			walkToken(name);
		};
		case PDot(_dot):{
			walkToken(_dot);
		};
	};
	function walkNObjectField(node:NObjectField) {
		walkNObjectFieldName(node.name);
		walkToken(node.colon);
		walkNExpr(node.e);
	}
	function walkNFunction(node:NFunction) {
		if (node.ident != null) walkToken(node.ident);
		if (node.params != null) walkNTypeDeclParameters(node.params);
		walkToken(node.popen);
		if (node.args != null) walkCommaSeparated(node.args, function(el) walkNFunctionArgument(el));
		walkToken(node.pclose);
		if (node.type != null) walkNTypeHint(node.type);
		walkNExpr(node.e);
	}
	function walkNImport(node:NImport) {
		walkNPath(node.path);
		walkNImportMode(node.mode);
	}
	function walkNComplexType(node:NComplexType) switch node {
		case PFunctionType(type1, arrow, type2):{
			walkNComplexType(type1);
			walkToken(arrow);
			walkNComplexType(type2);
		};
		case PStructuralExtension(bropen, types, fields, brclose):{
			walkToken(bropen);
			walkArray(types, function(el) walkNStructuralExtension(el));
			walkNAnonymousTypeFields(fields);
			walkToken(brclose);
		};
		case PParenthesisType(popen, ct, pclose):{
			walkToken(popen);
			walkNComplexType(ct);
			walkToken(pclose);
		};
		case PAnoymousStructure(bropen, fields, brclose):{
			walkToken(bropen);
			walkNAnonymousTypeFields(fields);
			walkToken(brclose);
		};
		case PTypePath(path):{
			walkNTypePath(path);
		};
		case POptionalType(questionmark, type):{
			walkToken(questionmark);
			walkNComplexType(type);
		};
	};
	function walkNExprElse(node:NExprElse) {
		walkToken(node._else);
		walkNExpr(node.e);
	}
}