// This file is autogenerated from ParseTree data structures
// Use build-walker.hxml to re-generate!

package hxParser;

import hxParser.ParseTree;

@:publicFields class Walker {
	function walkToken(token:Token) { }
	function walkArray<T>(elems:Array<T>, walk:T -> Void) {
		for (el in elems) walk(el);
	}
	function walkCommaSeparated<T>(elems:CommaSeparated<T>, walk:T -> Void) {
		walk(elems.arg);
		for (el in elems.args) {
			walkToken(el.comma);
			walk(el.arg);
		};
	}
	function walkCommaSeparatedTrailing<T>(elems:CommaSeparatedAllowTrailing<T>, walk:T -> Void) {
		walk(elems.arg);
		for (el in elems.args) {
			walkToken(el.comma);
			walk(el.arg);
		};
		if (elems.comma != null) walkToken(elems.comma);
	}
	function walkClassField_Property(annotations:NAnnotations, modifiers:Array<FieldModifier>, varKeyword:Token, name:Token, parenOpen:Token, read:Token, comma:Token, write:Token, parenClose:Token, typeHint:Null<TypeHint>, assignment:Null<Assignment>, semicolon:Token) {
		walkNAnnotations(annotations);
		walkClassField_Property_modifiers(modifiers);
		walkToken(varKeyword);
		walkToken(name);
		walkToken(parenOpen);
		walkToken(read);
		walkToken(comma);
		walkToken(write);
		walkToken(parenClose);
		if (typeHint != null) walkTypeHint(typeHint);
		if (assignment != null) walkAssignment(assignment);
		walkToken(semicolon);
	}
	function walkExpr_EObjectDecl_fields(elems:CommaSeparatedAllowTrailing<ObjectField>) {
		walkCommaSeparatedTrailing(elems, walkObjectField);
	}
	function walkStringToken(node:StringToken) switch node {
		case DoubleQuote(var token):walkStringToken_DoubleQuote(token);
		case SingleQuote(var token):walkStringToken_SingleQuote(token);
	};
	function walkCase_Case(caseKeyword:Token, patterns:CommaSeparated<Expr>, guard:Null<Guard>, colon:Token, body:Array<BlockElement>) {
		walkToken(caseKeyword);
		walkCase_Case_patterns(patterns);
		if (guard != null) walkGuard(guard);
		walkToken(colon);
		walkCase_Case_body(body);
	}
	function walkDecl(node:Decl) switch node {
		case AbstractDecl(var decl):walkDecl_AbstractDecl(decl);
		case ImportDecl(var decl):walkDecl_ImportDecl(decl);
		case TypedefDecl(var decl):walkDecl_TypedefDecl(decl);
		case UsingDecl(var decl):walkDecl_UsingDecl(decl);
		case ClassDecl(var decl):walkDecl_ClassDecl(decl);
		case EnumDecl(var decl):walkDecl_EnumDecl(decl);
	};
	function walkFieldModifier(node:FieldModifier) switch node {
		case Macro(var keyword):walkFieldModifier_Macro(keyword);
		case Public(var keyword):walkFieldModifier_Public(keyword);
		case Private(var keyword):walkFieldModifier_Private(keyword);
		case Static(var keyword):walkFieldModifier_Static(keyword);
		case Inline(var keyword):walkFieldModifier_Inline(keyword);
		case Override(var keyword):walkFieldModifier_Override(keyword);
		case Dynamic(var keyword):walkFieldModifier_Dynamic(keyword);
	};
	function walkExpr_EBlock_elems(elems:Array<BlockElement>) {
		walkArray(elems, walkBlockElement);
	}
	function walkFunctionArgument(node:FunctionArgument) {
		walkNAnnotations(node.annotations);
		if (node.questionMark != null) walkToken(node.questionMark);
		walkToken(node.name);
		if (node.typeHint != null) walkTypeHint(node.typeHint);
		if (node.assignment != null) walkAssignment(node.assignment);
	}
	function walkExpr_EBinop(exprLeft:Expr, op:Token, exprRight:Expr) {
		walkExpr(exprLeft);
		walkToken(op);
		walkExpr(exprRight);
	}
	function walkFieldModifier_Macro(keyword:Token) {
		walkToken(keyword);
	}
	function walkExpr_ETry(tryKeyword:Token, expr:Expr, catches:Array<Catch>) {
		walkToken(tryKeyword);
		walkExpr(expr);
		walkExpr_ETry_catches(catches);
	}
	function walkBlockElement_Expr(expr:Expr, semicolon:Token) {
		walkExpr(expr);
		walkToken(semicolon);
	}
	function walkObjectFieldName_NString(string:StringToken) {
		walkStringToken(string);
	}
	function walkComplexType_StructuralExtension(braceOpen:Token, types:Array<StructuralExtension>, fields:AnonymousStructureFields, braceClose:Token) {
		walkToken(braceOpen);
		walkComplexType_StructuralExtension_types(types);
		walkAnonymousStructureFields(fields);
		walkToken(braceClose);
	}
	function walkExpr_EUntyped(untypedKeyword:Token, expr:Expr) {
		walkToken(untypedKeyword);
		walkExpr(expr);
	}
	function walkMacroExpr_Var(varKeyword:Token, decls:CommaSeparated<VarDecl>) {
		walkToken(varKeyword);
		walkMacroExpr_Var_decls(decls);
	}
	function walkClassField_Function_modifiers(elems:Array<FieldModifier>) {
		walkArray(elems, walkFieldModifier);
	}
	function walkFunction_args(elems:CommaSeparated<FunctionArgument>) {
		walkCommaSeparated(elems, walkFunctionArgument);
	}
	function walkAnonymousStructureFields(node:AnonymousStructureFields) switch node {
		case ShortNotation(var fields):walkAnonymousStructureFields_ShortNotation(fields);
		case ClassNotation(var fields):walkAnonymousStructureFields_ClassNotation(fields);
	};
	function walkComplexType(node:ComplexType) switch node {
		case StructuralExtension(var braceOpen, var types, var fields, var braceClose):walkComplexType_StructuralExtension(braceOpen, types, fields, braceClose);
		case Parenthesis(var parenOpen, var type, var parenClose):walkComplexType_Parenthesis(parenOpen, type, parenClose);
		case AnonymousStructure(var braceOpen, var fields, var braceClose):walkComplexType_AnonymousStructure(braceOpen, fields, braceClose);
		case Function(var typeLeft, var arrow, var typeRight):walkComplexType_Function(typeLeft, arrow, typeRight);
		case Optional(var questionMark, var type):walkComplexType_Optional(questionMark, type);
		case TypePath(var path):walkComplexType_TypePath(path);
	};
	function walkExpr_EDo(doKeyword:Token, exprBody:Expr, whileKeyword:Token, parenOpen:Token, exprCond:Expr, parenClose:Token) {
		walkToken(doKeyword);
		walkExpr(exprBody);
		walkToken(whileKeyword);
		walkToken(parenOpen);
		walkExpr(exprCond);
		walkToken(parenClose);
	}
	function walkImportDecl(node:ImportDecl) {
		walkToken(node.importKeyword);
		walkNPath(node.path);
		walkImportMode(node.mode);
		walkToken(node.semicolon);
	}
	function walkMacroExpr_Var_decls(elems:CommaSeparated<VarDecl>) {
		walkCommaSeparated(elems, walkVarDecl);
	}
	function walkGuard(node:Guard) {
		walkToken(node.ifKeyword);
		walkToken(node.parenOpen);
		walkExpr(node.expr);
		walkToken(node.parenClose);
	}
	function walkExpr_EIn(exprLeft:Expr, inKeyword:Token, exprRight:Expr) {
		walkExpr(exprLeft);
		walkToken(inKeyword);
		walkExpr(exprRight);
	}
	function walkEnumDecl_flags(elems:Array<NCommonFlag>) {
		walkArray(elems, walkNCommonFlag);
	}
	function walkStructuralExtension(node:StructuralExtension) {
		walkToken(node.gt);
		walkTypePath(node.path);
		walkToken(node.comma);
	}
	function walkExpr_ESafeCast(castKeyword:Token, parenOpen:Token, expr:Expr, comma:Token, type:ComplexType, parenClose:Token) {
		walkToken(castKeyword);
		walkToken(parenOpen);
		walkExpr(expr);
		walkToken(comma);
		walkComplexType(type);
		walkToken(parenClose);
	}
	function walkImportMode_IAs(asKeyword:Token, ident:Token) {
		walkToken(asKeyword);
		walkToken(ident);
	}
	function walkFieldModifier_Public(keyword:Token) {
		walkToken(keyword);
	}
	function walkLiteral(node:Literal) switch node {
		case PLiteralString(var s):walkLiteral_PLiteralString(s);
		case PLiteralInt(var token):walkLiteral_PLiteralInt(token);
		case PLiteralRegex(var token):walkLiteral_PLiteralRegex(token);
		case PLiteralFloat(var token):walkLiteral_PLiteralFloat(token);
	};
	function walkConstraints(node:Constraints) switch node {
		case None:{ };
		case Single(var colon, var type):walkConstraints_Single(colon, type);
		case Multiple(var colon, var parenOpen, var types, var parenClose):walkConstraints_Multiple(colon, parenOpen, types, parenClose);
	};
	function walkClassField_Function(annotations:NAnnotations, modifiers:Array<FieldModifier>, functionKeyword:Token, name:Token, params:Null<TypeDeclParameters>, parenOpen:Token, args:Null<CommaSeparated<FunctionArgument>>, parenClose:Token, typeHint:Null<TypeHint>, expr:MethodExpr) {
		walkNAnnotations(annotations);
		walkClassField_Function_modifiers(modifiers);
		walkToken(functionKeyword);
		walkToken(name);
		if (params != null) walkTypeDeclParameters(params);
		walkToken(parenOpen);
		if (args != null) walkClassField_Function_args(args);
		walkToken(parenClose);
		if (typeHint != null) walkTypeHint(typeHint);
		walkMethodExpr(expr);
	}
	function walkExpr_EArrayDecl_elems(elems:CommaSeparatedAllowTrailing<Expr>) {
		walkCommaSeparatedTrailing(elems, walkExpr);
	}
	function walkFunction(node:Function) {
		if (node.name != null) walkToken(node.name);
		if (node.params != null) walkTypeDeclParameters(node.params);
		walkToken(node.parenOpen);
		if (node.args != null) walkFunction_args(node.args);
		walkToken(node.parenClose);
		if (node.typeHint != null) walkTypeHint(node.typeHint);
		walkExpr(node.expr);
	}
	function walkExpr_ESwitch(switchKeyword:Token, expr:Expr, braceOpen:Token, cases:Array<Case>, braceClose:Token) {
		walkToken(switchKeyword);
		walkExpr(expr);
		walkToken(braceOpen);
		walkExpr_ESwitch_cases(cases);
		walkToken(braceClose);
	}
	function walkTypedefDecl_flags(elems:Array<NCommonFlag>) {
		walkArray(elems, walkNCommonFlag);
	}
	function walkFile_decls(elems:Array<Decl>) {
		walkArray(elems, walkDecl);
	}
	function walkTypePath(node:TypePath) {
		walkNPath(node.path);
		if (node.params != null) walkTypePathParameters(node.params);
	}
	function walkTypeDeclParameters_params(elems:CommaSeparated<TypeDeclParameter>) {
		walkCommaSeparated(elems, walkTypeDeclParameter);
	}
	function walkExpr_EParenthesis(parenOpen:Token, expr:Expr, parenClose:Token) {
		walkToken(parenOpen);
		walkExpr(expr);
		walkToken(parenClose);
	}
	function walkClassDecl2(node:ClassDecl2) {
		walkNAnnotations(node.annotations);
		walkClassDecl2_flags(node.flags);
		walkClassDecl(node.decl);
	}
	function walkPackage(node:Package) {
		walkToken(node.packageKeyword);
		if (node.path != null) walkNPath(node.path);
		walkToken(node.semicolon);
	}
	function walkNAnnotations_metadata(elems:Array<Metadata>) {
		walkArray(elems, walkMetadata);
	}
	function walkAbstractDecl(node:AbstractDecl) {
		walkNAnnotations(node.annotations);
		walkAbstractDecl_flags(node.flags);
		walkToken(node.abstractKeyword);
		walkToken(node.name);
		if (node.params != null) walkTypeDeclParameters(node.params);
		if (node.underlyingType != null) walkUnderlyingType(node.underlyingType);
		walkAbstractDecl_relations(node.relations);
		walkToken(node.braceOpen);
		walkAbstractDecl_fields(node.fields);
		walkToken(node.braceClose);
	}
	function walkClassField(node:ClassField) switch node {
		case Property(var annotations, var modifiers, var varKeyword, var name, var parenOpen, var read, var comma, var write, var parenClose, var typeHint, var assignment, var semicolon):walkClassField_Property(annotations, modifiers, varKeyword, name, parenOpen, read, comma, write, parenClose, typeHint, assignment, semicolon);
		case Variable(var annotations, var modifiers, var varKeyword, var name, var typeHint, var assignment, var semicolon):walkClassField_Variable(annotations, modifiers, varKeyword, name, typeHint, assignment, semicolon);
		case Function(var annotations, var modifiers, var functionKeyword, var name, var params, var parenOpen, var args, var parenClose, var typeHint, var expr):walkClassField_Function(annotations, modifiers, functionKeyword, name, params, parenOpen, args, parenClose, typeHint, expr);
	};
	function walkFieldModifier_Inline(keyword:Token) {
		walkToken(keyword);
	}
	function walkExpr_EReturn(returnKeyword:Token) {
		walkToken(returnKeyword);
	}
	function walkNEnumFieldArgs(node:NEnumFieldArgs) {
		walkToken(node.parenOpen);
		if (node.args != null) walkNEnumFieldArgs_args(node.args);
		walkToken(node.parenClose);
	}
	function walkExpr_EIntDot(int:Token, dot:Token) {
		walkToken(int);
		walkToken(dot);
	}
	function walkLiteral_PLiteralRegex(token:Token) {
		walkToken(token);
	}
	function walkExpr_EBlock(braceOpen:Token, elems:Array<BlockElement>, braceClose:Token) {
		walkToken(braceOpen);
		walkExpr_EBlock_elems(elems);
		walkToken(braceClose);
	}
	function walkExpr_ECall(expr:Expr, args:CallArgs) {
		walkExpr(expr);
		walkCallArgs(args);
	}
	function walkCase_Default(defaultKeyword:Token, colon:Token, body:Array<BlockElement>) {
		walkToken(defaultKeyword);
		walkToken(colon);
		walkCase_Default_body(body);
	}
	function walkExpr_EUnaryPostfix(expr:Expr, op:Token) {
		walkExpr(expr);
		walkToken(op);
	}
	function walkMethodExpr_Block(expr:Expr) {
		walkExpr(expr);
	}
	function walkCallArgs(node:CallArgs) {
		walkToken(node.parenOpen);
		if (node.args != null) walkCallArgs_args(node.args);
		walkToken(node.parenClose);
	}
	function walkExpr_EMetadata(metadata:Metadata, expr:Expr) {
		walkMetadata(metadata);
		walkExpr(expr);
	}
	function walkClassDecl(node:ClassDecl) {
		walkToken(node.kind);
		walkToken(node.name);
		if (node.params != null) walkTypeDeclParameters(node.params);
		walkClassDecl_relations(node.relations);
		walkToken(node.braceOpen);
		walkClassDecl_fields(node.fields);
		walkToken(node.braceClose);
	}
	function walkMetadata_Simple(name:Token) {
		walkToken(name);
	}
	function walkCase_Case_body(elems:Array<BlockElement>) {
		walkArray(elems, walkBlockElement);
	}
	function walkImportMode(node:ImportMode) switch node {
		case IAll(var dotStar):walkImportMode_IAll(dotStar);
		case IAs(var asKeyword, var ident):walkImportMode_IAs(asKeyword, ident);
		case IIn(var inKeyword, var ident):walkImportMode_IIn(inKeyword, ident);
		case INormal:{ };
	};
	function walkMethodExpr(node:MethodExpr) switch node {
		case Block(var expr):walkMethodExpr_Block(expr);
		case None(var semicolon):walkMethodExpr_None(semicolon);
		case Expr(var expr, var semicolon):walkMethodExpr_Expr(expr, semicolon);
	};
	function walkExpr_EThrow(throwKeyword:Token, expr:Expr) {
		walkToken(throwKeyword);
		walkExpr(expr);
	}
	function walkAssignment(node:Assignment) {
		walkToken(node.assign);
		walkExpr(node.expr);
	}
	function walkMethodExpr_Expr(expr:Expr, semicolon:Token) {
		walkExpr(expr);
		walkToken(semicolon);
	}
	function walkMacroExpr_Class(classDecl:ClassDecl) {
		walkClassDecl(classDecl);
	}
	function walkCase_Case_patterns(elems:CommaSeparated<Expr>) {
		walkCommaSeparated(elems, walkExpr);
	}
	function walkNPath_idents(elems:Array<NDotIdent>) {
		walkArray(elems, walkNDotIdent);
	}
	function walkNCommonFlag(node:NCommonFlag) switch node {
		case PPrivate(var token):walkNCommonFlag_PPrivate(token);
		case PExtern(var token):walkNCommonFlag_PExtern(token);
	};
	function walkClassField_Variable_modifiers(elems:Array<FieldModifier>) {
		walkArray(elems, walkFieldModifier);
	}
	function walkTypeHint(node:TypeHint) {
		walkToken(node.colon);
		walkComplexType(node.type);
	}
	function walkExpr_EArrayDecl(bracketOpen:Token, elems:Null<CommaSeparatedAllowTrailing<Expr>>, bracketClose:Token) {
		walkToken(bracketOpen);
		if (elems != null) walkExpr_EArrayDecl_elems(elems);
		walkToken(bracketClose);
	}
	function walkAnonymousStructureFields_ShortNotation(fields:Null<CommaSeparatedAllowTrailing<AnonymousStructureField>>) {
		if (fields != null) walkAnonymousStructureFields_ShortNotation_fields(fields);
	}
	function walkExpr_EIs(parenOpen:Token, expr:Expr, isKeyword:Token, path:TypePath, parenClose:Token) {
		walkToken(parenOpen);
		walkExpr(expr);
		walkToken(isKeyword);
		walkTypePath(path);
		walkToken(parenClose);
	}
	function walkExpr_EObjectDecl(braceOpen:Token, fields:CommaSeparatedAllowTrailing<ObjectField>, braceClose:Token) {
		walkToken(braceOpen);
		walkExpr_EObjectDecl_fields(fields);
		walkToken(braceClose);
	}
	function walkUsingDecl(node:UsingDecl) {
		walkToken(node.usingKeyword);
		walkNPath(node.path);
		walkToken(node.semicolon);
	}
	function walkClassDecl_relations(elems:Array<ClassRelation>) {
		walkArray(elems, walkClassRelation);
	}
	function walkExpr_EField(expr:Expr, ident:NDotIdent) {
		walkExpr(expr);
		walkNDotIdent(ident);
	}
	function walkComplexType_StructuralExtension_types(elems:Array<StructuralExtension>) {
		walkArray(elems, walkStructuralExtension);
	}
	function walkTypePathParameter_ArrayExpr(bracketOpen:Token, elems:Null<CommaSeparatedAllowTrailing<Expr>>, bracketClose:Token) {
		walkToken(bracketOpen);
		if (elems != null) walkTypePathParameter_ArrayExpr_elems(elems);
		walkToken(bracketClose);
	}
	function walkComplexType_Optional(questionMark:Token, type:ComplexType) {
		walkToken(questionMark);
		walkComplexType(type);
	}
	function walkExpr_EIf(ifKeyword:Token, parenOpen:Token, exprCond:Expr, parenClose:Token, exprThen:Expr, exprElse:Null<ExprElse>) {
		walkToken(ifKeyword);
		walkToken(parenOpen);
		walkExpr(exprCond);
		walkToken(parenClose);
		walkExpr(exprThen);
		if (exprElse != null) walkExprElse(exprElse);
	}
	function walkComplexType_AnonymousStructure(braceOpen:Token, fields:AnonymousStructureFields, braceClose:Token) {
		walkToken(braceOpen);
		walkAnonymousStructureFields(fields);
		walkToken(braceClose);
	}
	function walkVarDecl(node:VarDecl) {
		walkToken(node.name);
		if (node.typeHint != null) walkTypeHint(node.typeHint);
		if (node.assignment != null) walkAssignment(node.assignment);
	}
	function walkNCommonFlag_PExtern(token:Token) {
		walkToken(token);
	}
	function walkTypePathParameter_ArrayExpr_elems(elems:CommaSeparatedAllowTrailing<Expr>) {
		walkCommaSeparatedTrailing(elems, walkExpr);
	}
	function walkNEnumField(node:NEnumField) {
		walkNAnnotations(node.annotations);
		walkToken(node.name);
		if (node.params != null) walkTypeDeclParameters(node.params);
		if (node.args != null) walkNEnumFieldArgs(node.args);
		if (node.typeHint != null) walkTypeHint(node.typeHint);
		walkToken(node.semicolon);
	}
	function walkNConst_PConstLiteral(literal:Literal) {
		walkLiteral(literal);
	}
	function walkMethodExpr_None(semicolon:Token) {
		walkToken(semicolon);
	}
	function walkAbstractRelation_From(fromKeyword:Token, type:ComplexType) {
		walkToken(fromKeyword);
		walkComplexType(type);
	}
	function walkClassField_Variable(annotations:NAnnotations, modifiers:Array<FieldModifier>, varKeyword:Token, name:Token, typeHint:Null<TypeHint>, assignment:Null<Assignment>, semicolon:Token) {
		walkNAnnotations(annotations);
		walkClassField_Variable_modifiers(modifiers);
		walkToken(varKeyword);
		walkToken(name);
		if (typeHint != null) walkTypeHint(typeHint);
		if (assignment != null) walkAssignment(assignment);
		walkToken(semicolon);
	}
	function walkTypeDeclParameter(node:TypeDeclParameter) {
		walkNAnnotations(node.annotations);
		walkToken(node.name);
		walkConstraints(node.constraints);
	}
	function walkComplexType_Parenthesis(parenOpen:Token, type:ComplexType, parenClose:Token) {
		walkToken(parenOpen);
		walkComplexType(type);
		walkToken(parenClose);
	}
	function walkNDotIdent(node:NDotIdent) switch node {
		case PDotIdent(var name):walkNDotIdent_PDotIdent(name);
		case PDot(var dot):walkNDotIdent_PDot(dot);
	};
	function walkExpr_EUnaryPrefix(op:Token, expr:Expr) {
		walkToken(op);
		walkExpr(expr);
	}
	function walkAnonymousStructureField(node:AnonymousStructureField) {
		if (node.questionMark != null) walkToken(node.questionMark);
		walkToken(node.name);
		walkTypeHint(node.typeHint);
	}
	function walkFieldModifier_Dynamic(keyword:Token) {
		walkToken(keyword);
	}
	function walkExpr_EConst(const:NConst) {
		walkNConst(const);
	}
	function walkClassField_Function_args(elems:CommaSeparated<FunctionArgument>) {
		walkCommaSeparated(elems, walkFunctionArgument);
	}
	function walkClassRelation(node:ClassRelation) switch node {
		case Extends(var extendsKeyword, var path):walkClassRelation_Extends(extendsKeyword, path);
		case Implements(var implementsKeyword, var path):walkClassRelation_Implements(implementsKeyword, path);
	};
	function walkExpr_ETernary(exprCond:Expr, questionMark:Token, exprThen:Expr, colon:Token, exprElse:Expr) {
		walkExpr(exprCond);
		walkToken(questionMark);
		walkExpr(exprThen);
		walkToken(colon);
		walkExpr(exprElse);
	}
	function walkCase_Default_body(elems:Array<BlockElement>) {
		walkArray(elems, walkBlockElement);
	}
	function walkExpr_EFor(forKeyword:Token, parenOpen:Token, exprIter:Expr, parenClose:Token, exprBody:Expr) {
		walkToken(forKeyword);
		walkToken(parenOpen);
		walkExpr(exprIter);
		walkToken(parenClose);
		walkExpr(exprBody);
	}
	function walkDecl_EnumDecl(decl:EnumDecl) {
		walkEnumDecl(decl);
	}
	function walkMacroExpr_Expr(expr:Expr) {
		walkExpr(expr);
	}
	function walkDecl_ClassDecl(decl:ClassDecl2) {
		walkClassDecl2(decl);
	}
	function walkBlockElement(node:BlockElement) switch node {
		case InlineFunction(var inlineKeyword, var functionKeyword, var fun, var semicolon):walkBlockElement_InlineFunction(inlineKeyword, functionKeyword, fun, semicolon);
		case Var(var varKeyword, var decls, var semicolon):walkBlockElement_Var(varKeyword, decls, semicolon);
		case Expr(var expr, var semicolon):walkBlockElement_Expr(expr, semicolon);
	};
	function walkTypePathParameter_Literal(literal:Literal) {
		walkLiteral(literal);
	}
	function walkAnonymousStructureFields_ClassNotation_fields(elems:Array<ClassField>) {
		walkArray(elems, walkClassField);
	}
	function walkFieldModifier_Static(keyword:Token) {
		walkToken(keyword);
	}
	function walkCatch(node:Catch) {
		walkToken(node.catchKeyword);
		walkToken(node.parenOpen);
		walkToken(node.ident);
		walkTypeHint(node.typeHint);
		walkToken(node.parenClose);
		walkExpr(node.expr);
	}
	function walkAbstractDecl_fields(elems:Array<ClassField>) {
		walkArray(elems, walkClassField);
	}
	function walkNEnumFieldArgs_args(elems:CommaSeparated<NEnumFieldArg>) {
		walkCommaSeparated(elems, walkNEnumFieldArg);
	}
	function walkFile(node:File) {
		if (node.pack != null) walkPackage(node.pack);
		walkFile_decls(node.decls);
		walkToken(node.eof);
	}
	function walkCallArgs_args(elems:CommaSeparated<Expr>) {
		walkCommaSeparated(elems, walkExpr);
	}
	function walkExpr_EBreak(breakKeyword:Token) {
		walkToken(breakKeyword);
	}
	function walkExpr_ESwitch_cases(elems:Array<Case>) {
		walkArray(elems, walkCase);
	}
	function walkExpr_EDollarIdent(ident:Token) {
		walkToken(ident);
	}
	function walkObjectField(node:ObjectField) {
		walkObjectFieldName(node.name);
		walkToken(node.colon);
		walkExpr(node.expr);
	}
	function walkImportMode_IIn(inKeyword:Token, ident:Token) {
		walkToken(inKeyword);
		walkToken(ident);
	}
	function walkExpr_EUnsafeCast(castKeyword:Token, expr:Expr) {
		walkToken(castKeyword);
		walkExpr(expr);
	}
	function walkTypedefDecl(node:TypedefDecl) {
		walkNAnnotations(node.annotations);
		walkTypedefDecl_flags(node.flags);
		walkToken(node.typedefKeyword);
		walkToken(node.name);
		if (node.params != null) walkTypeDeclParameters(node.params);
		walkToken(node.assign);
		walkComplexType(node.type);
		if (node.semicolon != null) walkToken(node.semicolon);
	}
	function walkMacroExpr(node:MacroExpr) switch node {
		case TypeHint(var typeHint):walkMacroExpr_TypeHint(typeHint);
		case Var(var varKeyword, var decls):walkMacroExpr_Var(varKeyword, decls);
		case Class(var classDecl):walkMacroExpr_Class(classDecl);
		case Expr(var expr):walkMacroExpr_Expr(expr);
	};
	function walkMetadata_WithArgs(name:Token, args:CommaSeparated<Expr>, parenClose:Token) {
		walkToken(name);
		walkMetadata_WithArgs_args(args);
		walkToken(parenClose);
	}
	function walkDecl_AbstractDecl(decl:AbstractDecl) {
		walkAbstractDecl(decl);
	}
	function walkAbstractRelation(node:AbstractRelation) switch node {
		case To(var toKeyword, var type):walkAbstractRelation_To(toKeyword, type);
		case From(var fromKeyword, var type):walkAbstractRelation_From(fromKeyword, type);
	};
	function walkNDotIdent_PDot(dot:Token) {
		walkToken(dot);
	}
	function walkConstraints_Multiple(colon:Token, parenOpen:Token, types:CommaSeparated<ComplexType>, parenClose:Token) {
		walkToken(colon);
		walkToken(parenOpen);
		walkConstraints_Multiple_types(types);
		walkToken(parenClose);
	}
	function walkExpr_EReturnExpr(returnKeyword:Token, expr:Expr) {
		walkToken(returnKeyword);
		walkExpr(expr);
	}
	function walkNConst_PConstIdent(ident:Token) {
		walkToken(ident);
	}
	function walkClassField_Property_modifiers(elems:Array<FieldModifier>) {
		walkArray(elems, walkFieldModifier);
	}
	function walkConstraints_Single(colon:Token, type:ComplexType) {
		walkToken(colon);
		walkComplexType(type);
	}
	function walkExpr_ETry_catches(elems:Array<Catch>) {
		walkArray(elems, walkCatch);
	}
	function walkExpr_EArrayAccess(expr:Expr, bracketOpen:Token, exprKey:Expr, bracketClose:Token) {
		walkExpr(expr);
		walkToken(bracketOpen);
		walkExpr(exprKey);
		walkToken(bracketClose);
	}
	function walkCase(node:Case) switch node {
		case Default(var defaultKeyword, var colon, var body):walkCase_Default(defaultKeyword, colon, body);
		case Case(var caseKeyword, var patterns, var guard, var colon, var body):walkCase_Case(caseKeyword, patterns, guard, colon, body);
	};
	function walkObjectFieldName_NIdent(ident:Token) {
		walkToken(ident);
	}
	function walkTypeDeclParameters(node:TypeDeclParameters) {
		walkToken(node.lt);
		walkTypeDeclParameters_params(node.params);
		walkToken(node.gt);
	}
	function walkExpr_EWhile(whileKeyword:Token, parenOpen:Token, exprCond:Expr, parenClose:Token, exprBody:Expr) {
		walkToken(whileKeyword);
		walkToken(parenOpen);
		walkExpr(exprCond);
		walkToken(parenClose);
		walkExpr(exprBody);
	}
	function walkClassRelation_Implements(implementsKeyword:Token, path:TypePath) {
		walkToken(implementsKeyword);
		walkTypePath(path);
	}
	function walkNPath(node:NPath) {
		walkToken(node.ident);
		walkNPath_idents(node.idents);
	}
	function walkNConst(node:NConst) switch node {
		case PConstIdent(var ident):walkNConst_PConstIdent(ident);
		case PConstLiteral(var literal):walkNConst_PConstLiteral(literal);
	};
	function walkNCommonFlag_PPrivate(token:Token) {
		walkToken(token);
	}
	function walkDecl_UsingDecl(decl:UsingDecl) {
		walkUsingDecl(decl);
	}
	function walkTypePathParameters(node:TypePathParameters) {
		walkToken(node.lt);
		walkTypePathParameters_params(node.params);
		walkToken(node.gt);
	}
	function walkConstraints_Multiple_types(elems:CommaSeparated<ComplexType>) {
		walkCommaSeparated(elems, walkComplexType);
	}
	function walkClassRelation_Extends(extendsKeyword:Token, path:TypePath) {
		walkToken(extendsKeyword);
		walkTypePath(path);
	}
	function walkExpr_EVar(varKeyword:Token, decl:VarDecl) {
		walkToken(varKeyword);
		walkVarDecl(decl);
	}
	function walkUnderlyingType(node:UnderlyingType) {
		walkToken(node.parenOpen);
		walkComplexType(node.type);
		walkToken(node.parenClose);
	}
	function walkAnonymousStructureFields_ClassNotation(fields:Array<ClassField>) {
		walkAnonymousStructureFields_ClassNotation_fields(fields);
	}
	function walkMacroExpr_TypeHint(typeHint:TypeHint) {
		walkTypeHint(typeHint);
	}
	function walkComplexType_TypePath(path:TypePath) {
		walkTypePath(path);
	}
	function walkDecl_TypedefDecl(decl:TypedefDecl) {
		walkTypedefDecl(decl);
	}
	function walkStringToken_DoubleQuote(token:Token) {
		walkToken(token);
	}
	function walkDecl_ImportDecl(decl:ImportDecl) {
		walkImportDecl(decl);
	}
	function walkObjectFieldName(node:ObjectFieldName) switch node {
		case NIdent(var ident):walkObjectFieldName_NIdent(ident);
		case NString(var string):walkObjectFieldName_NString(string);
	};
	function walkExpr_EFunction(functionKeyword:Token, fun:Function) {
		walkToken(functionKeyword);
		walkFunction(fun);
	}
	function walkTypePathParameter_Type(type:ComplexType) {
		walkComplexType(type);
	}
	function walkClassDecl2_flags(elems:Array<NCommonFlag>) {
		walkArray(elems, walkNCommonFlag);
	}
	function walkFieldModifier_Override(keyword:Token) {
		walkToken(keyword);
	}
	function walkExpr_EMacro(macroKeyword:Token, expr:MacroExpr) {
		walkToken(macroKeyword);
		walkMacroExpr(expr);
	}
	function walkComplexType_Function(typeLeft:ComplexType, arrow:Token, typeRight:ComplexType) {
		walkComplexType(typeLeft);
		walkToken(arrow);
		walkComplexType(typeRight);
	}
	function walkImportMode_IAll(dotStar:Token) {
		walkToken(dotStar);
	}
	function walkNDotIdent_PDotIdent(name:Token) {
		walkToken(name);
	}
	function walkMetadata_WithArgs_args(elems:CommaSeparated<Expr>) {
		walkCommaSeparated(elems, walkExpr);
	}
	function walkTypePathParameters_params(elems:CommaSeparated<TypePathParameter>) {
		walkCommaSeparated(elems, walkTypePathParameter);
	}
	function walkFieldModifier_Private(keyword:Token) {
		walkToken(keyword);
	}
	function walkExpr_ENew(newKeyword:Token, path:TypePath, args:CallArgs) {
		walkToken(newKeyword);
		walkTypePath(path);
		walkCallArgs(args);
	}
	function walkExprElse(node:ExprElse) {
		walkToken(node.elseKeyword);
		walkExpr(node.expr);
	}
	function walkAbstractRelation_To(toKeyword:Token, type:ComplexType) {
		walkToken(toKeyword);
		walkComplexType(type);
	}
	function walkTypePathParameter(node:TypePathParameter) switch node {
		case ArrayExpr(var bracketOpen, var elems, var bracketClose):walkTypePathParameter_ArrayExpr(bracketOpen, elems, bracketClose);
		case Literal(var literal):walkTypePathParameter_Literal(literal);
		case Type(var type):walkTypePathParameter_Type(type);
	};
	function walkEnumDecl_fields(elems:Array<NEnumField>) {
		walkArray(elems, walkNEnumField);
	}
	function walkStringToken_SingleQuote(token:Token) {
		walkToken(token);
	}
	function walkLiteral_PLiteralInt(token:Token) {
		walkToken(token);
	}
	function walkLiteral_PLiteralString(s:StringToken) {
		walkStringToken(s);
	}
	function walkAnonymousStructureFields_ShortNotation_fields(elems:CommaSeparatedAllowTrailing<AnonymousStructureField>) {
		walkCommaSeparatedTrailing(elems, walkAnonymousStructureField);
	}
	function walkExpr_ECheckType(parenOpen:Token, expr:Expr, colon:Token, type:ComplexType, parenClose:Token) {
		walkToken(parenOpen);
		walkExpr(expr);
		walkToken(colon);
		walkComplexType(type);
		walkToken(parenClose);
	}
	function walkAbstractDecl_flags(elems:Array<NCommonFlag>) {
		walkArray(elems, walkNCommonFlag);
	}
	function walkExpr(node:Expr) switch node {
		case EMacro(var macroKeyword, var expr):walkExpr_EMacro(macroKeyword, expr);
		case ECall(var expr, var args):walkExpr_ECall(expr, args);
		case EMetadata(var metadata, var expr):walkExpr_EMetadata(metadata, expr);
		case EMacroEscape(var ident, var braceOpen, var expr, var braceClose):walkExpr_EMacroEscape(ident, braceOpen, expr, braceClose);
		case ESafeCast(var castKeyword, var parenOpen, var expr, var comma, var type, var parenClose):walkExpr_ESafeCast(castKeyword, parenOpen, expr, comma, type, parenClose);
		case ENew(var newKeyword, var path, var args):walkExpr_ENew(newKeyword, path, args);
		case EIntDot(var int, var dot):walkExpr_EIntDot(int, dot);
		case EIf(var ifKeyword, var parenOpen, var exprCond, var parenClose, var exprThen, var exprElse):walkExpr_EIf(ifKeyword, parenOpen, exprCond, parenClose, exprThen, exprElse);
		case ETry(var tryKeyword, var expr, var catches):walkExpr_ETry(tryKeyword, expr, catches);
		case EUntyped(var untypedKeyword, var expr):walkExpr_EUntyped(untypedKeyword, expr);
		case EWhile(var whileKeyword, var parenOpen, var exprCond, var parenClose, var exprBody):walkExpr_EWhile(whileKeyword, parenOpen, exprCond, parenClose, exprBody);
		case EIs(var parenOpen, var expr, var isKeyword, var path, var parenClose):walkExpr_EIs(parenOpen, expr, isKeyword, path, parenClose);
		case EArrayAccess(var expr, var bracketOpen, var exprKey, var bracketClose):walkExpr_EArrayAccess(expr, bracketOpen, exprKey, bracketClose);
		case EBinop(var exprLeft, var op, var exprRight):walkExpr_EBinop(exprLeft, op, exprRight);
		case EBreak(var breakKeyword):walkExpr_EBreak(breakKeyword);
		case ETernary(var exprCond, var questionMark, var exprThen, var colon, var exprElse):walkExpr_ETernary(exprCond, questionMark, exprThen, colon, exprElse);
		case EField(var expr, var ident):walkExpr_EField(expr, ident);
		case EUnsafeCast(var castKeyword, var expr):walkExpr_EUnsafeCast(castKeyword, expr);
		case ESwitch(var switchKeyword, var expr, var braceOpen, var cases, var braceClose):walkExpr_ESwitch(switchKeyword, expr, braceOpen, cases, braceClose);
		case EUnaryPostfix(var expr, var op):walkExpr_EUnaryPostfix(expr, op);
		case EFor(var forKeyword, var parenOpen, var exprIter, var parenClose, var exprBody):walkExpr_EFor(forKeyword, parenOpen, exprIter, parenClose, exprBody);
		case EReturnExpr(var returnKeyword, var expr):walkExpr_EReturnExpr(returnKeyword, expr);
		case ECheckType(var parenOpen, var expr, var colon, var type, var parenClose):walkExpr_ECheckType(parenOpen, expr, colon, type, parenClose);
		case EDo(var doKeyword, var exprBody, var whileKeyword, var parenOpen, var exprCond, var parenClose):walkExpr_EDo(doKeyword, exprBody, whileKeyword, parenOpen, exprCond, parenClose);
		case EContinue(var continueKeyword):walkExpr_EContinue(continueKeyword);
		case EObjectDecl(var braceOpen, var fields, var braceClose):walkExpr_EObjectDecl(braceOpen, fields, braceClose);
		case EParenthesis(var parenOpen, var expr, var parenClose):walkExpr_EParenthesis(parenOpen, expr, parenClose);
		case EIn(var exprLeft, var inKeyword, var exprRight):walkExpr_EIn(exprLeft, inKeyword, exprRight);
		case EVar(var varKeyword, var decl):walkExpr_EVar(varKeyword, decl);
		case EDollarIdent(var ident):walkExpr_EDollarIdent(ident);
		case EFunction(var functionKeyword, var fun):walkExpr_EFunction(functionKeyword, fun);
		case EArrayDecl(var bracketOpen, var elems, var bracketClose):walkExpr_EArrayDecl(bracketOpen, elems, bracketClose);
		case EBlock(var braceOpen, var elems, var braceClose):walkExpr_EBlock(braceOpen, elems, braceClose);
		case EThrow(var throwKeyword, var expr):walkExpr_EThrow(throwKeyword, expr);
		case EConst(var const):walkExpr_EConst(const);
		case EReturn(var returnKeyword):walkExpr_EReturn(returnKeyword);
		case EUnaryPrefix(var op, var expr):walkExpr_EUnaryPrefix(op, expr);
	};
	function walkLiteral_PLiteralFloat(token:Token) {
		walkToken(token);
	}
	function walkBlockElement_Var(varKeyword:Token, decls:CommaSeparated<VarDecl>, semicolon:Token) {
		walkToken(varKeyword);
		walkBlockElement_Var_decls(decls);
		walkToken(semicolon);
	}
	function walkExpr_EContinue(continueKeyword:Token) {
		walkToken(continueKeyword);
	}
	function walkNEnumFieldArg(node:NEnumFieldArg) {
		if (node.questionMark != null) walkToken(node.questionMark);
		walkToken(node.name);
		walkTypeHint(node.typeHint);
	}
	function walkMetadata(node:Metadata) switch node {
		case WithArgs(var name, var args, var parenClose):walkMetadata_WithArgs(name, args, parenClose);
		case Simple(var name):walkMetadata_Simple(name);
	};
	function walkClassDecl_fields(elems:Array<ClassField>) {
		walkArray(elems, walkClassField);
	}
	function walkExpr_EMacroEscape(ident:Token, braceOpen:Token, expr:Expr, braceClose:Token) {
		walkToken(ident);
		walkToken(braceOpen);
		walkExpr(expr);
		walkToken(braceClose);
	}
	function walkBlockElement_InlineFunction(inlineKeyword:Token, functionKeyword:Token, fun:Function, semicolon:Token) {
		walkToken(inlineKeyword);
		walkToken(functionKeyword);
		walkFunction(fun);
		walkToken(semicolon);
	}
	function walkBlockElement_Var_decls(elems:CommaSeparated<VarDecl>) {
		walkCommaSeparated(elems, walkVarDecl);
	}
	function walkAbstractDecl_relations(elems:Array<AbstractRelation>) {
		walkArray(elems, walkAbstractRelation);
	}
	function walkNAnnotations(node:NAnnotations) {
		if (node.doc != null) walkToken(node.doc);
		walkNAnnotations_metadata(node.metadata);
	}
	function walkEnumDecl(node:EnumDecl) {
		walkNAnnotations(node.annotations);
		walkEnumDecl_flags(node.flags);
		walkToken(node.enumKeyword);
		walkToken(node.name);
		if (node.params != null) walkTypeDeclParameters(node.params);
		walkToken(node.braceOpen);
		walkEnumDecl_fields(node.fields);
		walkToken(node.braceClose);
	}
}