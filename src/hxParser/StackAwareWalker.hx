// This file is autogenerated from ParseTree data structures
// Use build-walker.hxml to re-generate!

package hxParser;

import hxParser.ParseTree;

@:publicFields class StackAwareWalker {
	function walkToken(token:Token, stack:WalkStack) { }
	function walkArray<T>(elems:Array<T>, stack:WalkStack, walk:T -> WalkStack -> Void) {
		for (i in 0 ... elems.length) walk(elems[i], Element(i, stack));
	}
	function walkCommaSeparated<T>(elems:CommaSeparated<T>, stack:WalkStack, walk:T -> WalkStack -> Void) {
		walk(elems.arg, Element(0, stack));
		var i = 1;
		for (el in elems.args) {
			walkToken(el.comma, Edge("comma", stack));
			walk(el.arg, Element(i, stack));
			i++;
		};
	}
	function walkCommaSeparatedTrailing<T>(elems:CommaSeparatedAllowTrailing<T>, stack:WalkStack, walk:T -> WalkStack -> Void) {
		walk(elems.arg, Element(0, stack));
		var i = 1;
		for (el in elems.args) {
			walkToken(el.comma, Edge("comma", stack));
			walk(el.arg, Element(i, stack));
			i++;
		};
		if (elems.comma != null) walkToken(elems.comma, Edge("commaTrailing", stack));
	}
	function walkClassRelation_Extends(extendsKeyword:Token, path:TypePath, stack:WalkStack) {
		stack = Node(ClassRelation_Extends(extendsKeyword, path), stack);
		{
			walkToken(extendsKeyword, Edge("extendsKeyword", stack));
			walkTypePath(path, Edge("path", stack));
		};
	}
	function walkNBlockElement_PVar_vl(elems:CommaSeparated<NVarDeclaration>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNVarDeclaration);
	}
	function walkCatch(node:Catch, stack:WalkStack) {
		stack = Node(Catch(node), stack);
		{
			walkToken(node.catchKeyword, Edge("catchKeyword", stack));
			walkToken(node.parenOpen, Edge("parenOpen", stack));
			walkToken(node.ident, Edge("ident", stack));
			walkTypeHint(node.typeHint, Edge("typeHint", stack));
			walkToken(node.parenClose, Edge("parenClose", stack));
			walkExpr(node.expr, Edge("expr", stack));
		};
	}
	function walkDecl_ClassDecl(annotations:NAnnotations, flags:Array<NCommonFlag>, classDecl:ClassDecl, stack:WalkStack) {
		stack = Node(Decl_ClassDecl(annotations, flags, classDecl), stack);
		{
			walkNAnnotations(annotations, Edge("annotations", stack));
			walkDecl_ClassDecl_flags(flags, Edge("flags", stack));
			walkClassDecl(classDecl, Edge("classDecl", stack));
		};
	}
	function walkDecl_AbstractDecl_relations(elems:Array<AbstractRelation>, stack:WalkStack) {
		walkArray(elems, stack, walkAbstractRelation);
	}
	function walkNString_PString2(s:Token, stack:WalkStack) {
		stack = Node(NString_PString2(s), stack);
		{
			walkToken(s, Edge("s", stack));
		};
	}
	function walkNDotIdent_PDotIdent(name:Token, stack:WalkStack) {
		stack = Node(NDotIdent_PDotIdent(name), stack);
		{
			walkToken(name, Edge("name", stack));
		};
	}
	function walkComplexType(node:ComplexType, stack:WalkStack) switch node {
		case PFunctionType(type1, arrow, type2):walkComplexType_PFunctionType(type1, arrow, type2, stack);
		case PStructuralExtension(braceOpen, types, fields, braceClose):walkComplexType_PStructuralExtension(braceOpen, types, fields, braceClose, stack);
		case PParenthesisType(parenOpen, ct, parenClose):walkComplexType_PParenthesisType(parenOpen, ct, parenClose, stack);
		case PAnonymousStructure(braceOpen, fields, braceClose):walkComplexType_PAnonymousStructure(braceOpen, fields, braceClose, stack);
		case PTypePath(path):walkComplexType_PTypePath(path, stack);
		case POptionalType(questionmark, type):walkComplexType_POptionalType(questionmark, type, stack);
	};
	function walkFunctionArgument(node:FunctionArgument, stack:WalkStack) {
		stack = Node(FunctionArgument(node), stack);
		{
			walkNAnnotations(node.annotations, Edge("annotations", stack));
			if (node.questionmark != null) walkToken(node.questionmark, Edge("questionmark", stack));
			walkToken(node.name, Edge("name", stack));
			if (node.typeHint != null) walkTypeHint(node.typeHint, Edge("typeHint", stack));
			if (node.assignment != null) walkNAssignment(node.assignment, Edge("assignment", stack));
		};
	}
	function walkExpr_EDollarIdent(ident:Token, stack:WalkStack) {
		stack = Node(Expr_EDollarIdent(ident), stack);
		{
			walkToken(ident, Edge("ident", stack));
		};
	}
	function walkComplexType_PFunctionType(type1:ComplexType, arrow:Token, type2:ComplexType, stack:WalkStack) {
		stack = Node(ComplexType_PFunctionType(type1, arrow, type2), stack);
		{
			walkComplexType(type1, Edge("type1", stack));
			walkToken(arrow, Edge("arrow", stack));
			walkComplexType(type2, Edge("type2", stack));
		};
	}
	function walkObjectFieldName_NString(string:NString, stack:WalkStack) {
		stack = Node(ObjectFieldName_NString(string), stack);
		{
			walkNString(string, Edge("string", stack));
		};
	}
	function walkConstraints_Multiple(colon:Token, parenOpen:Token, types:CommaSeparated<ComplexType>, parenClose:Token, stack:WalkStack) {
		stack = Node(Constraints_Multiple(colon, parenOpen, types, parenClose), stack);
		{
			walkToken(colon, Edge("colon", stack));
			walkToken(parenOpen, Edge("parenOpen", stack));
			walkConstraints_Multiple_types(types, Edge("types", stack));
			walkToken(parenClose, Edge("parenClose", stack));
		};
	}
	function walkNFieldExpr_PBlockFieldExpr(e:Expr, stack:WalkStack) {
		stack = Node(NFieldExpr_PBlockFieldExpr(e), stack);
		{
			walkExpr(e, Edge("e", stack));
		};
	}
	function walkNMacroExpr_PVar_v(elems:CommaSeparated<NVarDeclaration>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNVarDeclaration);
	}
	function walkExprElse(node:ExprElse, stack:WalkStack) {
		stack = Node(ExprElse(node), stack);
		{
			walkToken(node.elseKeyword, Edge("elseKeyword", stack));
			walkExpr(node.expr, Edge("expr", stack));
		};
	}
	function walkExpr_EReturn(returnKeyword:Token, stack:WalkStack) {
		stack = Node(Expr_EReturn(returnKeyword), stack);
		{
			walkToken(returnKeyword, Edge("returnKeyword", stack));
		};
	}
	function walkNTypePathParameter_PConstantTypePathParameter(constant:NLiteral, stack:WalkStack) {
		stack = Node(NTypePathParameter_PConstantTypePathParameter(constant), stack);
		{
			walkNLiteral(constant, Edge("constant", stack));
		};
	}
	function walkNEnumFieldArgs(node:NEnumFieldArgs, stack:WalkStack) {
		stack = Node(NEnumFieldArgs(node), stack);
		{
			walkToken(node.parenOpen, Edge("parenOpen", stack));
			if (node.args != null) walkNEnumFieldArgs_args(node.args, Edge("args", stack));
			walkToken(node.parenClose, Edge("parenClose", stack));
		};
	}
	function walkNPath_idents(elems:Array<NDotIdent>, stack:WalkStack) {
		walkArray(elems, stack, walkNDotIdent);
	}
	function walkNMacroExpr_PClass(c:ClassDecl, stack:WalkStack) {
		stack = Node(NMacroExpr_PClass(c), stack);
		{
			walkClassDecl(c, Edge("c", stack));
		};
	}
	function walkExpr_ECheckType(parenOpen:Token, expr:Expr, colon:Token, type:ComplexType, parenClose:Token, stack:WalkStack) {
		stack = Node(Expr_ECheckType(parenOpen, expr, colon, type, parenClose), stack);
		{
			walkToken(parenOpen, Edge("parenOpen", stack));
			walkExpr(expr, Edge("expr", stack));
			walkToken(colon, Edge("colon", stack));
			walkComplexType(type, Edge("type", stack));
			walkToken(parenClose, Edge("parenClose", stack));
		};
	}
	function walkNTypePathParameter(node:NTypePathParameter, stack:WalkStack) switch node {
		case PArrayExprTypePathParameter(bracketOpen, el, bracketClose):walkNTypePathParameter_PArrayExprTypePathParameter(bracketOpen, el, bracketClose, stack);
		case PConstantTypePathParameter(constant):walkNTypePathParameter_PConstantTypePathParameter(constant, stack);
		case PTypeTypePathParameter(type):walkNTypePathParameter_PTypeTypePathParameter(type, stack);
	};
	function walkClassDecl(node:ClassDecl, stack:WalkStack) {
		stack = Node(ClassDecl(node), stack);
		{
			walkToken(node.kind, Edge("kind", stack));
			walkToken(node.name, Edge("name", stack));
			if (node.params != null) walkTypeDeclParameters(node.params, Edge("params", stack));
			walkClassDecl_relations(node.relations, Edge("relations", stack));
			walkToken(node.braceOpen, Edge("braceOpen", stack));
			walkClassDecl_fields(node.fields, Edge("fields", stack));
			walkToken(node.braceClose, Edge("braceClose", stack));
		};
	}
	function walkNConst_PConstLiteral(literal:NLiteral, stack:WalkStack) {
		stack = Node(NConst_PConstLiteral(literal), stack);
		{
			walkNLiteral(literal, Edge("literal", stack));
		};
	}
	function walkImportMode(node:ImportMode, stack:WalkStack) switch node {
		case IIn(inKeyword, ident):walkImportMode_IIn(inKeyword, ident, stack);
		case INormal:{ };
		case IAll(dotstar):walkImportMode_IAll(dotstar, stack);
		case IAs(asKeyword, ident):walkImportMode_IAs(asKeyword, ident, stack);
	};
	function walkFile(node:File, stack:WalkStack) {
		stack = Node(File(node), stack);
		{
			if (node.pack != null) walkPackage(node.pack, Edge("pack", stack));
			walkFile_decls(node.decls, Edge("decls", stack));
			walkToken(node.eof, Edge("eof", stack));
		};
	}
	function walkFieldModifier_Static(keyword:Token, stack:WalkStack) {
		stack = Node(FieldModifier_Static(keyword), stack);
		{
			walkToken(keyword, Edge("keyword", stack));
		};
	}
	function walkDecl_ImportDecl(importKeyword:Token, path:NPath, mode:ImportMode, semicolon:Token, stack:WalkStack) {
		stack = Node(Decl_ImportDecl(importKeyword, path, mode, semicolon), stack);
		{
			walkToken(importKeyword, Edge("importKeyword", stack));
			walkNPath(path, Edge("path", stack));
			walkImportMode(mode, Edge("mode", stack));
			walkToken(semicolon, Edge("semicolon", stack));
		};
	}
	function walkNDotIdent_PDot(_dot:Token, stack:WalkStack) {
		stack = Node(NDotIdent_PDot(_dot), stack);
		{
			walkToken(_dot, Edge("_dot", stack));
		};
	}
	function walkExpr_EMetadata(metadata:NMetadata, expr:Expr, stack:WalkStack) {
		stack = Node(Expr_EMetadata(metadata, expr), stack);
		{
			walkNMetadata(metadata, Edge("metadata", stack));
			walkExpr(expr, Edge("expr", stack));
		};
	}
	function walkExpr_EThrow(throwKeyword:Token, expr:Expr, stack:WalkStack) {
		stack = Node(Expr_EThrow(throwKeyword, expr), stack);
		{
			walkToken(throwKeyword, Edge("throwKeyword", stack));
			walkExpr(expr, Edge("expr", stack));
		};
	}
	function walkNMetadata_PMetadataWithArgs_el(elems:CommaSeparated<Expr>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkExpr);
	}
	function walkNAnonymousTypeFields_PAnonymousShortFields(fields:Null<CommaSeparatedAllowTrailing<NAnonymousTypeField>>, stack:WalkStack) {
		stack = Node(NAnonymousTypeFields_PAnonymousShortFields(fields), stack);
		{
			if (fields != null) walkNAnonymousTypeFields_PAnonymousShortFields_fields(fields, Edge("fields", stack));
		};
	}
	function walkAbstractRelation_From(fromKeyword:Token, type:ComplexType, stack:WalkStack) {
		stack = Node(AbstractRelation_From(fromKeyword, type), stack);
		{
			walkToken(fromKeyword, Edge("fromKeyword", stack));
			walkComplexType(type, Edge("type", stack));
		};
	}
	function walkClassField_Function_modifiers(elems:Array<FieldModifier>, stack:WalkStack) {
		walkArray(elems, stack, walkFieldModifier);
	}
	function walkDecl_AbstractDecl_flags(elems:Array<NCommonFlag>, stack:WalkStack) {
		walkArray(elems, stack, walkNCommonFlag);
	}
	function walkTypeDeclParameters_params(elems:CommaSeparated<TypeDeclParameter>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkTypeDeclParameter);
	}
	function walkExpr_EVar(varKeyword:Token, decl:NVarDeclaration, stack:WalkStack) {
		stack = Node(Expr_EVar(varKeyword, decl), stack);
		{
			walkToken(varKeyword, Edge("varKeyword", stack));
			walkNVarDeclaration(decl, Edge("decl", stack));
		};
	}
	function walkNEnumFieldArgs_args(elems:CommaSeparated<NEnumFieldArg>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNEnumFieldArg);
	}
	function walkDecl_AbstractDecl(annotations:NAnnotations, flags:Array<NCommonFlag>, abstractKeyword:Token, name:Token, params:Null<TypeDeclParameters>, underlyingType:Null<UnderlyingType>, relations:Array<AbstractRelation>, braceOpen:Token, fields:Array<ClassField>, braceClose:Token, stack:WalkStack) {
		stack = Node(Decl_AbstractDecl(annotations, flags, abstractKeyword, name, params, underlyingType, relations, braceOpen, fields, braceClose), stack);
		{
			walkNAnnotations(annotations, Edge("annotations", stack));
			walkDecl_AbstractDecl_flags(flags, Edge("flags", stack));
			walkToken(abstractKeyword, Edge("abstractKeyword", stack));
			walkToken(name, Edge("name", stack));
			if (params != null) walkTypeDeclParameters(params, Edge("params", stack));
			if (underlyingType != null) walkUnderlyingType(underlyingType, Edge("underlyingType", stack));
			walkDecl_AbstractDecl_relations(relations, Edge("relations", stack));
			walkToken(braceOpen, Edge("braceOpen", stack));
			walkDecl_AbstractDecl_fields(fields, Edge("fields", stack));
			walkToken(braceClose, Edge("braceClose", stack));
		};
	}
	function walkPackage(node:Package, stack:WalkStack) {
		stack = Node(Package(node), stack);
		{
			walkToken(node.packageKeyword, Edge("packageKeyword", stack));
			if (node.path != null) walkNPath(node.path, Edge("path", stack));
			walkToken(node.semicolon, Edge("semicolon", stack));
		};
	}
	function walkClassField_Function(annotations:NAnnotations, modifiers:Array<FieldModifier>, functionKeyword:Token, name:Token, params:Null<TypeDeclParameters>, parenOpen:Token, args:Null<CommaSeparated<FunctionArgument>>, parenClose:Token, typeHint:Null<TypeHint>, expr:Null<NFieldExpr>, stack:WalkStack) {
		stack = Node(ClassField_Function(annotations, modifiers, functionKeyword, name, params, parenOpen, args, parenClose, typeHint, expr), stack);
		{
			walkNAnnotations(annotations, Edge("annotations", stack));
			walkClassField_Function_modifiers(modifiers, Edge("modifiers", stack));
			walkToken(functionKeyword, Edge("functionKeyword", stack));
			walkToken(name, Edge("name", stack));
			if (params != null) walkTypeDeclParameters(params, Edge("params", stack));
			walkToken(parenOpen, Edge("parenOpen", stack));
			if (args != null) walkClassField_Function_args(args, Edge("args", stack));
			walkToken(parenClose, Edge("parenClose", stack));
			if (typeHint != null) walkTypeHint(typeHint, Edge("typeHint", stack));
			if (expr != null) walkNFieldExpr(expr, Edge("expr", stack));
		};
	}
	function walkFunction(node:Function, stack:WalkStack) {
		stack = Node(Function(node), stack);
		{
			if (node.name != null) walkToken(node.name, Edge("name", stack));
			if (node.params != null) walkTypeDeclParameters(node.params, Edge("params", stack));
			walkToken(node.parenOpen, Edge("parenOpen", stack));
			if (node.args != null) walkFunction_args(node.args, Edge("args", stack));
			walkToken(node.parenClose, Edge("parenClose", stack));
			if (node.typeHint != null) walkTypeHint(node.typeHint, Edge("typeHint", stack));
			walkExpr(node.expr, Edge("expr", stack));
		};
	}
	function walkTypePath(node:TypePath, stack:WalkStack) {
		stack = Node(TypePath(node), stack);
		{
			walkNPath(node.path, Edge("path", stack));
			if (node.params != null) walkNTypePathParameters(node.params, Edge("params", stack));
		};
	}
	function walkFieldModifier_Override(keyword:Token, stack:WalkStack) {
		stack = Node(FieldModifier_Override(keyword), stack);
		{
			walkToken(keyword, Edge("keyword", stack));
		};
	}
	function walkExpr_EIntDot(int:Token, dot:Token, stack:WalkStack) {
		stack = Node(Expr_EIntDot(int, dot), stack);
		{
			walkToken(int, Edge("int", stack));
			walkToken(dot, Edge("dot", stack));
		};
	}
	function walkNMacroExpr_PExpr(e:Expr, stack:WalkStack) {
		stack = Node(NMacroExpr_PExpr(e), stack);
		{
			walkExpr(e, Edge("e", stack));
		};
	}
	function walkClassField_Property_modifiers(elems:Array<FieldModifier>, stack:WalkStack) {
		walkArray(elems, stack, walkFieldModifier);
	}
	function walkNMacroExpr_PTypeHint(typeHint:TypeHint, stack:WalkStack) {
		stack = Node(NMacroExpr_PTypeHint(typeHint), stack);
		{
			walkTypeHint(typeHint, Edge("typeHint", stack));
		};
	}
	function walkExpr_ETernary(exprCond:Expr, questionmark:Token, exprThen:Expr, colon:Token, exprElse:Expr, stack:WalkStack) {
		stack = Node(Expr_ETernary(exprCond, questionmark, exprThen, colon, exprElse), stack);
		{
			walkExpr(exprCond, Edge("exprCond", stack));
			walkToken(questionmark, Edge("questionmark", stack));
			walkExpr(exprThen, Edge("exprThen", stack));
			walkToken(colon, Edge("colon", stack));
			walkExpr(exprElse, Edge("exprElse", stack));
		};
	}
	function walkFieldModifier_Public(keyword:Token, stack:WalkStack) {
		stack = Node(FieldModifier_Public(keyword), stack);
		{
			walkToken(keyword, Edge("keyword", stack));
		};
	}
	function walkNAssignment(node:NAssignment, stack:WalkStack) {
		stack = Node(NAssignment(node), stack);
		{
			walkToken(node.assign, Edge("assign", stack));
			walkExpr(node.e, Edge("e", stack));
		};
	}
	function walkExpr_ENew(newKeyword:Token, path:TypePath, args:CallArgs, stack:WalkStack) {
		stack = Node(Expr_ENew(newKeyword, path, args), stack);
		{
			walkToken(newKeyword, Edge("newKeyword", stack));
			walkTypePath(path, Edge("path", stack));
			walkCallArgs(args, Edge("args", stack));
		};
	}
	function walkNCase_PDefault_el(elems:Array<NBlockElement>, stack:WalkStack) {
		walkArray(elems, stack, walkNBlockElement);
	}
	function walkComplexType_PStructuralExtension_types(elems:Array<NStructuralExtension>, stack:WalkStack) {
		walkArray(elems, stack, walkNStructuralExtension);
	}
	function walkFieldModifier_Inline(keyword:Token, stack:WalkStack) {
		stack = Node(FieldModifier_Inline(keyword), stack);
		{
			walkToken(keyword, Edge("keyword", stack));
		};
	}
	function walkTypeDeclParameter(node:TypeDeclParameter, stack:WalkStack) {
		stack = Node(TypeDeclParameter(node), stack);
		{
			walkNAnnotations(node.annotations, Edge("annotations", stack));
			walkToken(node.name, Edge("name", stack));
			walkConstraints(node.constraints, Edge("constraints", stack));
		};
	}
	function walkComplexType_PAnonymousStructure(braceOpen:Token, fields:NAnonymousTypeFields, braceClose:Token, stack:WalkStack) {
		stack = Node(ComplexType_PAnonymousStructure(braceOpen, fields, braceClose), stack);
		{
			walkToken(braceOpen, Edge("braceOpen", stack));
			walkNAnonymousTypeFields(fields, Edge("fields", stack));
			walkToken(braceClose, Edge("braceClose", stack));
		};
	}
	function walkExpr_EDo(doKeyword:Token, exprBody:Expr, whileKeyword:Token, parenOpen:Token, exprCond:Expr, parenClose:Token, stack:WalkStack) {
		stack = Node(Expr_EDo(doKeyword, exprBody, whileKeyword, parenOpen, exprCond, parenClose), stack);
		{
			walkToken(doKeyword, Edge("doKeyword", stack));
			walkExpr(exprBody, Edge("exprBody", stack));
			walkToken(whileKeyword, Edge("whileKeyword", stack));
			walkToken(parenOpen, Edge("parenOpen", stack));
			walkExpr(exprCond, Edge("exprCond", stack));
			walkToken(parenClose, Edge("parenClose", stack));
		};
	}
	function walkImportMode_IAs(asKeyword:Token, ident:Token, stack:WalkStack) {
		stack = Node(ImportMode_IAs(asKeyword, ident), stack);
		{
			walkToken(asKeyword, Edge("asKeyword", stack));
			walkToken(ident, Edge("ident", stack));
		};
	}
	function walkNFieldExpr(node:NFieldExpr, stack:WalkStack) switch node {
		case PNoFieldExpr(semicolon):walkNFieldExpr_PNoFieldExpr(semicolon, stack);
		case PBlockFieldExpr(e):walkNFieldExpr_PBlockFieldExpr(e, stack);
		case PExprFieldExpr(e, semicolon):walkNFieldExpr_PExprFieldExpr(e, semicolon, stack);
	};
	function walkNCase_PDefault(_default:Token, colon:Token, el:Array<NBlockElement>, stack:WalkStack) {
		stack = Node(NCase_PDefault(_default, colon, el), stack);
		{
			walkToken(_default, Edge("_default", stack));
			walkToken(colon, Edge("colon", stack));
			walkNCase_PDefault_el(el, Edge("el", stack));
		};
	}
	function walkExpr_EFor(forKeyword:Token, parenOpen:Token, exprIter:Expr, parenClose:Token, exprBody:Expr, stack:WalkStack) {
		stack = Node(Expr_EFor(forKeyword, parenOpen, exprIter, parenClose, exprBody), stack);
		{
			walkToken(forKeyword, Edge("forKeyword", stack));
			walkToken(parenOpen, Edge("parenOpen", stack));
			walkExpr(exprIter, Edge("exprIter", stack));
			walkToken(parenClose, Edge("parenClose", stack));
			walkExpr(exprBody, Edge("exprBody", stack));
		};
	}
	function walkNMetadata_PMetadataWithArgs(name:Token, el:CommaSeparated<Expr>, parenClose:Token, stack:WalkStack) {
		stack = Node(NMetadata_PMetadataWithArgs(name, el, parenClose), stack);
		{
			walkToken(name, Edge("name", stack));
			walkNMetadata_PMetadataWithArgs_el(el, Edge("el", stack));
			walkToken(parenClose, Edge("parenClose", stack));
		};
	}
	function walkNCommonFlag(node:NCommonFlag, stack:WalkStack) switch node {
		case PExtern(token):walkNCommonFlag_PExtern(token, stack);
		case PPrivate(token):walkNCommonFlag_PPrivate(token, stack);
	};
	function walkNBlockElement_PVar(_var:Token, vl:CommaSeparated<NVarDeclaration>, semicolon:Token, stack:WalkStack) {
		stack = Node(NBlockElement_PVar(_var, vl, semicolon), stack);
		{
			walkToken(_var, Edge("_var", stack));
			walkNBlockElement_PVar_vl(vl, Edge("vl", stack));
			walkToken(semicolon, Edge("semicolon", stack));
		};
	}
	function walkExpr_EBinop(exprLeft:Expr, op:Token, exprRight:Expr, stack:WalkStack) {
		stack = Node(Expr_EBinop(exprLeft, op, exprRight), stack);
		{
			walkExpr(exprLeft, Edge("exprLeft", stack));
			walkToken(op, Edge("op", stack));
			walkExpr(exprRight, Edge("exprRight", stack));
		};
	}
	function walkNTypePathParameter_PArrayExprTypePathParameter(bracketOpen:Token, el:Null<CommaSeparatedAllowTrailing<Expr>>, bracketClose:Token, stack:WalkStack) {
		stack = Node(NTypePathParameter_PArrayExprTypePathParameter(bracketOpen, el, bracketClose), stack);
		{
			walkToken(bracketOpen, Edge("bracketOpen", stack));
			if (el != null) walkNTypePathParameter_PArrayExprTypePathParameter_el(el, Edge("el", stack));
			walkToken(bracketClose, Edge("bracketClose", stack));
		};
	}
	function walkFieldModifier_Dynamic(keyword:Token, stack:WalkStack) {
		stack = Node(FieldModifier_Dynamic(keyword), stack);
		{
			walkToken(keyword, Edge("keyword", stack));
		};
	}
	function walkClassDecl_relations(elems:Array<ClassRelation>, stack:WalkStack) {
		walkArray(elems, stack, walkClassRelation);
	}
	function walkNPath(node:NPath, stack:WalkStack) {
		stack = Node(NPath(node), stack);
		{
			walkToken(node.ident, Edge("ident", stack));
			walkNPath_idents(node.idents, Edge("idents", stack));
		};
	}
	function walkNAnonymousTypeFields_PAnonymousClassFields_fields(elems:Array<ClassField>, stack:WalkStack) {
		walkArray(elems, stack, walkClassField);
	}
	function walkNTypePathParameter_PArrayExprTypePathParameter_el(elems:CommaSeparatedAllowTrailing<Expr>, stack:WalkStack) {
		walkCommaSeparatedTrailing(elems, stack, walkExpr);
	}
	function walkNStructuralExtension(node:NStructuralExtension, stack:WalkStack) {
		stack = Node(NStructuralExtension(node), stack);
		{
			walkToken(node.gt, Edge("gt", stack));
			walkTypePath(node.path, Edge("path", stack));
			walkToken(node.comma, Edge("comma", stack));
		};
	}
	function walkClassRelation(node:ClassRelation, stack:WalkStack) switch node {
		case Extends(extendsKeyword, path):walkClassRelation_Extends(extendsKeyword, path, stack);
		case Implements(implementsKeyword, path):walkClassRelation_Implements(implementsKeyword, path, stack);
	};
	function walkNVarDeclaration(node:NVarDeclaration, stack:WalkStack) {
		stack = Node(NVarDeclaration(node), stack);
		{
			walkToken(node.name, Edge("name", stack));
			if (node.typeHint != null) walkTypeHint(node.typeHint, Edge("typeHint", stack));
			if (node.assignment != null) walkNAssignment(node.assignment, Edge("assignment", stack));
		};
	}
	function walkExpr_EBlock(braceOpen:Token, elems:Array<NBlockElement>, braceClose:Token, stack:WalkStack) {
		stack = Node(Expr_EBlock(braceOpen, elems, braceClose), stack);
		{
			walkToken(braceOpen, Edge("braceOpen", stack));
			walkExpr_EBlock_elems(elems, Edge("elems", stack));
			walkToken(braceClose, Edge("braceClose", stack));
		};
	}
	function walkExpr_EParenthesis(parenOpen:Token, expr:Expr, parenClose:Token, stack:WalkStack) {
		stack = Node(Expr_EParenthesis(parenOpen, expr, parenClose), stack);
		{
			walkToken(parenOpen, Edge("parenOpen", stack));
			walkExpr(expr, Edge("expr", stack));
			walkToken(parenClose, Edge("parenClose", stack));
		};
	}
	function walkDecl_EnumDecl_flags(elems:Array<NCommonFlag>, stack:WalkStack) {
		walkArray(elems, stack, walkNCommonFlag);
	}
	function walkExpr(node:Expr, stack:WalkStack) switch node {
		case EIs(parenOpen, expr, isKeyword, path, parenClose):walkExpr_EIs(parenOpen, expr, isKeyword, path, parenClose, stack);
		case EMetadata(metadata, expr):walkExpr_EMetadata(metadata, expr, stack);
		case EField(expr, ident):walkExpr_EField(expr, ident, stack);
		case EMacro(macroKeyword, expr):walkExpr_EMacro(macroKeyword, expr, stack);
		case ESwitch(switchKeyword, expr, braceOpen, cases, braceClose):walkExpr_ESwitch(switchKeyword, expr, braceOpen, cases, braceClose, stack);
		case EReturnExpr(returnKeyword, expr):walkExpr_EReturnExpr(returnKeyword, expr, stack);
		case EUnsafeCast(castKeyword, expr):walkExpr_EUnsafeCast(castKeyword, expr, stack);
		case EIn(exprLeft, inKeyword, exprRight):walkExpr_EIn(exprLeft, inKeyword, exprRight, stack);
		case EParenthesis(parenOpen, expr, parenClose):walkExpr_EParenthesis(parenOpen, expr, parenClose, stack);
		case ESafeCast(castKeyword, parenOpen, expr, comma, type, parenClose):walkExpr_ESafeCast(castKeyword, parenOpen, expr, comma, type, parenClose, stack);
		case EIf(ifKeyword, parenOpen, exprCond, parenClose, exprThen, exprElse):walkExpr_EIf(ifKeyword, parenOpen, exprCond, parenClose, exprThen, exprElse, stack);
		case EBlock(braceOpen, elems, braceClose):walkExpr_EBlock(braceOpen, elems, braceClose, stack);
		case EUnaryPrefix(op, expr):walkExpr_EUnaryPrefix(op, expr, stack);
		case EBinop(exprLeft, op, exprRight):walkExpr_EBinop(exprLeft, op, exprRight, stack);
		case ETry(tryKeyword, expr, catches):walkExpr_ETry(tryKeyword, expr, catches, stack);
		case EObjectDecl(braceOpen, fields, braceClose):walkExpr_EObjectDecl(braceOpen, fields, braceClose, stack);
		case EVar(varKeyword, decl):walkExpr_EVar(varKeyword, decl, stack);
		case EBreak(breakKeyword):walkExpr_EBreak(breakKeyword, stack);
		case EFor(forKeyword, parenOpen, exprIter, parenClose, exprBody):walkExpr_EFor(forKeyword, parenOpen, exprIter, parenClose, exprBody, stack);
		case ENew(newKeyword, path, args):walkExpr_ENew(newKeyword, path, args, stack);
		case ECall(expr, args):walkExpr_ECall(expr, args, stack);
		case ECheckType(parenOpen, expr, colon, type, parenClose):walkExpr_ECheckType(parenOpen, expr, colon, type, parenClose, stack);
		case EContinue(continueKeyword):walkExpr_EContinue(continueKeyword, stack);
		case EUnaryPostfix(expr, op):walkExpr_EUnaryPostfix(expr, op, stack);
		case EArrayAccess(expr, bracketOpen, exprKey, bracketClose):walkExpr_EArrayAccess(expr, bracketOpen, exprKey, bracketClose, stack);
		case ETernary(exprCond, questionmark, exprThen, colon, exprElse):walkExpr_ETernary(exprCond, questionmark, exprThen, colon, exprElse, stack);
		case EDo(doKeyword, exprBody, whileKeyword, parenOpen, exprCond, parenClose):walkExpr_EDo(doKeyword, exprBody, whileKeyword, parenOpen, exprCond, parenClose, stack);
		case EMacroEscape(ident, braceOpen, expr, braceClose):walkExpr_EMacroEscape(ident, braceOpen, expr, braceClose, stack);
		case EConst(const):walkExpr_EConst(const, stack);
		case EDollarIdent(ident):walkExpr_EDollarIdent(ident, stack);
		case EFunction(functionKeyword, fun):walkExpr_EFunction(functionKeyword, fun, stack);
		case EReturn(returnKeyword):walkExpr_EReturn(returnKeyword, stack);
		case EWhile(whileKeyword, parenOpen, exprCond, parenClose, exprBody):walkExpr_EWhile(whileKeyword, parenOpen, exprCond, parenClose, exprBody, stack);
		case EArrayDecl(bracketOpen, elems, bracketClose):walkExpr_EArrayDecl(bracketOpen, elems, bracketClose, stack);
		case EIntDot(int, dot):walkExpr_EIntDot(int, dot, stack);
		case EThrow(throwKeyword, expr):walkExpr_EThrow(throwKeyword, expr, stack);
		case EUntyped(untypedKeyword, expr):walkExpr_EUntyped(untypedKeyword, expr, stack);
	};
	function walkExpr_ECall(expr:Expr, args:CallArgs, stack:WalkStack) {
		stack = Node(Expr_ECall(expr, args), stack);
		{
			walkExpr(expr, Edge("expr", stack));
			walkCallArgs(args, Edge("args", stack));
		};
	}
	function walkExpr_EObjectDecl_fields(elems:CommaSeparatedAllowTrailing<ObjectField>, stack:WalkStack) {
		walkCommaSeparatedTrailing(elems, stack, walkObjectField);
	}
	function walkNLiteral_PLiteralString(s:NString, stack:WalkStack) {
		stack = Node(NLiteral_PLiteralString(s), stack);
		{
			walkNString(s, Edge("s", stack));
		};
	}
	function walkTypeDeclParameters(node:TypeDeclParameters, stack:WalkStack) {
		stack = Node(TypeDeclParameters(node), stack);
		{
			walkToken(node.lt, Edge("lt", stack));
			walkTypeDeclParameters_params(node.params, Edge("params", stack));
			walkToken(node.gt, Edge("gt", stack));
		};
	}
	function walkClassRelation_Implements(implementsKeyword:Token, path:TypePath, stack:WalkStack) {
		stack = Node(ClassRelation_Implements(implementsKeyword, path), stack);
		{
			walkToken(implementsKeyword, Edge("implementsKeyword", stack));
			walkTypePath(path, Edge("path", stack));
		};
	}
	function walkNBlockElement_PExpr(e:Expr, semicolon:Token, stack:WalkStack) {
		stack = Node(NBlockElement_PExpr(e, semicolon), stack);
		{
			walkExpr(e, Edge("e", stack));
			walkToken(semicolon, Edge("semicolon", stack));
		};
	}
	function walkNMetadata_PMetadata(name:Token, stack:WalkStack) {
		stack = Node(NMetadata_PMetadata(name), stack);
		{
			walkToken(name, Edge("name", stack));
		};
	}
	function walkNLiteral(node:NLiteral, stack:WalkStack) switch node {
		case PLiteralString(s):walkNLiteral_PLiteralString(s, stack);
		case PLiteralFloat(token):walkNLiteral_PLiteralFloat(token, stack);
		case PLiteralRegex(token):walkNLiteral_PLiteralRegex(token, stack);
		case PLiteralInt(token):walkNLiteral_PLiteralInt(token, stack);
	};
	function walkFieldModifier_Macro(keyword:Token, stack:WalkStack) {
		stack = Node(FieldModifier_Macro(keyword), stack);
		{
			walkToken(keyword, Edge("keyword", stack));
		};
	}
	function walkNCase_PCase_patterns(elems:CommaSeparated<Expr>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkExpr);
	}
	function walkNLiteral_PLiteralRegex(token:Token, stack:WalkStack) {
		stack = Node(NLiteral_PLiteralRegex(token), stack);
		{
			walkToken(token, Edge("token", stack));
		};
	}
	function walkExpr_EWhile(whileKeyword:Token, parenOpen:Token, exprCond:Expr, parenClose:Token, exprBody:Expr, stack:WalkStack) {
		stack = Node(Expr_EWhile(whileKeyword, parenOpen, exprCond, parenClose, exprBody), stack);
		{
			walkToken(whileKeyword, Edge("whileKeyword", stack));
			walkToken(parenOpen, Edge("parenOpen", stack));
			walkExpr(exprCond, Edge("exprCond", stack));
			walkToken(parenClose, Edge("parenClose", stack));
			walkExpr(exprBody, Edge("exprBody", stack));
		};
	}
	function walkAbstractRelation(node:AbstractRelation, stack:WalkStack) switch node {
		case To(toKeyword, type):walkAbstractRelation_To(toKeyword, type, stack);
		case From(fromKeyword, type):walkAbstractRelation_From(fromKeyword, type, stack);
	};
	function walkExpr_EBreak(breakKeyword:Token, stack:WalkStack) {
		stack = Node(Expr_EBreak(breakKeyword), stack);
		{
			walkToken(breakKeyword, Edge("breakKeyword", stack));
		};
	}
	function walkDecl_EnumDecl_fields(elems:Array<NEnumField>, stack:WalkStack) {
		walkArray(elems, stack, walkNEnumField);
	}
	function walkExpr_EIf(ifKeyword:Token, parenOpen:Token, exprCond:Expr, parenClose:Token, exprThen:Expr, exprElse:Null<ExprElse>, stack:WalkStack) {
		stack = Node(Expr_EIf(ifKeyword, parenOpen, exprCond, parenClose, exprThen, exprElse), stack);
		{
			walkToken(ifKeyword, Edge("ifKeyword", stack));
			walkToken(parenOpen, Edge("parenOpen", stack));
			walkExpr(exprCond, Edge("exprCond", stack));
			walkToken(parenClose, Edge("parenClose", stack));
			walkExpr(exprThen, Edge("exprThen", stack));
			if (exprElse != null) walkExprElse(exprElse, Edge("exprElse", stack));
		};
	}
	function walkNConst(node:NConst, stack:WalkStack) switch node {
		case PConstLiteral(literal):walkNConst_PConstLiteral(literal, stack);
		case PConstIdent(ident):walkNConst_PConstIdent(ident, stack);
	};
	function walkNCommonFlag_PExtern(token:Token, stack:WalkStack) {
		stack = Node(NCommonFlag_PExtern(token), stack);
		{
			walkToken(token, Edge("token", stack));
		};
	}
	function walkDecl_UsingDecl(usingKeyword:Token, path:NPath, semicolon:Token, stack:WalkStack) {
		stack = Node(Decl_UsingDecl(usingKeyword, path, semicolon), stack);
		{
			walkToken(usingKeyword, Edge("usingKeyword", stack));
			walkNPath(path, Edge("path", stack));
			walkToken(semicolon, Edge("semicolon", stack));
		};
	}
	function walkAbstractRelation_To(toKeyword:Token, type:ComplexType, stack:WalkStack) {
		stack = Node(AbstractRelation_To(toKeyword, type), stack);
		{
			walkToken(toKeyword, Edge("toKeyword", stack));
			walkComplexType(type, Edge("type", stack));
		};
	}
	function walkDecl_AbstractDecl_fields(elems:Array<ClassField>, stack:WalkStack) {
		walkArray(elems, stack, walkClassField);
	}
	function walkExpr_EObjectDecl(braceOpen:Token, fields:CommaSeparatedAllowTrailing<ObjectField>, braceClose:Token, stack:WalkStack) {
		stack = Node(Expr_EObjectDecl(braceOpen, fields, braceClose), stack);
		{
			walkToken(braceOpen, Edge("braceOpen", stack));
			walkExpr_EObjectDecl_fields(fields, Edge("fields", stack));
			walkToken(braceClose, Edge("braceClose", stack));
		};
	}
	function walkNTypePathParameters(node:NTypePathParameters, stack:WalkStack) {
		stack = Node(NTypePathParameters(node), stack);
		{
			walkToken(node.lt, Edge("lt", stack));
			walkNTypePathParameters_parameters(node.parameters, Edge("parameters", stack));
			walkToken(node.gt, Edge("gt", stack));
		};
	}
	function walkComplexType_PStructuralExtension(braceOpen:Token, types:Array<NStructuralExtension>, fields:NAnonymousTypeFields, braceClose:Token, stack:WalkStack) {
		stack = Node(ComplexType_PStructuralExtension(braceOpen, types, fields, braceClose), stack);
		{
			walkToken(braceOpen, Edge("braceOpen", stack));
			walkComplexType_PStructuralExtension_types(types, Edge("types", stack));
			walkNAnonymousTypeFields(fields, Edge("fields", stack));
			walkToken(braceClose, Edge("braceClose", stack));
		};
	}
	function walkExpr_EIs(parenOpen:Token, expr:Expr, isKeyword:Token, path:TypePath, parenClose:Token, stack:WalkStack) {
		stack = Node(Expr_EIs(parenOpen, expr, isKeyword, path, parenClose), stack);
		{
			walkToken(parenOpen, Edge("parenOpen", stack));
			walkExpr(expr, Edge("expr", stack));
			walkToken(isKeyword, Edge("isKeyword", stack));
			walkTypePath(path, Edge("path", stack));
			walkToken(parenClose, Edge("parenClose", stack));
		};
	}
	function walkClassDecl_fields(elems:Array<ClassField>, stack:WalkStack) {
		walkArray(elems, stack, walkClassField);
	}
	function walkExpr_EField(expr:Expr, ident:NDotIdent, stack:WalkStack) {
		stack = Node(Expr_EField(expr, ident), stack);
		{
			walkExpr(expr, Edge("expr", stack));
			walkNDotIdent(ident, Edge("ident", stack));
		};
	}
	function walkExpr_EIn(exprLeft:Expr, inKeyword:Token, exprRight:Expr, stack:WalkStack) {
		stack = Node(Expr_EIn(exprLeft, inKeyword, exprRight), stack);
		{
			walkExpr(exprLeft, Edge("exprLeft", stack));
			walkToken(inKeyword, Edge("inKeyword", stack));
			walkExpr(exprRight, Edge("exprRight", stack));
		};
	}
	function walkExpr_EUntyped(untypedKeyword:Token, expr:Expr, stack:WalkStack) {
		stack = Node(Expr_EUntyped(untypedKeyword, expr), stack);
		{
			walkToken(untypedKeyword, Edge("untypedKeyword", stack));
			walkExpr(expr, Edge("expr", stack));
		};
	}
	function walkNConst_PConstIdent(ident:Token, stack:WalkStack) {
		stack = Node(NConst_PConstIdent(ident), stack);
		{
			walkToken(ident, Edge("ident", stack));
		};
	}
	function walkNCase(node:NCase, stack:WalkStack) switch node {
		case PCase(_case, patterns, guard, colon, el):walkNCase_PCase(_case, patterns, guard, colon, el, stack);
		case PDefault(_default, colon, el):walkNCase_PDefault(_default, colon, el, stack);
	};
	function walkExpr_EBlock_elems(elems:Array<NBlockElement>, stack:WalkStack) {
		walkArray(elems, stack, walkNBlockElement);
	}
	function walkNAnnotations_metadata(elems:Array<NMetadata>, stack:WalkStack) {
		walkArray(elems, stack, walkNMetadata);
	}
	function walkNFieldExpr_PExprFieldExpr(e:Expr, semicolon:Token, stack:WalkStack) {
		stack = Node(NFieldExpr_PExprFieldExpr(e, semicolon), stack);
		{
			walkExpr(e, Edge("e", stack));
			walkToken(semicolon, Edge("semicolon", stack));
		};
	}
	function walkExpr_EUnsafeCast(castKeyword:Token, expr:Expr, stack:WalkStack) {
		stack = Node(Expr_EUnsafeCast(castKeyword, expr), stack);
		{
			walkToken(castKeyword, Edge("castKeyword", stack));
			walkExpr(expr, Edge("expr", stack));
		};
	}
	function walkExpr_EFunction(functionKeyword:Token, fun:Function, stack:WalkStack) {
		stack = Node(Expr_EFunction(functionKeyword, fun), stack);
		{
			walkToken(functionKeyword, Edge("functionKeyword", stack));
			walkFunction(fun, Edge("fun", stack));
		};
	}
	function walkDecl_ClassDecl_flags(elems:Array<NCommonFlag>, stack:WalkStack) {
		walkArray(elems, stack, walkNCommonFlag);
	}
	function walkNString(node:NString, stack:WalkStack) switch node {
		case PString(s):walkNString_PString(s, stack);
		case PString2(s):walkNString_PString2(s, stack);
	};
	function walkExpr_EArrayDecl(bracketOpen:Token, elems:Null<CommaSeparatedAllowTrailing<Expr>>, bracketClose:Token, stack:WalkStack) {
		stack = Node(Expr_EArrayDecl(bracketOpen, elems, bracketClose), stack);
		{
			walkToken(bracketOpen, Edge("bracketOpen", stack));
			if (elems != null) walkExpr_EArrayDecl_elems(elems, Edge("elems", stack));
			walkToken(bracketClose, Edge("bracketClose", stack));
		};
	}
	function walkNAnnotations(node:NAnnotations, stack:WalkStack) {
		stack = Node(NAnnotations(node), stack);
		{
			if (node.doc != null) walkToken(node.doc, Edge("doc", stack));
			walkNAnnotations_metadata(node.metadata, Edge("metadata", stack));
		};
	}
	function walkNLiteral_PLiteralFloat(token:Token, stack:WalkStack) {
		stack = Node(NLiteral_PLiteralFloat(token), stack);
		{
			walkToken(token, Edge("token", stack));
		};
	}
	function walkExpr_ETry(tryKeyword:Token, expr:Expr, catches:Array<Catch>, stack:WalkStack) {
		stack = Node(Expr_ETry(tryKeyword, expr, catches), stack);
		{
			walkToken(tryKeyword, Edge("tryKeyword", stack));
			walkExpr(expr, Edge("expr", stack));
			walkExpr_ETry_catches(catches, Edge("catches", stack));
		};
	}
	function walkNDotIdent(node:NDotIdent, stack:WalkStack) switch node {
		case PDotIdent(name):walkNDotIdent_PDotIdent(name, stack);
		case PDot(_dot):walkNDotIdent_PDot(_dot, stack);
	};
	function walkClassField_Property(annotations:NAnnotations, modifiers:Array<FieldModifier>, varKeyword:Token, name:Token, parenOpen:Token, read:Token, comma:Token, write:Token, parenClose:Token, typeHint:Null<TypeHint>, assignment:Null<NAssignment>, semicolon:Token, stack:WalkStack) {
		stack = Node(ClassField_Property(annotations, modifiers, varKeyword, name, parenOpen, read, comma, write, parenClose, typeHint, assignment, semicolon), stack);
		{
			walkNAnnotations(annotations, Edge("annotations", stack));
			walkClassField_Property_modifiers(modifiers, Edge("modifiers", stack));
			walkToken(varKeyword, Edge("varKeyword", stack));
			walkToken(name, Edge("name", stack));
			walkToken(parenOpen, Edge("parenOpen", stack));
			walkToken(read, Edge("read", stack));
			walkToken(comma, Edge("comma", stack));
			walkToken(write, Edge("write", stack));
			walkToken(parenClose, Edge("parenClose", stack));
			if (typeHint != null) walkTypeHint(typeHint, Edge("typeHint", stack));
			if (assignment != null) walkNAssignment(assignment, Edge("assignment", stack));
			walkToken(semicolon, Edge("semicolon", stack));
		};
	}
	function walkConstraints_Single(colon:Token, type:ComplexType, stack:WalkStack) {
		stack = Node(Constraints_Single(colon, type), stack);
		{
			walkToken(colon, Edge("colon", stack));
			walkComplexType(type, Edge("type", stack));
		};
	}
	function walkComplexType_PParenthesisType(parenOpen:Token, ct:ComplexType, parenClose:Token, stack:WalkStack) {
		stack = Node(ComplexType_PParenthesisType(parenOpen, ct, parenClose), stack);
		{
			walkToken(parenOpen, Edge("parenOpen", stack));
			walkComplexType(ct, Edge("ct", stack));
			walkToken(parenClose, Edge("parenClose", stack));
		};
	}
	function walkNFieldExpr_PNoFieldExpr(semicolon:Token, stack:WalkStack) {
		stack = Node(NFieldExpr_PNoFieldExpr(semicolon), stack);
		{
			walkToken(semicolon, Edge("semicolon", stack));
		};
	}
	function walkExpr_ETry_catches(elems:Array<Catch>, stack:WalkStack) {
		walkArray(elems, stack, walkCatch);
	}
	function walkFieldModifier_Private(keyword:Token, stack:WalkStack) {
		stack = Node(FieldModifier_Private(keyword), stack);
		{
			walkToken(keyword, Edge("keyword", stack));
		};
	}
	function walkClassField_Function_args(elems:CommaSeparated<FunctionArgument>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkFunctionArgument);
	}
	function walkNTypePathParameter_PTypeTypePathParameter(type:ComplexType, stack:WalkStack) {
		stack = Node(NTypePathParameter_PTypeTypePathParameter(type), stack);
		{
			walkComplexType(type, Edge("type", stack));
		};
	}
	function walkExpr_EConst(const:NConst, stack:WalkStack) {
		stack = Node(Expr_EConst(const), stack);
		{
			walkNConst(const, Edge("const", stack));
		};
	}
	function walkDecl_TypedefDecl(annotations:NAnnotations, flags:Array<NCommonFlag>, typedefKeyword:Token, name:Token, params:Null<TypeDeclParameters>, assign:Token, type:ComplexType, semicolon:Null<Token>, stack:WalkStack) {
		stack = Node(Decl_TypedefDecl(annotations, flags, typedefKeyword, name, params, assign, type, semicolon), stack);
		{
			walkNAnnotations(annotations, Edge("annotations", stack));
			walkDecl_TypedefDecl_flags(flags, Edge("flags", stack));
			walkToken(typedefKeyword, Edge("typedefKeyword", stack));
			walkToken(name, Edge("name", stack));
			if (params != null) walkTypeDeclParameters(params, Edge("params", stack));
			walkToken(assign, Edge("assign", stack));
			walkComplexType(type, Edge("type", stack));
			if (semicolon != null) walkToken(semicolon, Edge("semicolon", stack));
		};
	}
	function walkClassField_Variable(annotations:NAnnotations, modifiers:Array<FieldModifier>, varKeyword:Token, name:Token, typeHint:Null<TypeHint>, assignment:Null<NAssignment>, semicolon:Token, stack:WalkStack) {
		stack = Node(ClassField_Variable(annotations, modifiers, varKeyword, name, typeHint, assignment, semicolon), stack);
		{
			walkNAnnotations(annotations, Edge("annotations", stack));
			walkClassField_Variable_modifiers(modifiers, Edge("modifiers", stack));
			walkToken(varKeyword, Edge("varKeyword", stack));
			walkToken(name, Edge("name", stack));
			if (typeHint != null) walkTypeHint(typeHint, Edge("typeHint", stack));
			if (assignment != null) walkNAssignment(assignment, Edge("assignment", stack));
			walkToken(semicolon, Edge("semicolon", stack));
		};
	}
	function walkExpr_EUnaryPostfix(expr:Expr, op:Token, stack:WalkStack) {
		stack = Node(Expr_EUnaryPostfix(expr, op), stack);
		{
			walkExpr(expr, Edge("expr", stack));
			walkToken(op, Edge("op", stack));
		};
	}
	function walkNTypePathParameters_parameters(elems:CommaSeparated<NTypePathParameter>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNTypePathParameter);
	}
	function walkDecl_TypedefDecl_flags(elems:Array<NCommonFlag>, stack:WalkStack) {
		walkArray(elems, stack, walkNCommonFlag);
	}
	function walkCallArgs(node:CallArgs, stack:WalkStack) {
		stack = Node(CallArgs(node), stack);
		{
			walkToken(node.parenOpen, Edge("parenOpen", stack));
			if (node.args != null) walkCallArgs_args(node.args, Edge("args", stack));
			walkToken(node.parenClose, Edge("parenClose", stack));
		};
	}
	function walkExpr_EArrayAccess(expr:Expr, bracketOpen:Token, exprKey:Expr, bracketClose:Token, stack:WalkStack) {
		stack = Node(Expr_EArrayAccess(expr, bracketOpen, exprKey, bracketClose), stack);
		{
			walkExpr(expr, Edge("expr", stack));
			walkToken(bracketOpen, Edge("bracketOpen", stack));
			walkExpr(exprKey, Edge("exprKey", stack));
			walkToken(bracketClose, Edge("bracketClose", stack));
		};
	}
	function walkImportMode_IIn(inKeyword:Token, ident:Token, stack:WalkStack) {
		stack = Node(ImportMode_IIn(inKeyword, ident), stack);
		{
			walkToken(inKeyword, Edge("inKeyword", stack));
			walkToken(ident, Edge("ident", stack));
		};
	}
	function walkFieldModifier(node:FieldModifier, stack:WalkStack) switch node {
		case Dynamic(keyword):walkFieldModifier_Dynamic(keyword, stack);
		case Inline(keyword):walkFieldModifier_Inline(keyword, stack);
		case Macro(keyword):walkFieldModifier_Macro(keyword, stack);
		case Override(keyword):walkFieldModifier_Override(keyword, stack);
		case Private(keyword):walkFieldModifier_Private(keyword, stack);
		case Public(keyword):walkFieldModifier_Public(keyword, stack);
		case Static(keyword):walkFieldModifier_Static(keyword, stack);
	};
	function walkExpr_EContinue(continueKeyword:Token, stack:WalkStack) {
		stack = Node(Expr_EContinue(continueKeyword), stack);
		{
			walkToken(continueKeyword, Edge("continueKeyword", stack));
		};
	}
	function walkExpr_EMacroEscape(ident:Token, braceOpen:Token, expr:Expr, braceClose:Token, stack:WalkStack) {
		stack = Node(Expr_EMacroEscape(ident, braceOpen, expr, braceClose), stack);
		{
			walkToken(ident, Edge("ident", stack));
			walkToken(braceOpen, Edge("braceOpen", stack));
			walkExpr(expr, Edge("expr", stack));
			walkToken(braceClose, Edge("braceClose", stack));
		};
	}
	function walkExpr_EArrayDecl_elems(elems:CommaSeparatedAllowTrailing<Expr>, stack:WalkStack) {
		walkCommaSeparatedTrailing(elems, stack, walkExpr);
	}
	function walkNLiteral_PLiteralInt(token:Token, stack:WalkStack) {
		stack = Node(NLiteral_PLiteralInt(token), stack);
		{
			walkToken(token, Edge("token", stack));
		};
	}
	function walkTypeHint(node:TypeHint, stack:WalkStack) {
		stack = Node(TypeHint(node), stack);
		{
			walkToken(node.colon, Edge("colon", stack));
			walkComplexType(node.type, Edge("type", stack));
		};
	}
	function walkComplexType_POptionalType(questionmark:Token, type:ComplexType, stack:WalkStack) {
		stack = Node(ComplexType_POptionalType(questionmark, type), stack);
		{
			walkToken(questionmark, Edge("questionmark", stack));
			walkComplexType(type, Edge("type", stack));
		};
	}
	function walkNBlockElement_PInlineFunction(_inline:Token, _function:Token, f:Function, semicolon:Token, stack:WalkStack) {
		stack = Node(NBlockElement_PInlineFunction(_inline, _function, f, semicolon), stack);
		{
			walkToken(_inline, Edge("_inline", stack));
			walkToken(_function, Edge("_function", stack));
			walkFunction(f, Edge("f", stack));
			walkToken(semicolon, Edge("semicolon", stack));
		};
	}
	function walkNCase_PCase_el(elems:Array<NBlockElement>, stack:WalkStack) {
		walkArray(elems, stack, walkNBlockElement);
	}
	function walkClassField_Variable_modifiers(elems:Array<FieldModifier>, stack:WalkStack) {
		walkArray(elems, stack, walkFieldModifier);
	}
	function walkConstraints(node:Constraints, stack:WalkStack) switch node {
		case None:{ };
		case Multiple(colon, parenOpen, types, parenClose):walkConstraints_Multiple(colon, parenOpen, types, parenClose, stack);
		case Single(colon, type):walkConstraints_Single(colon, type, stack);
	};
	function walkObjectField(node:ObjectField, stack:WalkStack) {
		stack = Node(ObjectField(node), stack);
		{
			walkObjectFieldName(node.name, Edge("name", stack));
			walkToken(node.colon, Edge("colon", stack));
			walkExpr(node.expr, Edge("expr", stack));
		};
	}
	function walkNAnonymousTypeFields_PAnonymousClassFields(fields:Array<ClassField>, stack:WalkStack) {
		stack = Node(NAnonymousTypeFields_PAnonymousClassFields(fields), stack);
		{
			walkNAnonymousTypeFields_PAnonymousClassFields_fields(fields, Edge("fields", stack));
		};
	}
	function walkExpr_ESafeCast(castKeyword:Token, parenOpen:Token, expr:Expr, comma:Token, type:ComplexType, parenClose:Token, stack:WalkStack) {
		stack = Node(Expr_ESafeCast(castKeyword, parenOpen, expr, comma, type, parenClose), stack);
		{
			walkToken(castKeyword, Edge("castKeyword", stack));
			walkToken(parenOpen, Edge("parenOpen", stack));
			walkExpr(expr, Edge("expr", stack));
			walkToken(comma, Edge("comma", stack));
			walkComplexType(type, Edge("type", stack));
			walkToken(parenClose, Edge("parenClose", stack));
		};
	}
	function walkNAnonymousTypeField(node:NAnonymousTypeField, stack:WalkStack) {
		stack = Node(NAnonymousTypeField(node), stack);
		{
			if (node.questionmark != null) walkToken(node.questionmark, Edge("questionmark", stack));
			walkToken(node.name, Edge("name", stack));
			walkTypeHint(node.typeHint, Edge("typeHint", stack));
		};
	}
	function walkFile_decls(elems:Array<Decl>, stack:WalkStack) {
		walkArray(elems, stack, walkDecl);
	}
	function walkDecl(node:Decl, stack:WalkStack) switch node {
		case ClassDecl(annotations, flags, classDecl):walkDecl_ClassDecl(annotations, flags, classDecl, stack);
		case TypedefDecl(annotations, flags, typedefKeyword, name, params, assign, type, semicolon):walkDecl_TypedefDecl(annotations, flags, typedefKeyword, name, params, assign, type, semicolon, stack);
		case EnumDecl(annotations, flags, enumKeyword, name, params, braceOpen, fields, braceClose):walkDecl_EnumDecl(annotations, flags, enumKeyword, name, params, braceOpen, fields, braceClose, stack);
		case UsingDecl(usingKeyword, path, semicolon):walkDecl_UsingDecl(usingKeyword, path, semicolon, stack);
		case AbstractDecl(annotations, flags, abstractKeyword, name, params, underlyingType, relations, braceOpen, fields, braceClose):walkDecl_AbstractDecl(annotations, flags, abstractKeyword, name, params, underlyingType, relations, braceOpen, fields, braceClose, stack);
		case ImportDecl(importKeyword, path, mode, semicolon):walkDecl_ImportDecl(importKeyword, path, mode, semicolon, stack);
	};
	function walkNGuard(node:NGuard, stack:WalkStack) {
		stack = Node(NGuard(node), stack);
		{
			walkToken(node._if, Edge("_if", stack));
			walkToken(node.parenOpen, Edge("parenOpen", stack));
			walkExpr(node.e, Edge("e", stack));
			walkToken(node.parenClose, Edge("parenClose", stack));
		};
	}
	function walkCallArgs_args(elems:CommaSeparated<Expr>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkExpr);
	}
	function walkConstraints_Multiple_types(elems:CommaSeparated<ComplexType>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkComplexType);
	}
	function walkNMacroExpr(node:NMacroExpr, stack:WalkStack) switch node {
		case PVar(_var, v):walkNMacroExpr_PVar(_var, v, stack);
		case PTypeHint(typeHint):walkNMacroExpr_PTypeHint(typeHint, stack);
		case PClass(c):walkNMacroExpr_PClass(c, stack);
		case PExpr(e):walkNMacroExpr_PExpr(e, stack);
	};
	function walkNEnumField(node:NEnumField, stack:WalkStack) {
		stack = Node(NEnumField(node), stack);
		{
			walkNAnnotations(node.annotations, Edge("annotations", stack));
			walkToken(node.name, Edge("name", stack));
			if (node.params != null) walkTypeDeclParameters(node.params, Edge("params", stack));
			if (node.args != null) walkNEnumFieldArgs(node.args, Edge("args", stack));
			if (node.typeHint != null) walkTypeHint(node.typeHint, Edge("typeHint", stack));
			walkToken(node.semicolon, Edge("semicolon", stack));
		};
	}
	function walkNBlockElement(node:NBlockElement, stack:WalkStack) switch node {
		case PVar(_var, vl, semicolon):walkNBlockElement_PVar(_var, vl, semicolon, stack);
		case PExpr(e, semicolon):walkNBlockElement_PExpr(e, semicolon, stack);
		case PInlineFunction(_inline, _function, f, semicolon):walkNBlockElement_PInlineFunction(_inline, _function, f, semicolon, stack);
	};
	function walkDecl_EnumDecl(annotations:NAnnotations, flags:Array<NCommonFlag>, enumKeyword:Token, name:Token, params:Null<TypeDeclParameters>, braceOpen:Token, fields:Array<NEnumField>, braceClose:Token, stack:WalkStack) {
		stack = Node(Decl_EnumDecl(annotations, flags, enumKeyword, name, params, braceOpen, fields, braceClose), stack);
		{
			walkNAnnotations(annotations, Edge("annotations", stack));
			walkDecl_EnumDecl_flags(flags, Edge("flags", stack));
			walkToken(enumKeyword, Edge("enumKeyword", stack));
			walkToken(name, Edge("name", stack));
			if (params != null) walkTypeDeclParameters(params, Edge("params", stack));
			walkToken(braceOpen, Edge("braceOpen", stack));
			walkDecl_EnumDecl_fields(fields, Edge("fields", stack));
			walkToken(braceClose, Edge("braceClose", stack));
		};
	}
	function walkExpr_EMacro(macroKeyword:Token, expr:NMacroExpr, stack:WalkStack) {
		stack = Node(Expr_EMacro(macroKeyword, expr), stack);
		{
			walkToken(macroKeyword, Edge("macroKeyword", stack));
			walkNMacroExpr(expr, Edge("expr", stack));
		};
	}
	function walkNEnumFieldArg(node:NEnumFieldArg, stack:WalkStack) {
		stack = Node(NEnumFieldArg(node), stack);
		{
			if (node.questionmark != null) walkToken(node.questionmark, Edge("questionmark", stack));
			walkToken(node.name, Edge("name", stack));
			walkTypeHint(node.typeHint, Edge("typeHint", stack));
		};
	}
	function walkNMetadata(node:NMetadata, stack:WalkStack) switch node {
		case PMetadata(name):walkNMetadata_PMetadata(name, stack);
		case PMetadataWithArgs(name, el, parenClose):walkNMetadata_PMetadataWithArgs(name, el, parenClose, stack);
	};
	function walkNCase_PCase(_case:Token, patterns:CommaSeparated<Expr>, guard:Null<NGuard>, colon:Token, el:Array<NBlockElement>, stack:WalkStack) {
		stack = Node(NCase_PCase(_case, patterns, guard, colon, el), stack);
		{
			walkToken(_case, Edge("_case", stack));
			walkNCase_PCase_patterns(patterns, Edge("patterns", stack));
			if (guard != null) walkNGuard(guard, Edge("guard", stack));
			walkToken(colon, Edge("colon", stack));
			walkNCase_PCase_el(el, Edge("el", stack));
		};
	}
	function walkExpr_EReturnExpr(returnKeyword:Token, expr:Expr, stack:WalkStack) {
		stack = Node(Expr_EReturnExpr(returnKeyword, expr), stack);
		{
			walkToken(returnKeyword, Edge("returnKeyword", stack));
			walkExpr(expr, Edge("expr", stack));
		};
	}
	function walkNMacroExpr_PVar(_var:Token, v:CommaSeparated<NVarDeclaration>, stack:WalkStack) {
		stack = Node(NMacroExpr_PVar(_var, v), stack);
		{
			walkToken(_var, Edge("_var", stack));
			walkNMacroExpr_PVar_v(v, Edge("v", stack));
		};
	}
	function walkUnderlyingType(node:UnderlyingType, stack:WalkStack) {
		stack = Node(UnderlyingType(node), stack);
		{
			walkToken(node.parenOpen, Edge("parenOpen", stack));
			walkComplexType(node.type, Edge("type", stack));
			walkToken(node.parenClose, Edge("parenClose", stack));
		};
	}
	function walkNAnonymousTypeFields(node:NAnonymousTypeFields, stack:WalkStack) switch node {
		case PAnonymousClassFields(fields):walkNAnonymousTypeFields_PAnonymousClassFields(fields, stack);
		case PAnonymousShortFields(fields):walkNAnonymousTypeFields_PAnonymousShortFields(fields, stack);
	};
	function walkNAnonymousTypeFields_PAnonymousShortFields_fields(elems:CommaSeparatedAllowTrailing<NAnonymousTypeField>, stack:WalkStack) {
		walkCommaSeparatedTrailing(elems, stack, walkNAnonymousTypeField);
	}
	function walkExpr_ESwitch(switchKeyword:Token, expr:Expr, braceOpen:Token, cases:Array<NCase>, braceClose:Token, stack:WalkStack) {
		stack = Node(Expr_ESwitch(switchKeyword, expr, braceOpen, cases, braceClose), stack);
		{
			walkToken(switchKeyword, Edge("switchKeyword", stack));
			walkExpr(expr, Edge("expr", stack));
			walkToken(braceOpen, Edge("braceOpen", stack));
			walkExpr_ESwitch_cases(cases, Edge("cases", stack));
			walkToken(braceClose, Edge("braceClose", stack));
		};
	}
	function walkNCommonFlag_PPrivate(token:Token, stack:WalkStack) {
		stack = Node(NCommonFlag_PPrivate(token), stack);
		{
			walkToken(token, Edge("token", stack));
		};
	}
	function walkNString_PString(s:Token, stack:WalkStack) {
		stack = Node(NString_PString(s), stack);
		{
			walkToken(s, Edge("s", stack));
		};
	}
	function walkObjectFieldName(node:ObjectFieldName, stack:WalkStack) switch node {
		case NString(string):walkObjectFieldName_NString(string, stack);
		case NIdent(ident):walkObjectFieldName_NIdent(ident, stack);
	};
	function walkImportMode_IAll(dotstar:Token, stack:WalkStack) {
		stack = Node(ImportMode_IAll(dotstar), stack);
		{
			walkToken(dotstar, Edge("dotstar", stack));
		};
	}
	function walkClassField(node:ClassField, stack:WalkStack) switch node {
		case Property(annotations, modifiers, varKeyword, name, parenOpen, read, comma, write, parenClose, typeHint, assignment, semicolon):walkClassField_Property(annotations, modifiers, varKeyword, name, parenOpen, read, comma, write, parenClose, typeHint, assignment, semicolon, stack);
		case Variable(annotations, modifiers, varKeyword, name, typeHint, assignment, semicolon):walkClassField_Variable(annotations, modifiers, varKeyword, name, typeHint, assignment, semicolon, stack);
		case Function(annotations, modifiers, functionKeyword, name, params, parenOpen, args, parenClose, typeHint, expr):walkClassField_Function(annotations, modifiers, functionKeyword, name, params, parenOpen, args, parenClose, typeHint, expr, stack);
	};
	function walkExpr_ESwitch_cases(elems:Array<NCase>, stack:WalkStack) {
		walkArray(elems, stack, walkNCase);
	}
	function walkExpr_EUnaryPrefix(op:Token, expr:Expr, stack:WalkStack) {
		stack = Node(Expr_EUnaryPrefix(op, expr), stack);
		{
			walkToken(op, Edge("op", stack));
			walkExpr(expr, Edge("expr", stack));
		};
	}
	function walkObjectFieldName_NIdent(ident:Token, stack:WalkStack) {
		stack = Node(ObjectFieldName_NIdent(ident), stack);
		{
			walkToken(ident, Edge("ident", stack));
		};
	}
	function walkComplexType_PTypePath(path:TypePath, stack:WalkStack) {
		stack = Node(ComplexType_PTypePath(path), stack);
		{
			walkTypePath(path, Edge("path", stack));
		};
	}
	function walkFunction_args(elems:CommaSeparated<FunctionArgument>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkFunctionArgument);
	}
}