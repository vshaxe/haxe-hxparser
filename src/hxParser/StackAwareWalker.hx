// This file is autogenerated from ParseTree data structures
// Use build-walker.hxml to re-generate!

package hxParser;

import hxParser.ParseTree;

class StackAwareWalker {
	function walkToken(token:Token, stack:WalkStack) { }
	function walkArray<T>(elems:Array<T>, stack:WalkStack, walk:T -> WalkStack -> Void) {
		for (i in 0 ... elems.length) walk(elems[i], Element(i, stack));
	}
	function walkCommaSeparated<T>(elems:CommaSeparated<T>, stack:WalkStack, walk:T -> WalkStack -> Void) {
		walk(elems.arg, Element(0, stack));
		var i = 1;
		for (el in elems.args) {
			walkToken(el.comma, Edge("comma", stack));
			walk(el.arg, Element(i, stack));
			i++;
		};
	}
	function walkCommaSeparatedTrailing<T>(elems:CommaSeparatedAllowTrailing<T>, stack:WalkStack, walk:T -> WalkStack -> Void) {
		walk(elems.arg, Element(0, stack));
		var i = 1;
		for (el in elems.args) {
			walkToken(el.comma, Edge("comma", stack));
			walk(el.arg, Element(i, stack));
			i++;
		};
		if (elems.comma != null) walkToken(elems.comma, Edge("commaTrailing", stack));
	}
	function walkNBlockElement_PVar_vl(elems:CommaSeparated<NVarDeclaration>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNVarDeclaration);
	}
	function walkNObjectFieldName_PString(string:NString, stack:WalkStack) {
		stack = Node(NObjectFieldName_PString(string), stack);
		{
			walkNString(string, Edge("string", stack));
		};
	}
	function walkNExpr_PArrayDecl_el(elems:CommaSeparatedAllowTrailing<NExpr>, stack:WalkStack) {
		walkCommaSeparatedTrailing(elems, stack, walkNExpr);
	}
	function walkDecl_ClassDecl(annotations:NAnnotations, flags:Array<NCommonFlag>, classDecl:ClassDecl, stack:WalkStack) {
		stack = Node(Decl_ClassDecl(annotations, flags, classDecl), stack);
		{
			walkNAnnotations(annotations, Edge("annotations", stack));
			walkDecl_ClassDecl_flags(flags, Edge("flags", stack));
			walkClassDecl(classDecl, Edge("classDecl", stack));
		};
	}
	function walkNObjectFieldName(node:NObjectFieldName, stack:WalkStack) switch node {
		case PString(string):walkNObjectFieldName_PString(string, stack);
		case PIdent(ident):walkNObjectFieldName_PIdent(ident, stack);
	};
	function walkDecl_AbstractDecl_relations(elems:Array<NAbstractRelation>, stack:WalkStack) {
		walkArray(elems, stack, walkNAbstractRelation);
	}
	function walkNTypeHint(node:NTypeHint, stack:WalkStack) {
		stack = Node(NTypeHint(node), stack);
		{
			walkToken(node.colon, Edge("colon", stack));
			walkNComplexType(node.type, Edge("type", stack));
		};
	}
	function walkNString_PString2(s:Token, stack:WalkStack) {
		stack = Node(NString_PString2(s), stack);
		{
			walkToken(s, Edge("s", stack));
		};
	}
	function walkNExpr_PVar(_var:Token, d:NVarDeclaration, stack:WalkStack) {
		stack = Node(NExpr_PVar(_var, d), stack);
		{
			walkToken(_var, Edge("_var", stack));
			walkNVarDeclaration(d, Edge("d", stack));
		};
	}
	function walkNDotIdent_PDotIdent(name:Token, stack:WalkStack) {
		stack = Node(NDotIdent_PDotIdent(name), stack);
		{
			walkToken(name, Edge("name", stack));
		};
	}
	function walkNExpr_PDo(_do:Token, e1:NExpr, _while:Token, popen:Token, e2:NExpr, pclose:Token, stack:WalkStack) {
		stack = Node(NExpr_PDo(_do, e1, _while, popen, e2, pclose), stack);
		{
			walkToken(_do, Edge("_do", stack));
			walkNExpr(e1, Edge("e1", stack));
			walkToken(_while, Edge("_while", stack));
			walkToken(popen, Edge("popen", stack));
			walkNExpr(e2, Edge("e2", stack));
			walkToken(pclose, Edge("pclose", stack));
		};
	}
	function walkNFieldExpr_PBlockFieldExpr(e:NExpr, stack:WalkStack) {
		stack = Node(NFieldExpr_PBlockFieldExpr(e), stack);
		{
			walkNExpr(e, Edge("e", stack));
		};
	}
	function walkNMacroExpr_PVar_v(elems:CommaSeparated<NVarDeclaration>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNVarDeclaration);
	}
	function walkNTypePathParameter_PConstantTypePathParameter(constant:NLiteral, stack:WalkStack) {
		stack = Node(NTypePathParameter_PConstantTypePathParameter(constant), stack);
		{
			walkNLiteral(constant, Edge("constant", stack));
		};
	}
	function walkNEnumFieldArgs(node:NEnumFieldArgs, stack:WalkStack) {
		stack = Node(NEnumFieldArgs(node), stack);
		{
			walkToken(node.popen, Edge("popen", stack));
			if (node.args != null) walkNEnumFieldArgs_args(node.args, Edge("args", stack));
			walkToken(node.pclose, Edge("pclose", stack));
		};
	}
	function walkNPath_idents(elems:Array<NDotIdent>, stack:WalkStack) {
		walkArray(elems, stack, walkNDotIdent);
	}
	function walkNMacroExpr_PClass(c:ClassDecl, stack:WalkStack) {
		stack = Node(NMacroExpr_PClass(c), stack);
		{
			walkClassDecl(c, Edge("c", stack));
		};
	}
	function walkNExpr_PBlock(braceOpen:Token, elems:Array<NBlockElement>, braceClose:Token, stack:WalkStack) {
		stack = Node(NExpr_PBlock(braceOpen, elems, braceClose), stack);
		{
			walkToken(braceOpen, Edge("braceOpen", stack));
			walkNExpr_PBlock_elems(elems, Edge("elems", stack));
			walkToken(braceClose, Edge("braceClose", stack));
		};
	}
	function walkNModifier_PModifierPrivate(token:Token, stack:WalkStack) {
		stack = Node(NModifier_PModifierPrivate(token), stack);
		{
			walkToken(token, Edge("token", stack));
		};
	}
	function walkNClassRelation_PExtends(_extends:Token, path:NTypePath, stack:WalkStack) {
		stack = Node(NClassRelation_PExtends(_extends, path), stack);
		{
			walkToken(_extends, Edge("_extends", stack));
			walkNTypePath(path, Edge("path", stack));
		};
	}
	function walkNExpr_PUnsafeCast(_cast:Token, e:NExpr, stack:WalkStack) {
		stack = Node(NExpr_PUnsafeCast(_cast, e), stack);
		{
			walkToken(_cast, Edge("_cast", stack));
			walkNExpr(e, Edge("e", stack));
		};
	}
	function walkNTypePathParameter(node:NTypePathParameter, stack:WalkStack) switch node {
		case PArrayExprTypePathParameter(bkopen, el, bkclose):walkNTypePathParameter_PArrayExprTypePathParameter(bkopen, el, bkclose, stack);
		case PConstantTypePathParameter(constant):walkNTypePathParameter_PConstantTypePathParameter(constant, stack);
		case PTypeTypePathParameter(type):walkNTypePathParameter_PTypeTypePathParameter(type, stack);
	};
	function walkNConst_PConstLiteral(literal:NLiteral, stack:WalkStack) {
		stack = Node(NConst_PConstLiteral(literal), stack);
		{
			walkNLiteral(literal, Edge("literal", stack));
		};
	}
	function walkClassDecl(node:ClassDecl, stack:WalkStack) {
		stack = Node(ClassDecl(node), stack);
		{
			walkToken(node.kind, Edge("kind", stack));
			walkToken(node.name, Edge("name", stack));
			if (node.params != null) walkNTypeDeclParameters(node.params, Edge("params", stack));
			walkClassDecl_relations(node.relations, Edge("relations", stack));
			walkToken(node.braceOpen, Edge("braceOpen", stack));
			walkClassDecl_fields(node.fields, Edge("fields", stack));
			walkToken(node.braceClose, Edge("braceClose", stack));
		};
	}
	function walkNExpr_PMetadata(metadata:NMetadata, e:NExpr, stack:WalkStack) {
		stack = Node(NExpr_PMetadata(metadata, e), stack);
		{
			walkNMetadata(metadata, Edge("metadata", stack));
			walkNExpr(e, Edge("e", stack));
		};
	}
	function walkImportMode(node:ImportMode, stack:WalkStack) switch node {
		case IIn(inKeyword, ident):walkImportMode_IIn(inKeyword, ident, stack);
		case INormal:{ };
		case IAll(dotstar):walkImportMode_IAll(dotstar, stack);
		case IAs(asKeyword, ident):walkImportMode_IAs(asKeyword, ident, stack);
	};
	function walkFile(node:File, stack:WalkStack) {
		stack = Node(File(node), stack);
		{
			if (node.pack != null) walkPackage(node.pack, Edge("pack", stack));
			walkFile_decls(node.decls, Edge("decls", stack));
			walkToken(node.eof, Edge("eof", stack));
		};
	}
	function walkDecl_ImportDecl(importKeyword:Token, path:NPath, mode:ImportMode, semicolon:Token, stack:WalkStack) {
		stack = Node(Decl_ImportDecl(importKeyword, path, mode, semicolon), stack);
		{
			walkToken(importKeyword, Edge("importKeyword", stack));
			walkNPath(path, Edge("path", stack));
			walkImportMode(mode, Edge("mode", stack));
			walkToken(semicolon, Edge("semicolon", stack));
		};
	}
	function walkNDotIdent_PDot(_dot:Token, stack:WalkStack) {
		stack = Node(NDotIdent_PDot(_dot), stack);
		{
			walkToken(_dot, Edge("_dot", stack));
		};
	}
	function walkNMetadata_PMetadataWithArgs_el(elems:CommaSeparated<NExpr>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNExpr);
	}
	function walkNAnonymousTypeFields_PAnonymousShortFields(fields:Null<CommaSeparatedAllowTrailing<NAnonymousTypeField>>, stack:WalkStack) {
		stack = Node(NAnonymousTypeFields_PAnonymousShortFields(fields), stack);
		{
			if (fields != null) walkNAnonymousTypeFields_PAnonymousShortFields_fields(fields, Edge("fields", stack));
		};
	}
	function walkNClassField_PPropertyField_modifiers(elems:Array<NModifier>, stack:WalkStack) {
		walkArray(elems, stack, walkNModifier);
	}
	function walkNExpr_PSwitch_cases(elems:Array<NCase>, stack:WalkStack) {
		walkArray(elems, stack, walkNCase);
	}
	function walkNExpr_PSafeCast(_cast:Token, popen:Token, e:NExpr, comma:Token, ct:NComplexType, pclose:Token, stack:WalkStack) {
		stack = Node(NExpr_PSafeCast(_cast, popen, e, comma, ct, pclose), stack);
		{
			walkToken(_cast, Edge("_cast", stack));
			walkToken(popen, Edge("popen", stack));
			walkNExpr(e, Edge("e", stack));
			walkToken(comma, Edge("comma", stack));
			walkNComplexType(ct, Edge("ct", stack));
			walkToken(pclose, Edge("pclose", stack));
		};
	}
	function walkDecl_AbstractDecl_flags(elems:Array<NCommonFlag>, stack:WalkStack) {
		walkArray(elems, stack, walkNCommonFlag);
	}
	function walkNExpr(node:NExpr, stack:WalkStack) switch node {
		case PVar(_var, d):walkNExpr_PVar(_var, d, stack);
		case PConst(const):walkNExpr_PConst(const, stack);
		case PDo(_do, e1, _while, popen, e2, pclose):walkNExpr_PDo(_do, e1, _while, popen, e2, pclose, stack);
		case PMacro(_macro, e):walkNExpr_PMacro(_macro, e, stack);
		case PWhile(_while, popen, e1, pclose, e2):walkNExpr_PWhile(_while, popen, e1, pclose, e2, stack);
		case PIntDot(int, dot):walkNExpr_PIntDot(int, dot, stack);
		case PBlock(braceOpen, elems, braceClose):walkNExpr_PBlock(braceOpen, elems, braceClose, stack);
		case PFunction(_function, f):walkNExpr_PFunction(_function, f, stack);
		case PSwitch(_switch, e, braceOpen, cases, braceClose):walkNExpr_PSwitch(_switch, e, braceOpen, cases, braceClose, stack);
		case PReturn(_return):walkNExpr_PReturn(_return, stack);
		case PArrayDecl(bkopen, el, bkclose):walkNExpr_PArrayDecl(bkopen, el, bkclose, stack);
		case PDollarIdent(ident):walkNExpr_PDollarIdent(ident, stack);
		case PIf(_if, popen, e1, pclose, e2, elseExpr):walkNExpr_PIf(_if, popen, e1, pclose, e2, elseExpr, stack);
		case PReturnExpr(_return, e):walkNExpr_PReturnExpr(_return, e, stack);
		case PArray(e1, bkopen, e2, bkclose):walkNExpr_PArray(e1, bkopen, e2, bkclose, stack);
		case PContinue(_continue):walkNExpr_PContinue(_continue, stack);
		case PParenthesis(popen, e, pclose):walkNExpr_PParenthesis(popen, e, pclose, stack);
		case PTry(_try, e, catches):walkNExpr_PTry(_try, e, catches, stack);
		case PBreak(_break):walkNExpr_PBreak(_break, stack);
		case PCall(e, el):walkNExpr_PCall(e, el, stack);
		case PUnaryPostfix(e, op):walkNExpr_PUnaryPostfix(e, op, stack);
		case PBinop(e1, op, e2):walkNExpr_PBinop(e1, op, e2, stack);
		case PSafeCast(_cast, popen, e, comma, ct, pclose):walkNExpr_PSafeCast(_cast, popen, e, comma, ct, pclose, stack);
		case PUnaryPrefix(op, e):walkNExpr_PUnaryPrefix(op, e, stack);
		case PMacroEscape(ident, braceOpen, e, braceClose):walkNExpr_PMacroEscape(ident, braceOpen, e, braceClose, stack);
		case PIn(e1, _in, e2):walkNExpr_PIn(e1, _in, e2, stack);
		case PMetadata(metadata, e):walkNExpr_PMetadata(metadata, e, stack);
		case PUnsafeCast(_cast, e):walkNExpr_PUnsafeCast(_cast, e, stack);
		case PCheckType(popen, e, colon, type, pclose):walkNExpr_PCheckType(popen, e, colon, type, pclose, stack);
		case PUntyped(_untyped, e):walkNExpr_PUntyped(_untyped, e, stack);
		case PField(e, ident):walkNExpr_PField(e, ident, stack);
		case PIs(popen, e, _is, path, pclose):walkNExpr_PIs(popen, e, _is, path, pclose, stack);
		case PTernary(e1, questionmark, e2, colon, e3):walkNExpr_PTernary(e1, questionmark, e2, colon, e3, stack);
		case PObjectDecl(braceOpen, fl, braceClose):walkNExpr_PObjectDecl(braceOpen, fl, braceClose, stack);
		case PNew(_new, path, el):walkNExpr_PNew(_new, path, el, stack);
		case PThrow(_throw, e):walkNExpr_PThrow(_throw, e, stack);
		case PFor(_for, popen, e1, pclose, e2):walkNExpr_PFor(_for, popen, e1, pclose, e2, stack);
	};
	function walkNCallArgs(node:NCallArgs, stack:WalkStack) {
		stack = Node(NCallArgs(node), stack);
		{
			walkToken(node.popen, Edge("popen", stack));
			if (node.args != null) walkNCallArgs_args(node.args, Edge("args", stack));
			walkToken(node.pclose, Edge("pclose", stack));
		};
	}
	function walkNEnumFieldArgs_args(elems:CommaSeparated<NEnumFieldArg>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNEnumFieldArg);
	}
	function walkDecl_AbstractDecl(annotations:NAnnotations, flags:Array<NCommonFlag>, abstractKeyword:Token, name:Token, params:Null<NTypeDeclParameters>, underlyingType:Null<NUnderlyingType>, relations:Array<NAbstractRelation>, braceOpen:Token, fields:Array<NClassField>, braceClose:Token, stack:WalkStack) {
		stack = Node(Decl_AbstractDecl(annotations, flags, abstractKeyword, name, params, underlyingType, relations, braceOpen, fields, braceClose), stack);
		{
			walkNAnnotations(annotations, Edge("annotations", stack));
			walkDecl_AbstractDecl_flags(flags, Edge("flags", stack));
			walkToken(abstractKeyword, Edge("abstractKeyword", stack));
			walkToken(name, Edge("name", stack));
			if (params != null) walkNTypeDeclParameters(params, Edge("params", stack));
			if (underlyingType != null) walkNUnderlyingType(underlyingType, Edge("underlyingType", stack));
			walkDecl_AbstractDecl_relations(relations, Edge("relations", stack));
			walkToken(braceOpen, Edge("braceOpen", stack));
			walkDecl_AbstractDecl_fields(fields, Edge("fields", stack));
			walkToken(braceClose, Edge("braceClose", stack));
		};
	}
	function walkPackage(node:Package, stack:WalkStack) {
		stack = Node(Package(node), stack);
		{
			walkToken(node.packageKeyword, Edge("packageKeyword", stack));
			if (node.path != null) walkNPath(node.path, Edge("path", stack));
			walkToken(node.semicolon, Edge("semicolon", stack));
		};
	}
	function walkNConstraints_PMultipleConstraints(colon:Token, popen:Token, types:CommaSeparated<NComplexType>, pclose:Token, stack:WalkStack) {
		stack = Node(NConstraints_PMultipleConstraints(colon, popen, types, pclose), stack);
		{
			walkToken(colon, Edge("colon", stack));
			walkToken(popen, Edge("popen", stack));
			walkNConstraints_PMultipleConstraints_types(types, Edge("types", stack));
			walkToken(pclose, Edge("pclose", stack));
		};
	}
	function walkNExpr_PObjectDecl_fl(elems:CommaSeparatedAllowTrailing<NObjectField>, stack:WalkStack) {
		walkCommaSeparatedTrailing(elems, stack, walkNObjectField);
	}
	function walkNExpr_PConst(const:NConst, stack:WalkStack) {
		stack = Node(NExpr_PConst(const), stack);
		{
			walkNConst(const, Edge("const", stack));
		};
	}
	function walkNExpr_PParenthesis(popen:Token, e:NExpr, pclose:Token, stack:WalkStack) {
		stack = Node(NExpr_PParenthesis(popen, e, pclose), stack);
		{
			walkToken(popen, Edge("popen", stack));
			walkNExpr(e, Edge("e", stack));
			walkToken(pclose, Edge("pclose", stack));
		};
	}
	function walkNComplexType(node:NComplexType, stack:WalkStack) switch node {
		case PFunctionType(type1, arrow, type2):walkNComplexType_PFunctionType(type1, arrow, type2, stack);
		case PStructuralExtension(braceOpen, types, fields, braceClose):walkNComplexType_PStructuralExtension(braceOpen, types, fields, braceClose, stack);
		case PParenthesisType(popen, ct, pclose):walkNComplexType_PParenthesisType(popen, ct, pclose, stack);
		case PAnonymousStructure(braceOpen, fields, braceClose):walkNComplexType_PAnonymousStructure(braceOpen, fields, braceClose, stack);
		case PTypePath(path):walkNComplexType_PTypePath(path, stack);
		case POptionalType(questionmark, type):walkNComplexType_POptionalType(questionmark, type, stack);
	};
	function walkNComplexType_PStructuralExtension_types(elems:Array<NStructuralExtension>, stack:WalkStack) {
		walkArray(elems, stack, walkNStructuralExtension);
	}
	function walkNMacroExpr_PExpr(e:NExpr, stack:WalkStack) {
		stack = Node(NMacroExpr_PExpr(e), stack);
		{
			walkNExpr(e, Edge("e", stack));
		};
	}
	function walkNExpr_PBreak(_break:Token, stack:WalkStack) {
		stack = Node(NExpr_PBreak(_break), stack);
		{
			walkToken(_break, Edge("_break", stack));
		};
	}
	function walkNModifier_PModifierInline(token:Token, stack:WalkStack) {
		stack = Node(NModifier_PModifierInline(token), stack);
		{
			walkToken(token, Edge("token", stack));
		};
	}
	function walkNClassField_PVariableField(annotations:NAnnotations, modifiers:Array<NModifier>, _var:Token, name:Token, typeHint:Null<NTypeHint>, assignment:Null<NAssignment>, semicolon:Token, stack:WalkStack) {
		stack = Node(NClassField_PVariableField(annotations, modifiers, _var, name, typeHint, assignment, semicolon), stack);
		{
			walkNAnnotations(annotations, Edge("annotations", stack));
			walkNClassField_PVariableField_modifiers(modifiers, Edge("modifiers", stack));
			walkToken(_var, Edge("_var", stack));
			walkToken(name, Edge("name", stack));
			if (typeHint != null) walkNTypeHint(typeHint, Edge("typeHint", stack));
			if (assignment != null) walkNAssignment(assignment, Edge("assignment", stack));
			walkToken(semicolon, Edge("semicolon", stack));
		};
	}
	function walkNTypeDeclParameters_params(elems:CommaSeparated<NTypeDeclParameter>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNTypeDeclParameter);
	}
	function walkNMacroExpr_PTypeHint(type:NTypeHint, stack:WalkStack) {
		stack = Node(NMacroExpr_PTypeHint(type), stack);
		{
			walkNTypeHint(type, Edge("type", stack));
		};
	}
	function walkNExpr_PArrayDecl(bkopen:Token, el:Null<CommaSeparatedAllowTrailing<NExpr>>, bkclose:Token, stack:WalkStack) {
		stack = Node(NExpr_PArrayDecl(bkopen, el, bkclose), stack);
		{
			walkToken(bkopen, Edge("bkopen", stack));
			if (el != null) walkNExpr_PArrayDecl_el(el, Edge("el", stack));
			walkToken(bkclose, Edge("bkclose", stack));
		};
	}
	function walkNAssignment(node:NAssignment, stack:WalkStack) {
		stack = Node(NAssignment(node), stack);
		{
			walkToken(node.assign, Edge("assign", stack));
			walkNExpr(node.e, Edge("e", stack));
		};
	}
	function walkNComplexType_POptionalType(questionmark:Token, type:NComplexType, stack:WalkStack) {
		stack = Node(NComplexType_POptionalType(questionmark, type), stack);
		{
			walkToken(questionmark, Edge("questionmark", stack));
			walkNComplexType(type, Edge("type", stack));
		};
	}
	function walkNComplexType_PAnonymousStructure(braceOpen:Token, fields:NAnonymousTypeFields, braceClose:Token, stack:WalkStack) {
		stack = Node(NComplexType_PAnonymousStructure(braceOpen, fields, braceClose), stack);
		{
			walkToken(braceOpen, Edge("braceOpen", stack));
			walkNAnonymousTypeFields(fields, Edge("fields", stack));
			walkToken(braceClose, Edge("braceClose", stack));
		};
	}
	function walkNCase_PDefault_el(elems:Array<NBlockElement>, stack:WalkStack) {
		walkArray(elems, stack, walkNBlockElement);
	}
	function walkNCallArgs_args(elems:CommaSeparated<NExpr>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNExpr);
	}
	function walkNAbstractRelation(node:NAbstractRelation, stack:WalkStack) switch node {
		case PFrom(_from, type):walkNAbstractRelation_PFrom(_from, type, stack);
		case PTo(_to, type):walkNAbstractRelation_PTo(_to, type, stack);
	};
	function walkNExpr_PObjectDecl(braceOpen:Token, fl:CommaSeparatedAllowTrailing<NObjectField>, braceClose:Token, stack:WalkStack) {
		stack = Node(NExpr_PObjectDecl(braceOpen, fl, braceClose), stack);
		{
			walkToken(braceOpen, Edge("braceOpen", stack));
			walkNExpr_PObjectDecl_fl(fl, Edge("fl", stack));
			walkToken(braceClose, Edge("braceClose", stack));
		};
	}
	function walkNCatch(node:NCatch, stack:WalkStack) {
		stack = Node(NCatch(node), stack);
		{
			walkToken(node._catch, Edge("_catch", stack));
			walkToken(node.popen, Edge("popen", stack));
			walkToken(node.ident, Edge("ident", stack));
			walkNTypeHint(node.type, Edge("type", stack));
			walkToken(node.pclose, Edge("pclose", stack));
			walkNExpr(node.e, Edge("e", stack));
		};
	}
	function walkNAbstractRelation_PTo(_to:Token, type:NComplexType, stack:WalkStack) {
		stack = Node(NAbstractRelation_PTo(_to, type), stack);
		{
			walkToken(_to, Edge("_to", stack));
			walkNComplexType(type, Edge("type", stack));
		};
	}
	function walkNTypeDeclParameter(node:NTypeDeclParameter, stack:WalkStack) {
		stack = Node(NTypeDeclParameter(node), stack);
		{
			walkNAnnotations(node.annotations, Edge("annotations", stack));
			walkToken(node.name, Edge("name", stack));
			walkNConstraints(node.constraints, Edge("constraints", stack));
		};
	}
	function walkNExpr_PIntDot(int:Token, dot:Token, stack:WalkStack) {
		stack = Node(NExpr_PIntDot(int, dot), stack);
		{
			walkToken(int, Edge("int", stack));
			walkToken(dot, Edge("dot", stack));
		};
	}
	function walkNComplexType_PParenthesisType(popen:Token, ct:NComplexType, pclose:Token, stack:WalkStack) {
		stack = Node(NComplexType_PParenthesisType(popen, ct, pclose), stack);
		{
			walkToken(popen, Edge("popen", stack));
			walkNComplexType(ct, Edge("ct", stack));
			walkToken(pclose, Edge("pclose", stack));
		};
	}
	function walkImportMode_IAs(asKeyword:Token, ident:Token, stack:WalkStack) {
		stack = Node(ImportMode_IAs(asKeyword, ident), stack);
		{
			walkToken(asKeyword, Edge("asKeyword", stack));
			walkToken(ident, Edge("ident", stack));
		};
	}
	function walkNModifier(node:NModifier, stack:WalkStack) switch node {
		case PModifierStatic(token):walkNModifier_PModifierStatic(token, stack);
		case PModifierOverride(token):walkNModifier_PModifierOverride(token, stack);
		case PModifierMacro(token):walkNModifier_PModifierMacro(token, stack);
		case PModifierDynamic(token):walkNModifier_PModifierDynamic(token, stack);
		case PModifierInline(token):walkNModifier_PModifierInline(token, stack);
		case PModifierPrivate(token):walkNModifier_PModifierPrivate(token, stack);
		case PModifierPublic(token):walkNModifier_PModifierPublic(token, stack);
	};
	function walkNFieldExpr(node:NFieldExpr, stack:WalkStack) switch node {
		case PNoFieldExpr(semicolon):walkNFieldExpr_PNoFieldExpr(semicolon, stack);
		case PBlockFieldExpr(e):walkNFieldExpr_PBlockFieldExpr(e, stack);
		case PExprFieldExpr(e, semicolon):walkNFieldExpr_PExprFieldExpr(e, semicolon, stack);
	};
	function walkNCase_PDefault(_default:Token, colon:Token, el:Array<NBlockElement>, stack:WalkStack) {
		stack = Node(NCase_PDefault(_default, colon, el), stack);
		{
			walkToken(_default, Edge("_default", stack));
			walkToken(colon, Edge("colon", stack));
			walkNCase_PDefault_el(el, Edge("el", stack));
		};
	}
	function walkNMetadata_PMetadataWithArgs(name:Token, el:CommaSeparated<NExpr>, pclose:Token, stack:WalkStack) {
		stack = Node(NMetadata_PMetadataWithArgs(name, el, pclose), stack);
		{
			walkToken(name, Edge("name", stack));
			walkNMetadata_PMetadataWithArgs_el(el, Edge("el", stack));
			walkToken(pclose, Edge("pclose", stack));
		};
	}
	function walkNCommonFlag(node:NCommonFlag, stack:WalkStack) switch node {
		case PExtern(token):walkNCommonFlag_PExtern(token, stack);
		case PPrivate(token):walkNCommonFlag_PPrivate(token, stack);
	};
	function walkNModifier_PModifierDynamic(token:Token, stack:WalkStack) {
		stack = Node(NModifier_PModifierDynamic(token), stack);
		{
			walkToken(token, Edge("token", stack));
		};
	}
	function walkNClassField_PFunctionField_modifiers(elems:Array<NModifier>, stack:WalkStack) {
		walkArray(elems, stack, walkNModifier);
	}
	function walkNExpr_PArray(e1:NExpr, bkopen:Token, e2:NExpr, bkclose:Token, stack:WalkStack) {
		stack = Node(NExpr_PArray(e1, bkopen, e2, bkclose), stack);
		{
			walkNExpr(e1, Edge("e1", stack));
			walkToken(bkopen, Edge("bkopen", stack));
			walkNExpr(e2, Edge("e2", stack));
			walkToken(bkclose, Edge("bkclose", stack));
		};
	}
	function walkNBlockElement_PVar(_var:Token, vl:CommaSeparated<NVarDeclaration>, semicolon:Token, stack:WalkStack) {
		stack = Node(NBlockElement_PVar(_var, vl, semicolon), stack);
		{
			walkToken(_var, Edge("_var", stack));
			walkNBlockElement_PVar_vl(vl, Edge("vl", stack));
			walkToken(semicolon, Edge("semicolon", stack));
		};
	}
	function walkNTypePathParameter_PArrayExprTypePathParameter(bkopen:Token, el:Null<CommaSeparatedAllowTrailing<NExpr>>, bkclose:Token, stack:WalkStack) {
		stack = Node(NTypePathParameter_PArrayExprTypePathParameter(bkopen, el, bkclose), stack);
		{
			walkToken(bkopen, Edge("bkopen", stack));
			if (el != null) walkNTypePathParameter_PArrayExprTypePathParameter_el(el, Edge("el", stack));
			walkToken(bkclose, Edge("bkclose", stack));
		};
	}
	function walkClassDecl_relations(elems:Array<NClassRelation>, stack:WalkStack) {
		walkArray(elems, stack, walkNClassRelation);
	}
	function walkNPath(node:NPath, stack:WalkStack) {
		stack = Node(NPath(node), stack);
		{
			walkToken(node.ident, Edge("ident", stack));
			walkNPath_idents(node.idents, Edge("idents", stack));
		};
	}
	function walkNAnonymousTypeFields_PAnonymousClassFields_fields(elems:Array<NClassField>, stack:WalkStack) {
		walkArray(elems, stack, walkNClassField);
	}
	function walkNTypePathParameter_PArrayExprTypePathParameter_el(elems:CommaSeparatedAllowTrailing<NExpr>, stack:WalkStack) {
		walkCommaSeparatedTrailing(elems, stack, walkNExpr);
	}
	function walkNClassField(node:NClassField, stack:WalkStack) switch node {
		case PPropertyField(annotations, modifiers, _var, name, popen, get, comma, set, pclose, typeHint, assignment):walkNClassField_PPropertyField(annotations, modifiers, _var, name, popen, get, comma, set, pclose, typeHint, assignment, stack);
		case PVariableField(annotations, modifiers, _var, name, typeHint, assignment, semicolon):walkNClassField_PVariableField(annotations, modifiers, _var, name, typeHint, assignment, semicolon, stack);
		case PFunctionField(annotations, modifiers, _function, name, params, popen, args, pclose, typeHint, e):walkNClassField_PFunctionField(annotations, modifiers, _function, name, params, popen, args, pclose, typeHint, e, stack);
	};
	function walkNModifier_PModifierOverride(token:Token, stack:WalkStack) {
		stack = Node(NModifier_PModifierOverride(token), stack);
		{
			walkToken(token, Edge("token", stack));
		};
	}
	function walkNClassRelation(node:NClassRelation, stack:WalkStack) switch node {
		case PExtends(_extends, path):walkNClassRelation_PExtends(_extends, path, stack);
		case PImplements(_implements, path):walkNClassRelation_PImplements(_implements, path, stack);
	};
	function walkNExpr_PContinue(_continue:Token, stack:WalkStack) {
		stack = Node(NExpr_PContinue(_continue), stack);
		{
			walkToken(_continue, Edge("_continue", stack));
		};
	}
	function walkNStructuralExtension(node:NStructuralExtension, stack:WalkStack) {
		stack = Node(NStructuralExtension(node), stack);
		{
			walkToken(node.gt, Edge("gt", stack));
			walkNTypePath(node.path, Edge("path", stack));
			walkToken(node.comma, Edge("comma", stack));
		};
	}
	function walkNVarDeclaration(node:NVarDeclaration, stack:WalkStack) {
		stack = Node(NVarDeclaration(node), stack);
		{
			walkToken(node.name, Edge("name", stack));
			if (node.type != null) walkNTypeHint(node.type, Edge("type", stack));
			if (node.assignment != null) walkNAssignment(node.assignment, Edge("assignment", stack));
		};
	}
	function walkNClassField_PFunctionField(annotations:NAnnotations, modifiers:Array<NModifier>, _function:Token, name:Token, params:Null<NTypeDeclParameters>, popen:Token, args:Null<CommaSeparated<NFunctionArgument>>, pclose:Token, typeHint:Null<NTypeHint>, e:Null<NFieldExpr>, stack:WalkStack) {
		stack = Node(NClassField_PFunctionField(annotations, modifiers, _function, name, params, popen, args, pclose, typeHint, e), stack);
		{
			walkNAnnotations(annotations, Edge("annotations", stack));
			walkNClassField_PFunctionField_modifiers(modifiers, Edge("modifiers", stack));
			walkToken(_function, Edge("_function", stack));
			walkToken(name, Edge("name", stack));
			if (params != null) walkNTypeDeclParameters(params, Edge("params", stack));
			walkToken(popen, Edge("popen", stack));
			if (args != null) walkNClassField_PFunctionField_args(args, Edge("args", stack));
			walkToken(pclose, Edge("pclose", stack));
			if (typeHint != null) walkNTypeHint(typeHint, Edge("typeHint", stack));
			if (e != null) walkNFieldExpr(e, Edge("e", stack));
		};
	}
	function walkNModifier_PModifierStatic(token:Token, stack:WalkStack) {
		stack = Node(NModifier_PModifierStatic(token), stack);
		{
			walkToken(token, Edge("token", stack));
		};
	}
	function walkDecl_EnumDecl_flags(elems:Array<NCommonFlag>, stack:WalkStack) {
		walkArray(elems, stack, walkNCommonFlag);
	}
	function walkNObjectField(node:NObjectField, stack:WalkStack) {
		stack = Node(NObjectField(node), stack);
		{
			walkNObjectFieldName(node.name, Edge("name", stack));
			walkToken(node.colon, Edge("colon", stack));
			walkNExpr(node.e, Edge("e", stack));
		};
	}
	function walkNLiteral_PLiteralString(s:NString, stack:WalkStack) {
		stack = Node(NLiteral_PLiteralString(s), stack);
		{
			walkNString(s, Edge("s", stack));
		};
	}
	function walkNExpr_PBinop(e1:NExpr, op:Token, e2:NExpr, stack:WalkStack) {
		stack = Node(NExpr_PBinop(e1, op, e2), stack);
		{
			walkNExpr(e1, Edge("e1", stack));
			walkToken(op, Edge("op", stack));
			walkNExpr(e2, Edge("e2", stack));
		};
	}
	function walkNBlockElement_PExpr(e:NExpr, semicolon:Token, stack:WalkStack) {
		stack = Node(NBlockElement_PExpr(e, semicolon), stack);
		{
			walkNExpr(e, Edge("e", stack));
			walkToken(semicolon, Edge("semicolon", stack));
		};
	}
	function walkNAnnotations_meta(elems:Array<NMetadata>, stack:WalkStack) {
		walkArray(elems, stack, walkNMetadata);
	}
	function walkNComplexType_PFunctionType(type1:NComplexType, arrow:Token, type2:NComplexType, stack:WalkStack) {
		stack = Node(NComplexType_PFunctionType(type1, arrow, type2), stack);
		{
			walkNComplexType(type1, Edge("type1", stack));
			walkToken(arrow, Edge("arrow", stack));
			walkNComplexType(type2, Edge("type2", stack));
		};
	}
	function walkNMetadata_PMetadata(name:Token, stack:WalkStack) {
		stack = Node(NMetadata_PMetadata(name), stack);
		{
			walkToken(name, Edge("name", stack));
		};
	}
	function walkNLiteral(node:NLiteral, stack:WalkStack) switch node {
		case PLiteralString(s):walkNLiteral_PLiteralString(s, stack);
		case PLiteralFloat(token):walkNLiteral_PLiteralFloat(token, stack);
		case PLiteralRegex(token):walkNLiteral_PLiteralRegex(token, stack);
		case PLiteralInt(token):walkNLiteral_PLiteralInt(token, stack);
	};
	function walkNExpr_PFunction(_function:Token, f:NFunction, stack:WalkStack) {
		stack = Node(NExpr_PFunction(_function, f), stack);
		{
			walkToken(_function, Edge("_function", stack));
			walkNFunction(f, Edge("f", stack));
		};
	}
	function walkNCase_PCase_patterns(elems:CommaSeparated<NExpr>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNExpr);
	}
	function walkNLiteral_PLiteralRegex(token:Token, stack:WalkStack) {
		stack = Node(NLiteral_PLiteralRegex(token), stack);
		{
			walkToken(token, Edge("token", stack));
		};
	}
	function walkNExpr_PNew(_new:Token, path:NTypePath, el:NCallArgs, stack:WalkStack) {
		stack = Node(NExpr_PNew(_new, path, el), stack);
		{
			walkToken(_new, Edge("_new", stack));
			walkNTypePath(path, Edge("path", stack));
			walkNCallArgs(el, Edge("el", stack));
		};
	}
	function walkNExpr_PThrow(_throw:Token, e:NExpr, stack:WalkStack) {
		stack = Node(NExpr_PThrow(_throw, e), stack);
		{
			walkToken(_throw, Edge("_throw", stack));
			walkNExpr(e, Edge("e", stack));
		};
	}
	function walkDecl_EnumDecl_fields(elems:Array<NEnumField>, stack:WalkStack) {
		walkArray(elems, stack, walkNEnumField);
	}
	function walkNConst(node:NConst, stack:WalkStack) switch node {
		case PConstLiteral(literal):walkNConst_PConstLiteral(literal, stack);
		case PConstIdent(ident):walkNConst_PConstIdent(ident, stack);
	};
	function walkNCommonFlag_PExtern(token:Token, stack:WalkStack) {
		stack = Node(NCommonFlag_PExtern(token), stack);
		{
			walkToken(token, Edge("token", stack));
		};
	}
	function walkDecl_UsingDecl(usingKeyword:Token, path:NPath, semicolon:Token, stack:WalkStack) {
		stack = Node(Decl_UsingDecl(usingKeyword, path, semicolon), stack);
		{
			walkToken(usingKeyword, Edge("usingKeyword", stack));
			walkNPath(path, Edge("path", stack));
			walkToken(semicolon, Edge("semicolon", stack));
		};
	}
	function walkDecl_AbstractDecl_fields(elems:Array<NClassField>, stack:WalkStack) {
		walkArray(elems, stack, walkNClassField);
	}
	function walkNTypePathParameters(node:NTypePathParameters, stack:WalkStack) {
		stack = Node(NTypePathParameters(node), stack);
		{
			walkToken(node.lt, Edge("lt", stack));
			walkNTypePathParameters_parameters(node.parameters, Edge("parameters", stack));
			walkToken(node.gt, Edge("gt", stack));
		};
	}
	function walkNClassField_PVariableField_modifiers(elems:Array<NModifier>, stack:WalkStack) {
		walkArray(elems, stack, walkNModifier);
	}
	function walkClassDecl_fields(elems:Array<NClassField>, stack:WalkStack) {
		walkArray(elems, stack, walkNClassField);
	}
	function walkNExpr_PTry(_try:Token, e:NExpr, catches:Array<NCatch>, stack:WalkStack) {
		stack = Node(NExpr_PTry(_try, e, catches), stack);
		{
			walkToken(_try, Edge("_try", stack));
			walkNExpr(e, Edge("e", stack));
			walkNExpr_PTry_catches(catches, Edge("catches", stack));
		};
	}
	function walkNExpr_PCall(e:NExpr, el:NCallArgs, stack:WalkStack) {
		stack = Node(NExpr_PCall(e, el), stack);
		{
			walkNExpr(e, Edge("e", stack));
			walkNCallArgs(el, Edge("el", stack));
		};
	}
	function walkNFunctionArgument(node:NFunctionArgument, stack:WalkStack) {
		stack = Node(NFunctionArgument(node), stack);
		{
			walkNAnnotations(node.annotations, Edge("annotations", stack));
			if (node.questionmark != null) walkToken(node.questionmark, Edge("questionmark", stack));
			walkToken(node.name, Edge("name", stack));
			if (node.typeHint != null) walkNTypeHint(node.typeHint, Edge("typeHint", stack));
			if (node.assignment != null) walkNAssignment(node.assignment, Edge("assignment", stack));
		};
	}
	function walkNExpr_PTernary(e1:NExpr, questionmark:Token, e2:NExpr, colon:Token, e3:NExpr, stack:WalkStack) {
		stack = Node(NExpr_PTernary(e1, questionmark, e2, colon, e3), stack);
		{
			walkNExpr(e1, Edge("e1", stack));
			walkToken(questionmark, Edge("questionmark", stack));
			walkNExpr(e2, Edge("e2", stack));
			walkToken(colon, Edge("colon", stack));
			walkNExpr(e3, Edge("e3", stack));
		};
	}
	function walkNTypeDeclParameters(node:NTypeDeclParameters, stack:WalkStack) {
		stack = Node(NTypeDeclParameters(node), stack);
		{
			walkToken(node.lt, Edge("lt", stack));
			walkNTypeDeclParameters_params(node.params, Edge("params", stack));
			walkToken(node.gt, Edge("gt", stack));
		};
	}
	function walkNConst_PConstIdent(ident:Token, stack:WalkStack) {
		stack = Node(NConst_PConstIdent(ident), stack);
		{
			walkToken(ident, Edge("ident", stack));
		};
	}
	function walkNExpr_PUnaryPrefix(op:Token, e:NExpr, stack:WalkStack) {
		stack = Node(NExpr_PUnaryPrefix(op, e), stack);
		{
			walkToken(op, Edge("op", stack));
			walkNExpr(e, Edge("e", stack));
		};
	}
	function walkNExpr_PUntyped(_untyped:Token, e:NExpr, stack:WalkStack) {
		stack = Node(NExpr_PUntyped(_untyped, e), stack);
		{
			walkToken(_untyped, Edge("_untyped", stack));
			walkNExpr(e, Edge("e", stack));
		};
	}
	function walkNConstraints(node:NConstraints, stack:WalkStack) switch node {
		case PMultipleConstraints(colon, popen, types, pclose):walkNConstraints_PMultipleConstraints(colon, popen, types, pclose, stack);
		case PSingleConstraint(colon, type):walkNConstraints_PSingleConstraint(colon, type, stack);
		case PNoConstraints:{ };
	};
	function walkNCase(node:NCase, stack:WalkStack) switch node {
		case PCase(_case, patterns, guard, colon, el):walkNCase_PCase(_case, patterns, guard, colon, el, stack);
		case PDefault(_default, colon, el):walkNCase_PDefault(_default, colon, el, stack);
	};
	function walkNConstraints_PSingleConstraint(colon:Token, type:NComplexType, stack:WalkStack) {
		stack = Node(NConstraints_PSingleConstraint(colon, type), stack);
		{
			walkToken(colon, Edge("colon", stack));
			walkNComplexType(type, Edge("type", stack));
		};
	}
	function walkNComplexType_PTypePath(path:NTypePath, stack:WalkStack) {
		stack = Node(NComplexType_PTypePath(path), stack);
		{
			walkNTypePath(path, Edge("path", stack));
		};
	}
	function walkNFieldExpr_PExprFieldExpr(e:NExpr, semicolon:Token, stack:WalkStack) {
		stack = Node(NFieldExpr_PExprFieldExpr(e, semicolon), stack);
		{
			walkNExpr(e, Edge("e", stack));
			walkToken(semicolon, Edge("semicolon", stack));
		};
	}
	function walkDecl_ClassDecl_flags(elems:Array<NCommonFlag>, stack:WalkStack) {
		walkArray(elems, stack, walkNCommonFlag);
	}
	function walkNString(node:NString, stack:WalkStack) switch node {
		case PString(s):walkNString_PString(s, stack);
		case PString2(s):walkNString_PString2(s, stack);
	};
	function walkNAbstractRelation_PFrom(_from:Token, type:NComplexType, stack:WalkStack) {
		stack = Node(NAbstractRelation_PFrom(_from, type), stack);
		{
			walkToken(_from, Edge("_from", stack));
			walkNComplexType(type, Edge("type", stack));
		};
	}
	function walkNAnnotations(node:NAnnotations, stack:WalkStack) {
		stack = Node(NAnnotations(node), stack);
		{
			if (node.doc != null) walkToken(node.doc, Edge("doc", stack));
			walkNAnnotations_meta(node.meta, Edge("meta", stack));
		};
	}
	function walkNLiteral_PLiteralFloat(token:Token, stack:WalkStack) {
		stack = Node(NLiteral_PLiteralFloat(token), stack);
		{
			walkToken(token, Edge("token", stack));
		};
	}
	function walkNExpr_PIf(_if:Token, popen:Token, e1:NExpr, pclose:Token, e2:NExpr, elseExpr:Null<NExprElse>, stack:WalkStack) {
		stack = Node(NExpr_PIf(_if, popen, e1, pclose, e2, elseExpr), stack);
		{
			walkToken(_if, Edge("_if", stack));
			walkToken(popen, Edge("popen", stack));
			walkNExpr(e1, Edge("e1", stack));
			walkToken(pclose, Edge("pclose", stack));
			walkNExpr(e2, Edge("e2", stack));
			if (elseExpr != null) walkNExprElse(elseExpr, Edge("elseExpr", stack));
		};
	}
	function walkNDotIdent(node:NDotIdent, stack:WalkStack) switch node {
		case PDotIdent(name):walkNDotIdent_PDotIdent(name, stack);
		case PDot(_dot):walkNDotIdent_PDot(_dot, stack);
	};
	function walkNExpr_PCheckType(popen:Token, e:NExpr, colon:Token, type:NComplexType, pclose:Token, stack:WalkStack) {
		stack = Node(NExpr_PCheckType(popen, e, colon, type, pclose), stack);
		{
			walkToken(popen, Edge("popen", stack));
			walkNExpr(e, Edge("e", stack));
			walkToken(colon, Edge("colon", stack));
			walkNComplexType(type, Edge("type", stack));
			walkToken(pclose, Edge("pclose", stack));
		};
	}
	function walkNExpr_PUnaryPostfix(e:NExpr, op:Token, stack:WalkStack) {
		stack = Node(NExpr_PUnaryPostfix(e, op), stack);
		{
			walkNExpr(e, Edge("e", stack));
			walkToken(op, Edge("op", stack));
		};
	}
	function walkNFieldExpr_PNoFieldExpr(semicolon:Token, stack:WalkStack) {
		stack = Node(NFieldExpr_PNoFieldExpr(semicolon), stack);
		{
			walkToken(semicolon, Edge("semicolon", stack));
		};
	}
	function walkNTypePathParameter_PTypeTypePathParameter(type:NComplexType, stack:WalkStack) {
		stack = Node(NTypePathParameter_PTypeTypePathParameter(type), stack);
		{
			walkNComplexType(type, Edge("type", stack));
		};
	}
	function walkDecl_TypedefDecl(annotations:NAnnotations, flags:Array<NCommonFlag>, typedefKeyword:Token, name:Token, params:Null<NTypeDeclParameters>, assign:Token, type:NComplexType, semicolon:Null<Token>, stack:WalkStack) {
		stack = Node(Decl_TypedefDecl(annotations, flags, typedefKeyword, name, params, assign, type, semicolon), stack);
		{
			walkNAnnotations(annotations, Edge("annotations", stack));
			walkDecl_TypedefDecl_flags(flags, Edge("flags", stack));
			walkToken(typedefKeyword, Edge("typedefKeyword", stack));
			walkToken(name, Edge("name", stack));
			if (params != null) walkNTypeDeclParameters(params, Edge("params", stack));
			walkToken(assign, Edge("assign", stack));
			walkNComplexType(type, Edge("type", stack));
			if (semicolon != null) walkToken(semicolon, Edge("semicolon", stack));
		};
	}
	function walkNTypePathParameters_parameters(elems:CommaSeparated<NTypePathParameter>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNTypePathParameter);
	}
	function walkNExpr_PMacro(_macro:Token, e:NMacroExpr, stack:WalkStack) {
		stack = Node(NExpr_PMacro(_macro, e), stack);
		{
			walkToken(_macro, Edge("_macro", stack));
			walkNMacroExpr(e, Edge("e", stack));
		};
	}
	function walkDecl_TypedefDecl_flags(elems:Array<NCommonFlag>, stack:WalkStack) {
		walkArray(elems, stack, walkNCommonFlag);
	}
	function walkImportMode_IIn(inKeyword:Token, ident:Token, stack:WalkStack) {
		stack = Node(ImportMode_IIn(inKeyword, ident), stack);
		{
			walkToken(inKeyword, Edge("inKeyword", stack));
			walkToken(ident, Edge("ident", stack));
		};
	}
	function walkNModifier_PModifierPublic(token:Token, stack:WalkStack) {
		stack = Node(NModifier_PModifierPublic(token), stack);
		{
			walkToken(token, Edge("token", stack));
		};
	}
	function walkNExpr_PBlock_elems(elems:Array<NBlockElement>, stack:WalkStack) {
		walkArray(elems, stack, walkNBlockElement);
	}
	function walkNFunction_args(elems:CommaSeparated<NFunctionArgument>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNFunctionArgument);
	}
	function walkNModifier_PModifierMacro(token:Token, stack:WalkStack) {
		stack = Node(NModifier_PModifierMacro(token), stack);
		{
			walkToken(token, Edge("token", stack));
		};
	}
	function walkNConstraints_PMultipleConstraints_types(elems:CommaSeparated<NComplexType>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNComplexType);
	}
	function walkNLiteral_PLiteralInt(token:Token, stack:WalkStack) {
		stack = Node(NLiteral_PLiteralInt(token), stack);
		{
			walkToken(token, Edge("token", stack));
		};
	}
	function walkNBlockElement_PInlineFunction(_inline:Token, _function:Token, f:NFunction, semicolon:Token, stack:WalkStack) {
		stack = Node(NBlockElement_PInlineFunction(_inline, _function, f, semicolon), stack);
		{
			walkToken(_inline, Edge("_inline", stack));
			walkToken(_function, Edge("_function", stack));
			walkNFunction(f, Edge("f", stack));
			walkToken(semicolon, Edge("semicolon", stack));
		};
	}
	function walkNCase_PCase_el(elems:Array<NBlockElement>, stack:WalkStack) {
		walkArray(elems, stack, walkNBlockElement);
	}
	function walkNExpr_PIn(e1:NExpr, _in:Token, e2:NExpr, stack:WalkStack) {
		stack = Node(NExpr_PIn(e1, _in, e2), stack);
		{
			walkNExpr(e1, Edge("e1", stack));
			walkToken(_in, Edge("_in", stack));
			walkNExpr(e2, Edge("e2", stack));
		};
	}
	function walkNClassField_PPropertyField(annotations:NAnnotations, modifiers:Array<NModifier>, _var:Token, name:Token, popen:Token, get:Token, comma:Token, set:Token, pclose:Token, typeHint:Null<NTypeHint>, assignment:Null<NAssignment>, stack:WalkStack) {
		stack = Node(NClassField_PPropertyField(annotations, modifiers, _var, name, popen, get, comma, set, pclose, typeHint, assignment), stack);
		{
			walkNAnnotations(annotations, Edge("annotations", stack));
			walkNClassField_PPropertyField_modifiers(modifiers, Edge("modifiers", stack));
			walkToken(_var, Edge("_var", stack));
			walkToken(name, Edge("name", stack));
			walkToken(popen, Edge("popen", stack));
			walkToken(get, Edge("get", stack));
			walkToken(comma, Edge("comma", stack));
			walkToken(set, Edge("set", stack));
			walkToken(pclose, Edge("pclose", stack));
			if (typeHint != null) walkNTypeHint(typeHint, Edge("typeHint", stack));
			if (assignment != null) walkNAssignment(assignment, Edge("assignment", stack));
		};
	}
	function walkNAnonymousTypeFields_PAnonymousClassFields(fields:Array<NClassField>, stack:WalkStack) {
		stack = Node(NAnonymousTypeFields_PAnonymousClassFields(fields), stack);
		{
			walkNAnonymousTypeFields_PAnonymousClassFields_fields(fields, Edge("fields", stack));
		};
	}
	function walkNAnonymousTypeField(node:NAnonymousTypeField, stack:WalkStack) {
		stack = Node(NAnonymousTypeField(node), stack);
		{
			if (node.questionmark != null) walkToken(node.questionmark, Edge("questionmark", stack));
			walkToken(node.name, Edge("name", stack));
			walkNTypeHint(node.typeHint, Edge("typeHint", stack));
		};
	}
	function walkNUnderlyingType(node:NUnderlyingType, stack:WalkStack) {
		stack = Node(NUnderlyingType(node), stack);
		{
			walkToken(node.popen, Edge("popen", stack));
			walkNComplexType(node.type, Edge("type", stack));
			walkToken(node.pclose, Edge("pclose", stack));
		};
	}
	function walkFile_decls(elems:Array<Decl>, stack:WalkStack) {
		walkArray(elems, stack, walkDecl);
	}
	function walkDecl(node:Decl, stack:WalkStack) switch node {
		case ClassDecl(annotations, flags, classDecl):walkDecl_ClassDecl(annotations, flags, classDecl, stack);
		case TypedefDecl(annotations, flags, typedefKeyword, name, params, assign, type, semicolon):walkDecl_TypedefDecl(annotations, flags, typedefKeyword, name, params, assign, type, semicolon, stack);
		case EnumDecl(annotations, flags, enumKeyword, name, params, braceOpen, fields, braceClose):walkDecl_EnumDecl(annotations, flags, enumKeyword, name, params, braceOpen, fields, braceClose, stack);
		case UsingDecl(usingKeyword, path, semicolon):walkDecl_UsingDecl(usingKeyword, path, semicolon, stack);
		case AbstractDecl(annotations, flags, abstractKeyword, name, params, underlyingType, relations, braceOpen, fields, braceClose):walkDecl_AbstractDecl(annotations, flags, abstractKeyword, name, params, underlyingType, relations, braceOpen, fields, braceClose, stack);
		case ImportDecl(importKeyword, path, mode, semicolon):walkDecl_ImportDecl(importKeyword, path, mode, semicolon, stack);
	};
	function walkNGuard(node:NGuard, stack:WalkStack) {
		stack = Node(NGuard(node), stack);
		{
			walkToken(node._if, Edge("_if", stack));
			walkToken(node.popen, Edge("popen", stack));
			walkNExpr(node.e, Edge("e", stack));
			walkToken(node.pclose, Edge("pclose", stack));
		};
	}
	function walkNMacroExpr(node:NMacroExpr, stack:WalkStack) switch node {
		case PVar(_var, v):walkNMacroExpr_PVar(_var, v, stack);
		case PTypeHint(type):walkNMacroExpr_PTypeHint(type, stack);
		case PClass(c):walkNMacroExpr_PClass(c, stack);
		case PExpr(e):walkNMacroExpr_PExpr(e, stack);
	};
	function walkNEnumField(node:NEnumField, stack:WalkStack) {
		stack = Node(NEnumField(node), stack);
		{
			walkNAnnotations(node.annotations, Edge("annotations", stack));
			walkToken(node.name, Edge("name", stack));
			if (node.params != null) walkNTypeDeclParameters(node.params, Edge("params", stack));
			if (node.args != null) walkNEnumFieldArgs(node.args, Edge("args", stack));
			if (node.type != null) walkNTypeHint(node.type, Edge("type", stack));
			walkToken(node.semicolon, Edge("semicolon", stack));
		};
	}
	function walkNBlockElement(node:NBlockElement, stack:WalkStack) switch node {
		case PVar(_var, vl, semicolon):walkNBlockElement_PVar(_var, vl, semicolon, stack);
		case PExpr(e, semicolon):walkNBlockElement_PExpr(e, semicolon, stack);
		case PInlineFunction(_inline, _function, f, semicolon):walkNBlockElement_PInlineFunction(_inline, _function, f, semicolon, stack);
	};
	function walkNExpr_PSwitch(_switch:Token, e:NExpr, braceOpen:Token, cases:Array<NCase>, braceClose:Token, stack:WalkStack) {
		stack = Node(NExpr_PSwitch(_switch, e, braceOpen, cases, braceClose), stack);
		{
			walkToken(_switch, Edge("_switch", stack));
			walkNExpr(e, Edge("e", stack));
			walkToken(braceOpen, Edge("braceOpen", stack));
			walkNExpr_PSwitch_cases(cases, Edge("cases", stack));
			walkToken(braceClose, Edge("braceClose", stack));
		};
	}
	function walkNExpr_PField(e:NExpr, ident:NDotIdent, stack:WalkStack) {
		stack = Node(NExpr_PField(e, ident), stack);
		{
			walkNExpr(e, Edge("e", stack));
			walkNDotIdent(ident, Edge("ident", stack));
		};
	}
	function walkNExpr_PFor(_for:Token, popen:Token, e1:NExpr, pclose:Token, e2:NExpr, stack:WalkStack) {
		stack = Node(NExpr_PFor(_for, popen, e1, pclose, e2), stack);
		{
			walkToken(_for, Edge("_for", stack));
			walkToken(popen, Edge("popen", stack));
			walkNExpr(e1, Edge("e1", stack));
			walkToken(pclose, Edge("pclose", stack));
			walkNExpr(e2, Edge("e2", stack));
		};
	}
	function walkDecl_EnumDecl(annotations:NAnnotations, flags:Array<NCommonFlag>, enumKeyword:Token, name:Token, params:Null<NTypeDeclParameters>, braceOpen:Token, fields:Array<NEnumField>, braceClose:Token, stack:WalkStack) {
		stack = Node(Decl_EnumDecl(annotations, flags, enumKeyword, name, params, braceOpen, fields, braceClose), stack);
		{
			walkNAnnotations(annotations, Edge("annotations", stack));
			walkDecl_EnumDecl_flags(flags, Edge("flags", stack));
			walkToken(enumKeyword, Edge("enumKeyword", stack));
			walkToken(name, Edge("name", stack));
			if (params != null) walkNTypeDeclParameters(params, Edge("params", stack));
			walkToken(braceOpen, Edge("braceOpen", stack));
			walkDecl_EnumDecl_fields(fields, Edge("fields", stack));
			walkToken(braceClose, Edge("braceClose", stack));
		};
	}
	function walkNEnumFieldArg(node:NEnumFieldArg, stack:WalkStack) {
		stack = Node(NEnumFieldArg(node), stack);
		{
			if (node.questionmark != null) walkToken(node.questionmark, Edge("questionmark", stack));
			walkToken(node.name, Edge("name", stack));
			walkNTypeHint(node.typeHint, Edge("typeHint", stack));
		};
	}
	function walkNMetadata(node:NMetadata, stack:WalkStack) switch node {
		case PMetadata(name):walkNMetadata_PMetadata(name, stack);
		case PMetadataWithArgs(name, el, pclose):walkNMetadata_PMetadataWithArgs(name, el, pclose, stack);
	};
	function walkNClassRelation_PImplements(_implements:Token, path:NTypePath, stack:WalkStack) {
		stack = Node(NClassRelation_PImplements(_implements, path), stack);
		{
			walkToken(_implements, Edge("_implements", stack));
			walkNTypePath(path, Edge("path", stack));
		};
	}
	function walkNTypePath(node:NTypePath, stack:WalkStack) {
		stack = Node(NTypePath(node), stack);
		{
			walkNPath(node.path, Edge("path", stack));
			if (node.params != null) walkNTypePathParameters(node.params, Edge("params", stack));
		};
	}
	function walkNExpr_PIs(popen:Token, e:NExpr, _is:Token, path:NTypePath, pclose:Token, stack:WalkStack) {
		stack = Node(NExpr_PIs(popen, e, _is, path, pclose), stack);
		{
			walkToken(popen, Edge("popen", stack));
			walkNExpr(e, Edge("e", stack));
			walkToken(_is, Edge("_is", stack));
			walkNTypePath(path, Edge("path", stack));
			walkToken(pclose, Edge("pclose", stack));
		};
	}
	function walkNExpr_PWhile(_while:Token, popen:Token, e1:NExpr, pclose:Token, e2:NExpr, stack:WalkStack) {
		stack = Node(NExpr_PWhile(_while, popen, e1, pclose, e2), stack);
		{
			walkToken(_while, Edge("_while", stack));
			walkToken(popen, Edge("popen", stack));
			walkNExpr(e1, Edge("e1", stack));
			walkToken(pclose, Edge("pclose", stack));
			walkNExpr(e2, Edge("e2", stack));
		};
	}
	function walkNCase_PCase(_case:Token, patterns:CommaSeparated<NExpr>, guard:Null<NGuard>, colon:Token, el:Array<NBlockElement>, stack:WalkStack) {
		stack = Node(NCase_PCase(_case, patterns, guard, colon, el), stack);
		{
			walkToken(_case, Edge("_case", stack));
			walkNCase_PCase_patterns(patterns, Edge("patterns", stack));
			if (guard != null) walkNGuard(guard, Edge("guard", stack));
			walkToken(colon, Edge("colon", stack));
			walkNCase_PCase_el(el, Edge("el", stack));
		};
	}
	function walkNObjectFieldName_PIdent(ident:Token, stack:WalkStack) {
		stack = Node(NObjectFieldName_PIdent(ident), stack);
		{
			walkToken(ident, Edge("ident", stack));
		};
	}
	function walkNExpr_PReturnExpr(_return:Token, e:NExpr, stack:WalkStack) {
		stack = Node(NExpr_PReturnExpr(_return, e), stack);
		{
			walkToken(_return, Edge("_return", stack));
			walkNExpr(e, Edge("e", stack));
		};
	}
	function walkNExpr_PTry_catches(elems:Array<NCatch>, stack:WalkStack) {
		walkArray(elems, stack, walkNCatch);
	}
	function walkNMacroExpr_PVar(_var:Token, v:CommaSeparated<NVarDeclaration>, stack:WalkStack) {
		stack = Node(NMacroExpr_PVar(_var, v), stack);
		{
			walkToken(_var, Edge("_var", stack));
			walkNMacroExpr_PVar_v(v, Edge("v", stack));
		};
	}
	function walkNAnonymousTypeFields(node:NAnonymousTypeFields, stack:WalkStack) switch node {
		case PAnonymousClassFields(fields):walkNAnonymousTypeFields_PAnonymousClassFields(fields, stack);
		case PAnonymousShortFields(fields):walkNAnonymousTypeFields_PAnonymousShortFields(fields, stack);
	};
	function walkNAnonymousTypeFields_PAnonymousShortFields_fields(elems:CommaSeparatedAllowTrailing<NAnonymousTypeField>, stack:WalkStack) {
		walkCommaSeparatedTrailing(elems, stack, walkNAnonymousTypeField);
	}
	function walkNCommonFlag_PPrivate(token:Token, stack:WalkStack) {
		stack = Node(NCommonFlag_PPrivate(token), stack);
		{
			walkToken(token, Edge("token", stack));
		};
	}
	function walkNString_PString(s:Token, stack:WalkStack) {
		stack = Node(NString_PString(s), stack);
		{
			walkToken(s, Edge("s", stack));
		};
	}
	function walkNClassField_PFunctionField_args(elems:CommaSeparated<NFunctionArgument>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNFunctionArgument);
	}
	function walkNFunction(node:NFunction, stack:WalkStack) {
		stack = Node(NFunction(node), stack);
		{
			if (node.ident != null) walkToken(node.ident, Edge("ident", stack));
			if (node.params != null) walkNTypeDeclParameters(node.params, Edge("params", stack));
			walkToken(node.popen, Edge("popen", stack));
			if (node.args != null) walkNFunction_args(node.args, Edge("args", stack));
			walkToken(node.pclose, Edge("pclose", stack));
			if (node.type != null) walkNTypeHint(node.type, Edge("type", stack));
			walkNExpr(node.e, Edge("e", stack));
		};
	}
	function walkImportMode_IAll(dotstar:Token, stack:WalkStack) {
		stack = Node(ImportMode_IAll(dotstar), stack);
		{
			walkToken(dotstar, Edge("dotstar", stack));
		};
	}
	function walkNExpr_PMacroEscape(ident:Token, braceOpen:Token, e:NExpr, braceClose:Token, stack:WalkStack) {
		stack = Node(NExpr_PMacroEscape(ident, braceOpen, e, braceClose), stack);
		{
			walkToken(ident, Edge("ident", stack));
			walkToken(braceOpen, Edge("braceOpen", stack));
			walkNExpr(e, Edge("e", stack));
			walkToken(braceClose, Edge("braceClose", stack));
		};
	}
	function walkNExpr_PReturn(_return:Token, stack:WalkStack) {
		stack = Node(NExpr_PReturn(_return), stack);
		{
			walkToken(_return, Edge("_return", stack));
		};
	}
	function walkNExpr_PDollarIdent(ident:Token, stack:WalkStack) {
		stack = Node(NExpr_PDollarIdent(ident), stack);
		{
			walkToken(ident, Edge("ident", stack));
		};
	}
	function walkNComplexType_PStructuralExtension(braceOpen:Token, types:Array<NStructuralExtension>, fields:NAnonymousTypeFields, braceClose:Token, stack:WalkStack) {
		stack = Node(NComplexType_PStructuralExtension(braceOpen, types, fields, braceClose), stack);
		{
			walkToken(braceOpen, Edge("braceOpen", stack));
			walkNComplexType_PStructuralExtension_types(types, Edge("types", stack));
			walkNAnonymousTypeFields(fields, Edge("fields", stack));
			walkToken(braceClose, Edge("braceClose", stack));
		};
	}
	function walkNExprElse(node:NExprElse, stack:WalkStack) {
		stack = Node(NExprElse(node), stack);
		{
			walkToken(node._else, Edge("_else", stack));
			walkNExpr(node.e, Edge("e", stack));
		};
	}
}