// This file is autogenerated from ParseTree data structures
// Use build-walker.hxml to re-generate!

package hxParser;

import hxParser.ParseTree;

class StackAwareWalker {
	function walkToken(token:Token, stack:WalkStack) { }
	function walkArray<T>(elems:Array<T>, stack:WalkStack, walk:T -> WalkStack -> Void) {
		for (i in 0 ... elems.length) walk(elems[i], Element(i, stack));
	}
	function walkCommaSeparated<T>(elems:NCommaSeparated<T>, stack:WalkStack, walk:T -> WalkStack -> Void) {
		walk(elems.arg, Element(0, stack));
		var i = 1;
		for (el in elems.args) {
			walkToken(el.comma, Item("comma", stack));
			walk(el.arg, Element(i, stack));
			i++;
		};
	}
	function walkCommaSeparatedTrailing<T>(elems:NCommaSeparatedAllowTrailing<T>, stack:WalkStack, walk:T -> WalkStack -> Void) {
		walk(elems.arg, Element(0, stack));
		var i = 1;
		for (el in elems.args) {
			walkToken(el.comma, Item("comma", stack));
			walk(el.arg, Element(i, stack));
			i++;
		};
		if (elems.comma != null) walkToken(elems.comma, Item("commaTrailing", stack));
	}
	function walkNPackage(node:NPackage, stack:WalkStack) {
		walkToken(node._package, Item("_package", stack));
		if (node.path != null) walkNPath(node.path, Item("path", stack));
		walkToken(node.semicolon, Item("semicolon", stack));
	}
	function walkNBlockElement_PVar_vl(elems:NCommaSeparated<NVarDeclaration>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNVarDeclaration);
	}
	function walkNObjectFieldName_PString(string:NString, stack:WalkStack) {
		stack = Item("PString", stack);
		{
			walkNString(string, Item("string", stack));
		};
	}
	function walkNDecl_PClassDecl(annotations:NAnnotations, flags:Array<NCommonFlag>, c:NClassDecl, stack:WalkStack) {
		stack = Item("PClassDecl", stack);
		{
			walkNAnnotations(annotations, Item("annotations", stack));
			walkNDecl_PClassDecl_flags(flags, Item("flags", stack));
			walkNClassDecl(c, Item("c", stack));
		};
	}
	function walkNExpr_PArrayDecl_el(elems:NCommaSeparatedAllowTrailing<NExpr>, stack:WalkStack) {
		walkCommaSeparatedTrailing(elems, stack, walkNExpr);
	}
	function walkNObjectFieldName(node:NObjectFieldName, stack:WalkStack) switch node {
		case PString(string):walkNObjectFieldName_PString(string, stack);
		case PIdent(ident):walkNObjectFieldName_PIdent(ident, stack);
	};
	function walkNDecl_PImportDecl(_import:Token, importPath:NImport, semicolon:Token, stack:WalkStack) {
		stack = Item("PImportDecl", stack);
		{
			walkToken(_import, Item("_import", stack));
			walkNImport(importPath, Item("importPath", stack));
			walkToken(semicolon, Item("semicolon", stack));
		};
	}
	function walkNTypeHint(node:NTypeHint, stack:WalkStack) {
		walkToken(node.colon, Item("colon", stack));
		walkNComplexType(node.type, Item("type", stack));
	}
	function walkNString_PString2(s:Token, stack:WalkStack) {
		stack = Item("PString2", stack);
		{
			walkToken(s, Item("s", stack));
		};
	}
	function walkNExpr_PVar(_var:Token, d:NVarDeclaration, stack:WalkStack) {
		stack = Item("PVar", stack);
		{
			walkToken(_var, Item("_var", stack));
			walkNVarDeclaration(d, Item("d", stack));
		};
	}
	function walkNDotIdent_PDotIdent(name:Token, stack:WalkStack) {
		stack = Item("PDotIdent", stack);
		{
			walkToken(name, Item("name", stack));
		};
	}
	function walkNExpr_PDo(_do:Token, e1:NExpr, _while:Token, popen:Token, e2:NExpr, pclose:Token, stack:WalkStack) {
		stack = Item("PDo", stack);
		{
			walkToken(_do, Item("_do", stack));
			walkNExpr(e1, Item("e1", stack));
			walkToken(_while, Item("_while", stack));
			walkToken(popen, Item("popen", stack));
			walkNExpr(e2, Item("e2", stack));
			walkToken(pclose, Item("pclose", stack));
		};
	}
	function walkNFieldExpr_PBlockFieldExpr(e:NExpr, stack:WalkStack) {
		stack = Item("PBlockFieldExpr", stack);
		{
			walkNExpr(e, Item("e", stack));
		};
	}
	function walkNMacroExpr_PVar_v(elems:NCommaSeparated<NVarDeclaration>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNVarDeclaration);
	}
	function walkNTypePathParameter_PConstantTypePathParameter(constant:NLiteral, stack:WalkStack) {
		stack = Item("PConstantTypePathParameter", stack);
		{
			walkNLiteral(constant, Item("constant", stack));
		};
	}
	function walkNDecl_PTypedefDecl(annotations:NAnnotations, flags:Array<NCommonFlag>, _typedef:Token, name:Token, params:Null<NTypeDeclParameters>, assign:Token, type:NComplexType, semicolon:Null<Token>, stack:WalkStack) {
		stack = Item("PTypedefDecl", stack);
		{
			walkNAnnotations(annotations, Item("annotations", stack));
			walkNDecl_PTypedefDecl_flags(flags, Item("flags", stack));
			walkToken(_typedef, Item("_typedef", stack));
			walkToken(name, Item("name", stack));
			if (params != null) walkNTypeDeclParameters(params, Item("params", stack));
			walkToken(assign, Item("assign", stack));
			walkNComplexType(type, Item("type", stack));
			if (semicolon != null) walkToken(semicolon, Item("semicolon", stack));
		};
	}
	function walkNEnumFieldArgs(node:NEnumFieldArgs, stack:WalkStack) {
		walkToken(node.popen, Item("popen", stack));
		if (node.args != null) walkNEnumFieldArgs_args(node.args, Item("args", stack));
		walkToken(node.pclose, Item("pclose", stack));
	}
	function walkNPath_idents(elems:Array<NDotIdent>, stack:WalkStack) {
		walkArray(elems, stack, walkNDotIdent);
	}
	function walkNMacroExpr_PClass(c:NClassDecl, stack:WalkStack) {
		stack = Item("PClass", stack);
		{
			walkNClassDecl(c, Item("c", stack));
		};
	}
	function walkNExpr_PBlock(bropen:Token, elems:Array<NBlockElement>, brclose:Token, stack:WalkStack) {
		stack = Item("PBlock", stack);
		{
			walkToken(bropen, Item("bropen", stack));
			walkNExpr_PBlock_elems(elems, Item("elems", stack));
			walkToken(brclose, Item("brclose", stack));
		};
	}
	function walkNImportMode_PInMode(_in:Token, ident:Token, stack:WalkStack) {
		stack = Item("PInMode", stack);
		{
			walkToken(_in, Item("_in", stack));
			walkToken(ident, Item("ident", stack));
		};
	}
	function walkNModifier_PModifierPrivate(token:Token, stack:WalkStack) {
		stack = Item("PModifierPrivate", stack);
		{
			walkToken(token, Item("token", stack));
		};
	}
	function walkNClassRelation_PExtends(_extends:Token, path:NTypePath, stack:WalkStack) {
		stack = Item("PExtends", stack);
		{
			walkToken(_extends, Item("_extends", stack));
			walkNTypePath(path, Item("path", stack));
		};
	}
	function walkNExpr_PUnsafeCast(_cast:Token, e:NExpr, stack:WalkStack) {
		stack = Item("PUnsafeCast", stack);
		{
			walkToken(_cast, Item("_cast", stack));
			walkNExpr(e, Item("e", stack));
		};
	}
	function walkNTypePathParameter(node:NTypePathParameter, stack:WalkStack) switch node {
		case PArrayExprTypePathParameter(bkopen, el, bkclose):walkNTypePathParameter_PArrayExprTypePathParameter(bkopen, el, bkclose, stack);
		case PConstantTypePathParameter(constant):walkNTypePathParameter_PConstantTypePathParameter(constant, stack);
		case PTypeTypePathParameter(type):walkNTypePathParameter_PTypeTypePathParameter(type, stack);
	};
	function walkNFile_decls(elems:Array<NDecl>, stack:WalkStack) {
		walkArray(elems, stack, walkNDecl);
	}
	function walkNConst_PConstLiteral(literal:NLiteral, stack:WalkStack) {
		stack = Item("PConstLiteral", stack);
		{
			walkNLiteral(literal, Item("literal", stack));
		};
	}
	function walkNExpr_PMetadata(metadata:NMetadata, e:NExpr, stack:WalkStack) {
		stack = Item("PMetadata", stack);
		{
			walkNMetadata(metadata, Item("metadata", stack));
			walkNExpr(e, Item("e", stack));
		};
	}
	function walkNClassDecl_fields(elems:Array<NClassField>, stack:WalkStack) {
		walkArray(elems, stack, walkNClassField);
	}
	function walkNDotIdent_PDot(_dot:Token, stack:WalkStack) {
		stack = Item("PDot", stack);
		{
			walkToken(_dot, Item("_dot", stack));
		};
	}
	function walkNMetadata_PMetadataWithArgs_el(elems:NCommaSeparated<NExpr>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNExpr);
	}
	function walkNAnonymousTypeFields_PAnonymousShortFields(fields:Null<NCommaSeparatedAllowTrailing<NAnonymousTypeField>>, stack:WalkStack) {
		stack = Item("PAnonymousShortFields", stack);
		{
			if (fields != null) walkNAnonymousTypeFields_PAnonymousShortFields_fields(fields, Item("fields", stack));
		};
	}
	function walkNClassField_PPropertyField_modifiers(elems:Array<NModifier>, stack:WalkStack) {
		walkArray(elems, stack, walkNModifier);
	}
	function walkNExpr_PSwitch_cases(elems:Array<NCase>, stack:WalkStack) {
		walkArray(elems, stack, walkNCase);
	}
	function walkNExpr_PSafeCast(_cast:Token, popen:Token, e:NExpr, comma:Token, ct:NComplexType, pclose:Token, stack:WalkStack) {
		stack = Item("PSafeCast", stack);
		{
			walkToken(_cast, Item("_cast", stack));
			walkToken(popen, Item("popen", stack));
			walkNExpr(e, Item("e", stack));
			walkToken(comma, Item("comma", stack));
			walkNComplexType(ct, Item("ct", stack));
			walkToken(pclose, Item("pclose", stack));
		};
	}
	function walkNExpr(node:NExpr, stack:WalkStack) switch node {
		case PVar(_var, d):walkNExpr_PVar(_var, d, stack);
		case PConst(const):walkNExpr_PConst(const, stack);
		case PDo(_do, e1, _while, popen, e2, pclose):walkNExpr_PDo(_do, e1, _while, popen, e2, pclose, stack);
		case PMacro(_macro, e):walkNExpr_PMacro(_macro, e, stack);
		case PWhile(_while, popen, e1, pclose, e2):walkNExpr_PWhile(_while, popen, e1, pclose, e2, stack);
		case PIntDot(int, dot):walkNExpr_PIntDot(int, dot, stack);
		case PBlock(bropen, elems, brclose):walkNExpr_PBlock(bropen, elems, brclose, stack);
		case PFunction(_function, f):walkNExpr_PFunction(_function, f, stack);
		case PSwitch(_switch, e, bropen, cases, brclose):walkNExpr_PSwitch(_switch, e, bropen, cases, brclose, stack);
		case PReturn(_return):walkNExpr_PReturn(_return, stack);
		case PArrayDecl(bkopen, el, bkclose):walkNExpr_PArrayDecl(bkopen, el, bkclose, stack);
		case PDollarIdent(ident):walkNExpr_PDollarIdent(ident, stack);
		case PIf(_if, popen, e1, pclose, e2, elseExpr):walkNExpr_PIf(_if, popen, e1, pclose, e2, elseExpr, stack);
		case PReturnExpr(_return, e):walkNExpr_PReturnExpr(_return, e, stack);
		case PArray(e1, bkopen, e2, bkclose):walkNExpr_PArray(e1, bkopen, e2, bkclose, stack);
		case PContinue(_continue):walkNExpr_PContinue(_continue, stack);
		case PParenthesis(popen, e, pclose):walkNExpr_PParenthesis(popen, e, pclose, stack);
		case PTry(_try, e, catches):walkNExpr_PTry(_try, e, catches, stack);
		case PBreak(_break):walkNExpr_PBreak(_break, stack);
		case PCall(e, el):walkNExpr_PCall(e, el, stack);
		case PUnaryPostfix(e, op):walkNExpr_PUnaryPostfix(e, op, stack);
		case PBinop(e1, op, e2):walkNExpr_PBinop(e1, op, e2, stack);
		case PSafeCast(_cast, popen, e, comma, ct, pclose):walkNExpr_PSafeCast(_cast, popen, e, comma, ct, pclose, stack);
		case PUnaryPrefix(op, e):walkNExpr_PUnaryPrefix(op, e, stack);
		case PMacroEscape(ident, bropen, e, brclose):walkNExpr_PMacroEscape(ident, bropen, e, brclose, stack);
		case PIn(e1, _in, e2):walkNExpr_PIn(e1, _in, e2, stack);
		case PMetadata(metadata, e):walkNExpr_PMetadata(metadata, e, stack);
		case PUnsafeCast(_cast, e):walkNExpr_PUnsafeCast(_cast, e, stack);
		case PCheckType(popen, e, colon, type, pclose):walkNExpr_PCheckType(popen, e, colon, type, pclose, stack);
		case PUntyped(_untyped, e):walkNExpr_PUntyped(_untyped, e, stack);
		case PField(e, ident):walkNExpr_PField(e, ident, stack);
		case PIs(popen, e, _is, path, pclose):walkNExpr_PIs(popen, e, _is, path, pclose, stack);
		case PTernary(e1, questionmark, e2, colon, e3):walkNExpr_PTernary(e1, questionmark, e2, colon, e3, stack);
		case PObjectDecl(bropen, fl, brclose):walkNExpr_PObjectDecl(bropen, fl, brclose, stack);
		case PNew(_new, path, el):walkNExpr_PNew(_new, path, el, stack);
		case PThrow(_throw, e):walkNExpr_PThrow(_throw, e, stack);
		case PFor(_for, popen, e1, pclose, e2):walkNExpr_PFor(_for, popen, e1, pclose, e2, stack);
	};
	function walkNCallArgs(node:NCallArgs, stack:WalkStack) {
		walkToken(node.popen, Item("popen", stack));
		if (node.args != null) walkNCallArgs_args(node.args, Item("args", stack));
		walkToken(node.pclose, Item("pclose", stack));
	}
	function walkNEnumFieldArgs_args(elems:NCommaSeparated<NEnumFieldArg>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNEnumFieldArg);
	}
	function walkNConstraints_PMultipleConstraints(colon:Token, popen:Token, types:NCommaSeparated<NComplexType>, pclose:Token, stack:WalkStack) {
		stack = Item("PMultipleConstraints", stack);
		{
			walkToken(colon, Item("colon", stack));
			walkToken(popen, Item("popen", stack));
			walkNConstraints_PMultipleConstraints_types(types, Item("types", stack));
			walkToken(pclose, Item("pclose", stack));
		};
	}
	function walkNExpr_PObjectDecl_fl(elems:NCommaSeparatedAllowTrailing<NObjectField>, stack:WalkStack) {
		walkCommaSeparatedTrailing(elems, stack, walkNObjectField);
	}
	function walkNExpr_PConst(const:NConst, stack:WalkStack) {
		stack = Item("PConst", stack);
		{
			walkNConst(const, Item("const", stack));
		};
	}
	function walkNExpr_PParenthesis(popen:Token, e:NExpr, pclose:Token, stack:WalkStack) {
		stack = Item("PParenthesis", stack);
		{
			walkToken(popen, Item("popen", stack));
			walkNExpr(e, Item("e", stack));
			walkToken(pclose, Item("pclose", stack));
		};
	}
	function walkNComplexType(node:NComplexType, stack:WalkStack) switch node {
		case PFunctionType(type1, arrow, type2):walkNComplexType_PFunctionType(type1, arrow, type2, stack);
		case PStructuralExtension(bropen, types, fields, brclose):walkNComplexType_PStructuralExtension(bropen, types, fields, brclose, stack);
		case PParenthesisType(popen, ct, pclose):walkNComplexType_PParenthesisType(popen, ct, pclose, stack);
		case PAnonymousStructure(bropen, fields, brclose):walkNComplexType_PAnonymousStructure(bropen, fields, brclose, stack);
		case PTypePath(path):walkNComplexType_PTypePath(path, stack);
		case POptionalType(questionmark, type):walkNComplexType_POptionalType(questionmark, type, stack);
	};
	function walkNComplexType_PStructuralExtension_types(elems:Array<NStructuralExtension>, stack:WalkStack) {
		walkArray(elems, stack, walkNStructuralExtension);
	}
	function walkNMacroExpr_PExpr(e:NExpr, stack:WalkStack) {
		stack = Item("PExpr", stack);
		{
			walkNExpr(e, Item("e", stack));
		};
	}
	function walkNExpr_PBreak(_break:Token, stack:WalkStack) {
		stack = Item("PBreak", stack);
		{
			walkToken(_break, Item("_break", stack));
		};
	}
	function walkNDecl_PClassDecl_flags(elems:Array<NCommonFlag>, stack:WalkStack) {
		walkArray(elems, stack, walkNCommonFlag);
	}
	function walkNFile(node:NFile, stack:WalkStack) {
		if (node.pack != null) walkNPackage(node.pack, Item("pack", stack));
		walkNFile_decls(node.decls, Item("decls", stack));
		walkToken(node.eof, Item("eof", stack));
	}
	function walkNModifier_PModifierInline(token:Token, stack:WalkStack) {
		stack = Item("PModifierInline", stack);
		{
			walkToken(token, Item("token", stack));
		};
	}
	function walkNClassField_PVariableField(annotations:NAnnotations, modifiers:Array<NModifier>, _var:Token, name:Token, typeHint:Null<NTypeHint>, assignment:Null<NAssignment>, semicolon:Token, stack:WalkStack) {
		stack = Item("PVariableField", stack);
		{
			walkNAnnotations(annotations, Item("annotations", stack));
			walkNClassField_PVariableField_modifiers(modifiers, Item("modifiers", stack));
			walkToken(_var, Item("_var", stack));
			walkToken(name, Item("name", stack));
			if (typeHint != null) walkNTypeHint(typeHint, Item("typeHint", stack));
			if (assignment != null) walkNAssignment(assignment, Item("assignment", stack));
			walkToken(semicolon, Item("semicolon", stack));
		};
	}
	function walkNTypeDeclParameters_params(elems:NCommaSeparated<NTypeDeclParameter>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNTypeDeclParameter);
	}
	function walkNMacroExpr_PTypeHint(type:NTypeHint, stack:WalkStack) {
		stack = Item("PTypeHint", stack);
		{
			walkNTypeHint(type, Item("type", stack));
		};
	}
	function walkNImportMode(node:NImportMode, stack:WalkStack) switch node {
		case PAsMode(_as, ident):walkNImportMode_PAsMode(_as, ident, stack);
		case PNormalMode:{ };
		case PInMode(_in, ident):walkNImportMode_PInMode(_in, ident, stack);
		case PAllMode(dotstar):walkNImportMode_PAllMode(dotstar, stack);
	};
	function walkNExpr_PArrayDecl(bkopen:Token, el:Null<NCommaSeparatedAllowTrailing<NExpr>>, bkclose:Token, stack:WalkStack) {
		stack = Item("PArrayDecl", stack);
		{
			walkToken(bkopen, Item("bkopen", stack));
			if (el != null) walkNExpr_PArrayDecl_el(el, Item("el", stack));
			walkToken(bkclose, Item("bkclose", stack));
		};
	}
	function walkNDecl_PAbstractDecl_fields(elems:Array<NClassField>, stack:WalkStack) {
		walkArray(elems, stack, walkNClassField);
	}
	function walkNAssignment(node:NAssignment, stack:WalkStack) {
		walkToken(node.assign, Item("assign", stack));
		walkNExpr(node.e, Item("e", stack));
	}
	function walkNComplexType_POptionalType(questionmark:Token, type:NComplexType, stack:WalkStack) {
		stack = Item("POptionalType", stack);
		{
			walkToken(questionmark, Item("questionmark", stack));
			walkNComplexType(type, Item("type", stack));
		};
	}
	function walkNComplexType_PAnonymousStructure(bropen:Token, fields:NAnonymousTypeFields, brclose:Token, stack:WalkStack) {
		stack = Item("PAnonymousStructure", stack);
		{
			walkToken(bropen, Item("bropen", stack));
			walkNAnonymousTypeFields(fields, Item("fields", stack));
			walkToken(brclose, Item("brclose", stack));
		};
	}
	function walkNCase_PDefault_el(elems:Array<NBlockElement>, stack:WalkStack) {
		walkArray(elems, stack, walkNBlockElement);
	}
	function walkNCallArgs_args(elems:NCommaSeparated<NExpr>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNExpr);
	}
	function walkNAbstractRelation(node:NAbstractRelation, stack:WalkStack) switch node {
		case PFrom(_from, type):walkNAbstractRelation_PFrom(_from, type, stack);
		case PTo(_to, type):walkNAbstractRelation_PTo(_to, type, stack);
	};
	function walkNExpr_PObjectDecl(bropen:Token, fl:NCommaSeparatedAllowTrailing<NObjectField>, brclose:Token, stack:WalkStack) {
		stack = Item("PObjectDecl", stack);
		{
			walkToken(bropen, Item("bropen", stack));
			walkNExpr_PObjectDecl_fl(fl, Item("fl", stack));
			walkToken(brclose, Item("brclose", stack));
		};
	}
	function walkNCatch(node:NCatch, stack:WalkStack) {
		walkToken(node._catch, Item("_catch", stack));
		walkToken(node.popen, Item("popen", stack));
		walkToken(node.ident, Item("ident", stack));
		walkNTypeHint(node.type, Item("type", stack));
		walkToken(node.pclose, Item("pclose", stack));
		walkNExpr(node.e, Item("e", stack));
	}
	function walkNAbstractRelation_PTo(_to:Token, type:NComplexType, stack:WalkStack) {
		stack = Item("PTo", stack);
		{
			walkToken(_to, Item("_to", stack));
			walkNComplexType(type, Item("type", stack));
		};
	}
	function walkNTypeDeclParameter(node:NTypeDeclParameter, stack:WalkStack) {
		walkNAnnotations(node.annotations, Item("annotations", stack));
		walkToken(node.name, Item("name", stack));
		walkNConstraints(node.constraints, Item("constraints", stack));
	}
	function walkNExpr_PIntDot(int:Token, dot:Token, stack:WalkStack) {
		stack = Item("PIntDot", stack);
		{
			walkToken(int, Item("int", stack));
			walkToken(dot, Item("dot", stack));
		};
	}
	function walkNComplexType_PParenthesisType(popen:Token, ct:NComplexType, pclose:Token, stack:WalkStack) {
		stack = Item("PParenthesisType", stack);
		{
			walkToken(popen, Item("popen", stack));
			walkNComplexType(ct, Item("ct", stack));
			walkToken(pclose, Item("pclose", stack));
		};
	}
	function walkNModifier(node:NModifier, stack:WalkStack) switch node {
		case PModifierStatic(token):walkNModifier_PModifierStatic(token, stack);
		case PModifierOverride(token):walkNModifier_PModifierOverride(token, stack);
		case PModifierMacro(token):walkNModifier_PModifierMacro(token, stack);
		case PModifierDynamic(token):walkNModifier_PModifierDynamic(token, stack);
		case PModifierInline(token):walkNModifier_PModifierInline(token, stack);
		case PModifierPrivate(token):walkNModifier_PModifierPrivate(token, stack);
		case PModifierPublic(token):walkNModifier_PModifierPublic(token, stack);
	};
	function walkNFieldExpr(node:NFieldExpr, stack:WalkStack) switch node {
		case PNoFieldExpr(semicolon):walkNFieldExpr_PNoFieldExpr(semicolon, stack);
		case PBlockFieldExpr(e):walkNFieldExpr_PBlockFieldExpr(e, stack);
		case PExprFieldExpr(e, semicolon):walkNFieldExpr_PExprFieldExpr(e, semicolon, stack);
	};
	function walkNCase_PDefault(_default:Token, colon:Token, el:Array<NBlockElement>, stack:WalkStack) {
		stack = Item("PDefault", stack);
		{
			walkToken(_default, Item("_default", stack));
			walkToken(colon, Item("colon", stack));
			walkNCase_PDefault_el(el, Item("el", stack));
		};
	}
	function walkNMetadata_PMetadataWithArgs(name:Token, el:NCommaSeparated<NExpr>, pclose:Token, stack:WalkStack) {
		stack = Item("PMetadataWithArgs", stack);
		{
			walkToken(name, Item("name", stack));
			walkNMetadata_PMetadataWithArgs_el(el, Item("el", stack));
			walkToken(pclose, Item("pclose", stack));
		};
	}
	function walkNCommonFlag(node:NCommonFlag, stack:WalkStack) switch node {
		case PExtern(token):walkNCommonFlag_PExtern(token, stack);
		case PPrivate(token):walkNCommonFlag_PPrivate(token, stack);
	};
	function walkNDecl_PUsingDecl(_using:Token, path:NPath, semicolon:Token, stack:WalkStack) {
		stack = Item("PUsingDecl", stack);
		{
			walkToken(_using, Item("_using", stack));
			walkNPath(path, Item("path", stack));
			walkToken(semicolon, Item("semicolon", stack));
		};
	}
	function walkNModifier_PModifierDynamic(token:Token, stack:WalkStack) {
		stack = Item("PModifierDynamic", stack);
		{
			walkToken(token, Item("token", stack));
		};
	}
	function walkNClassField_PFunctionField_modifiers(elems:Array<NModifier>, stack:WalkStack) {
		walkArray(elems, stack, walkNModifier);
	}
	function walkNExpr_PArray(e1:NExpr, bkopen:Token, e2:NExpr, bkclose:Token, stack:WalkStack) {
		stack = Item("PArray", stack);
		{
			walkNExpr(e1, Item("e1", stack));
			walkToken(bkopen, Item("bkopen", stack));
			walkNExpr(e2, Item("e2", stack));
			walkToken(bkclose, Item("bkclose", stack));
		};
	}
	function walkNBlockElement_PVar(_var:Token, vl:NCommaSeparated<NVarDeclaration>, semicolon:Token, stack:WalkStack) {
		stack = Item("PVar", stack);
		{
			walkToken(_var, Item("_var", stack));
			walkNBlockElement_PVar_vl(vl, Item("vl", stack));
			walkToken(semicolon, Item("semicolon", stack));
		};
	}
	function walkNTypePathParameter_PArrayExprTypePathParameter(bkopen:Token, el:Null<NCommaSeparatedAllowTrailing<NExpr>>, bkclose:Token, stack:WalkStack) {
		stack = Item("PArrayExprTypePathParameter", stack);
		{
			walkToken(bkopen, Item("bkopen", stack));
			if (el != null) walkNTypePathParameter_PArrayExprTypePathParameter_el(el, Item("el", stack));
			walkToken(bkclose, Item("bkclose", stack));
		};
	}
	function walkNPath(node:NPath, stack:WalkStack) {
		walkToken(node.ident, Item("ident", stack));
		walkNPath_idents(node.idents, Item("idents", stack));
	}
	function walkNAnonymousTypeFields_PAnonymousClassFields_fields(elems:Array<NClassField>, stack:WalkStack) {
		walkArray(elems, stack, walkNClassField);
	}
	function walkNTypePathParameter_PArrayExprTypePathParameter_el(elems:NCommaSeparatedAllowTrailing<NExpr>, stack:WalkStack) {
		walkCommaSeparatedTrailing(elems, stack, walkNExpr);
	}
	function walkNClassField(node:NClassField, stack:WalkStack) switch node {
		case PPropertyField(annotations, modifiers, _var, name, popen, get, comma, set, pclose, typeHint, assignment):walkNClassField_PPropertyField(annotations, modifiers, _var, name, popen, get, comma, set, pclose, typeHint, assignment, stack);
		case PVariableField(annotations, modifiers, _var, name, typeHint, assignment, semicolon):walkNClassField_PVariableField(annotations, modifiers, _var, name, typeHint, assignment, semicolon, stack);
		case PFunctionField(annotations, modifiers, _function, name, params, popen, args, pclose, typeHint, e):walkNClassField_PFunctionField(annotations, modifiers, _function, name, params, popen, args, pclose, typeHint, e, stack);
	};
	function walkNModifier_PModifierOverride(token:Token, stack:WalkStack) {
		stack = Item("PModifierOverride", stack);
		{
			walkToken(token, Item("token", stack));
		};
	}
	function walkNClassRelation(node:NClassRelation, stack:WalkStack) switch node {
		case PExtends(_extends, path):walkNClassRelation_PExtends(_extends, path, stack);
		case PImplements(_implements, path):walkNClassRelation_PImplements(_implements, path, stack);
	};
	function walkNExpr_PContinue(_continue:Token, stack:WalkStack) {
		stack = Item("PContinue", stack);
		{
			walkToken(_continue, Item("_continue", stack));
		};
	}
	function walkNStructuralExtension(node:NStructuralExtension, stack:WalkStack) {
		walkToken(node.gt, Item("gt", stack));
		walkNTypePath(node.path, Item("path", stack));
		walkToken(node.comma, Item("comma", stack));
	}
	function walkNVarDeclaration(node:NVarDeclaration, stack:WalkStack) {
		walkToken(node.name, Item("name", stack));
		if (node.type != null) walkNTypeHint(node.type, Item("type", stack));
		if (node.assignment != null) walkNAssignment(node.assignment, Item("assignment", stack));
	}
	function walkNClassField_PFunctionField(annotations:NAnnotations, modifiers:Array<NModifier>, _function:Token, name:Token, params:Null<NTypeDeclParameters>, popen:Token, args:Null<NCommaSeparated<NFunctionArgument>>, pclose:Token, typeHint:Null<NTypeHint>, e:Null<NFieldExpr>, stack:WalkStack) {
		stack = Item("PFunctionField", stack);
		{
			walkNAnnotations(annotations, Item("annotations", stack));
			walkNClassField_PFunctionField_modifiers(modifiers, Item("modifiers", stack));
			walkToken(_function, Item("_function", stack));
			walkToken(name, Item("name", stack));
			if (params != null) walkNTypeDeclParameters(params, Item("params", stack));
			walkToken(popen, Item("popen", stack));
			if (args != null) walkNClassField_PFunctionField_args(args, Item("args", stack));
			walkToken(pclose, Item("pclose", stack));
			if (typeHint != null) walkNTypeHint(typeHint, Item("typeHint", stack));
			if (e != null) walkNFieldExpr(e, Item("e", stack));
		};
	}
	function walkNModifier_PModifierStatic(token:Token, stack:WalkStack) {
		stack = Item("PModifierStatic", stack);
		{
			walkToken(token, Item("token", stack));
		};
	}
	function walkNImportMode_PAllMode(dotstar:Token, stack:WalkStack) {
		stack = Item("PAllMode", stack);
		{
			walkToken(dotstar, Item("dotstar", stack));
		};
	}
	function walkNObjectField(node:NObjectField, stack:WalkStack) {
		walkNObjectFieldName(node.name, Item("name", stack));
		walkToken(node.colon, Item("colon", stack));
		walkNExpr(node.e, Item("e", stack));
	}
	function walkNImport(node:NImport, stack:WalkStack) {
		walkNPath(node.path, Item("path", stack));
		walkNImportMode(node.mode, Item("mode", stack));
	}
	function walkNLiteral_PLiteralString(s:NString, stack:WalkStack) {
		stack = Item("PLiteralString", stack);
		{
			walkNString(s, Item("s", stack));
		};
	}
	function walkNExpr_PBinop(e1:NExpr, op:Token, e2:NExpr, stack:WalkStack) {
		stack = Item("PBinop", stack);
		{
			walkNExpr(e1, Item("e1", stack));
			walkToken(op, Item("op", stack));
			walkNExpr(e2, Item("e2", stack));
		};
	}
	function walkNBlockElement_PExpr(e:NExpr, semicolon:Token, stack:WalkStack) {
		stack = Item("PExpr", stack);
		{
			walkNExpr(e, Item("e", stack));
			walkToken(semicolon, Item("semicolon", stack));
		};
	}
	function walkNAnnotations_meta(elems:Array<NMetadata>, stack:WalkStack) {
		walkArray(elems, stack, walkNMetadata);
	}
	function walkNImportMode_PAsMode(_as:Token, ident:Token, stack:WalkStack) {
		stack = Item("PAsMode", stack);
		{
			walkToken(_as, Item("_as", stack));
			walkToken(ident, Item("ident", stack));
		};
	}
	function walkNComplexType_PFunctionType(type1:NComplexType, arrow:Token, type2:NComplexType, stack:WalkStack) {
		stack = Item("PFunctionType", stack);
		{
			walkNComplexType(type1, Item("type1", stack));
			walkToken(arrow, Item("arrow", stack));
			walkNComplexType(type2, Item("type2", stack));
		};
	}
	function walkNMetadata_PMetadata(name:Token, stack:WalkStack) {
		stack = Item("PMetadata", stack);
		{
			walkToken(name, Item("name", stack));
		};
	}
	function walkNLiteral(node:NLiteral, stack:WalkStack) switch node {
		case PLiteralString(s):walkNLiteral_PLiteralString(s, stack);
		case PLiteralFloat(token):walkNLiteral_PLiteralFloat(token, stack);
		case PLiteralRegex(token):walkNLiteral_PLiteralRegex(token, stack);
		case PLiteralInt(token):walkNLiteral_PLiteralInt(token, stack);
	};
	function walkNDecl_PAbstractDecl(annotations:NAnnotations, flags:Array<NCommonFlag>, _abstract:Token, name:Token, params:Null<NTypeDeclParameters>, underlyingType:Null<NUnderlyingType>, relations:Array<NAbstractRelation>, bropen:Token, fields:Array<NClassField>, brclose:Token, stack:WalkStack) {
		stack = Item("PAbstractDecl", stack);
		{
			walkNAnnotations(annotations, Item("annotations", stack));
			walkNDecl_PAbstractDecl_flags(flags, Item("flags", stack));
			walkToken(_abstract, Item("_abstract", stack));
			walkToken(name, Item("name", stack));
			if (params != null) walkNTypeDeclParameters(params, Item("params", stack));
			if (underlyingType != null) walkNUnderlyingType(underlyingType, Item("underlyingType", stack));
			walkNDecl_PAbstractDecl_relations(relations, Item("relations", stack));
			walkToken(bropen, Item("bropen", stack));
			walkNDecl_PAbstractDecl_fields(fields, Item("fields", stack));
			walkToken(brclose, Item("brclose", stack));
		};
	}
	function walkNExpr_PFunction(_function:Token, f:NFunction, stack:WalkStack) {
		stack = Item("PFunction", stack);
		{
			walkToken(_function, Item("_function", stack));
			walkNFunction(f, Item("f", stack));
		};
	}
	function walkNCase_PCase_patterns(elems:NCommaSeparated<NExpr>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNExpr);
	}
	function walkNLiteral_PLiteralRegex(token:Token, stack:WalkStack) {
		stack = Item("PLiteralRegex", stack);
		{
			walkToken(token, Item("token", stack));
		};
	}
	function walkNExpr_PNew(_new:Token, path:NTypePath, el:NCallArgs, stack:WalkStack) {
		stack = Item("PNew", stack);
		{
			walkToken(_new, Item("_new", stack));
			walkNTypePath(path, Item("path", stack));
			walkNCallArgs(el, Item("el", stack));
		};
	}
	function walkNExpr_PThrow(_throw:Token, e:NExpr, stack:WalkStack) {
		stack = Item("PThrow", stack);
		{
			walkToken(_throw, Item("_throw", stack));
			walkNExpr(e, Item("e", stack));
		};
	}
	function walkNClassDecl(node:NClassDecl, stack:WalkStack) {
		walkToken(node.kind, Item("kind", stack));
		walkToken(node.name, Item("name", stack));
		if (node.params != null) walkNTypeDeclParameters(node.params, Item("params", stack));
		walkNClassDecl_relations(node.relations, Item("relations", stack));
		walkToken(node.bropen, Item("bropen", stack));
		walkNClassDecl_fields(node.fields, Item("fields", stack));
		walkToken(node.brclose, Item("brclose", stack));
	}
	function walkNConst(node:NConst, stack:WalkStack) switch node {
		case PConstLiteral(literal):walkNConst_PConstLiteral(literal, stack);
		case PConstIdent(ident):walkNConst_PConstIdent(ident, stack);
	};
	function walkNCommonFlag_PExtern(token:Token, stack:WalkStack) {
		stack = Item("PExtern", stack);
		{
			walkToken(token, Item("token", stack));
		};
	}
	function walkNDecl_PEnumDecl(annotations:NAnnotations, flags:Array<NCommonFlag>, _enum:Token, name:Token, params:Null<NTypeDeclParameters>, bropen:Token, fields:Array<NEnumField>, brclose:Token, stack:WalkStack) {
		stack = Item("PEnumDecl", stack);
		{
			walkNAnnotations(annotations, Item("annotations", stack));
			walkNDecl_PEnumDecl_flags(flags, Item("flags", stack));
			walkToken(_enum, Item("_enum", stack));
			walkToken(name, Item("name", stack));
			if (params != null) walkNTypeDeclParameters(params, Item("params", stack));
			walkToken(bropen, Item("bropen", stack));
			walkNDecl_PEnumDecl_fields(fields, Item("fields", stack));
			walkToken(brclose, Item("brclose", stack));
		};
	}
	function walkNTypePathParameters(node:NTypePathParameters, stack:WalkStack) {
		walkToken(node.lt, Item("lt", stack));
		walkNTypePathParameters_parameters(node.parameters, Item("parameters", stack));
		walkToken(node.gt, Item("gt", stack));
	}
	function walkNClassField_PVariableField_modifiers(elems:Array<NModifier>, stack:WalkStack) {
		walkArray(elems, stack, walkNModifier);
	}
	function walkNExpr_PTry(_try:Token, e:NExpr, catches:Array<NCatch>, stack:WalkStack) {
		stack = Item("PTry", stack);
		{
			walkToken(_try, Item("_try", stack));
			walkNExpr(e, Item("e", stack));
			walkNExpr_PTry_catches(catches, Item("catches", stack));
		};
	}
	function walkNExpr_PCall(e:NExpr, el:NCallArgs, stack:WalkStack) {
		stack = Item("PCall", stack);
		{
			walkNExpr(e, Item("e", stack));
			walkNCallArgs(el, Item("el", stack));
		};
	}
	function walkNFunctionArgument(node:NFunctionArgument, stack:WalkStack) {
		walkNAnnotations(node.annotations, Item("annotations", stack));
		if (node.questionmark != null) walkToken(node.questionmark, Item("questionmark", stack));
		walkToken(node.name, Item("name", stack));
		if (node.typeHint != null) walkNTypeHint(node.typeHint, Item("typeHint", stack));
		if (node.assignment != null) walkNAssignment(node.assignment, Item("assignment", stack));
	}
	function walkNDecl_PEnumDecl_flags(elems:Array<NCommonFlag>, stack:WalkStack) {
		walkArray(elems, stack, walkNCommonFlag);
	}
	function walkNExpr_PTernary(e1:NExpr, questionmark:Token, e2:NExpr, colon:Token, e3:NExpr, stack:WalkStack) {
		stack = Item("PTernary", stack);
		{
			walkNExpr(e1, Item("e1", stack));
			walkToken(questionmark, Item("questionmark", stack));
			walkNExpr(e2, Item("e2", stack));
			walkToken(colon, Item("colon", stack));
			walkNExpr(e3, Item("e3", stack));
		};
	}
	function walkNTypeDeclParameters(node:NTypeDeclParameters, stack:WalkStack) {
		walkToken(node.lt, Item("lt", stack));
		walkNTypeDeclParameters_params(node.params, Item("params", stack));
		walkToken(node.gt, Item("gt", stack));
	}
	function walkNConst_PConstIdent(ident:Token, stack:WalkStack) {
		stack = Item("PConstIdent", stack);
		{
			walkToken(ident, Item("ident", stack));
		};
	}
	function walkNExpr_PUnaryPrefix(op:Token, e:NExpr, stack:WalkStack) {
		stack = Item("PUnaryPrefix", stack);
		{
			walkToken(op, Item("op", stack));
			walkNExpr(e, Item("e", stack));
		};
	}
	function walkNExpr_PUntyped(_untyped:Token, e:NExpr, stack:WalkStack) {
		stack = Item("PUntyped", stack);
		{
			walkToken(_untyped, Item("_untyped", stack));
			walkNExpr(e, Item("e", stack));
		};
	}
	function walkNConstraints(node:NConstraints, stack:WalkStack) switch node {
		case PMultipleConstraints(colon, popen, types, pclose):walkNConstraints_PMultipleConstraints(colon, popen, types, pclose, stack);
		case PSingleConstraint(colon, type):walkNConstraints_PSingleConstraint(colon, type, stack);
		case PNoConstraints:{ };
	};
	function walkNClassDecl_relations(elems:Array<NClassRelation>, stack:WalkStack) {
		walkArray(elems, stack, walkNClassRelation);
	}
	function walkNCase(node:NCase, stack:WalkStack) switch node {
		case PCase(_case, patterns, guard, colon, el):walkNCase_PCase(_case, patterns, guard, colon, el, stack);
		case PDefault(_default, colon, el):walkNCase_PDefault(_default, colon, el, stack);
	};
	function walkNConstraints_PSingleConstraint(colon:Token, type:NComplexType, stack:WalkStack) {
		stack = Item("PSingleConstraint", stack);
		{
			walkToken(colon, Item("colon", stack));
			walkNComplexType(type, Item("type", stack));
		};
	}
	function walkNComplexType_PTypePath(path:NTypePath, stack:WalkStack) {
		stack = Item("PTypePath", stack);
		{
			walkNTypePath(path, Item("path", stack));
		};
	}
	function walkNFieldExpr_PExprFieldExpr(e:NExpr, semicolon:Token, stack:WalkStack) {
		stack = Item("PExprFieldExpr", stack);
		{
			walkNExpr(e, Item("e", stack));
			walkToken(semicolon, Item("semicolon", stack));
		};
	}
	function walkNDecl_PAbstractDecl_flags(elems:Array<NCommonFlag>, stack:WalkStack) {
		walkArray(elems, stack, walkNCommonFlag);
	}
	function walkNString(node:NString, stack:WalkStack) switch node {
		case PString(s):walkNString_PString(s, stack);
		case PString2(s):walkNString_PString2(s, stack);
	};
	function walkNDecl_PTypedefDecl_flags(elems:Array<NCommonFlag>, stack:WalkStack) {
		walkArray(elems, stack, walkNCommonFlag);
	}
	function walkNAbstractRelation_PFrom(_from:Token, type:NComplexType, stack:WalkStack) {
		stack = Item("PFrom", stack);
		{
			walkToken(_from, Item("_from", stack));
			walkNComplexType(type, Item("type", stack));
		};
	}
	function walkNAnnotations(node:NAnnotations, stack:WalkStack) {
		if (node.doc != null) walkToken(node.doc, Item("doc", stack));
		walkNAnnotations_meta(node.meta, Item("meta", stack));
	}
	function walkNLiteral_PLiteralFloat(token:Token, stack:WalkStack) {
		stack = Item("PLiteralFloat", stack);
		{
			walkToken(token, Item("token", stack));
		};
	}
	function walkNExpr_PIf(_if:Token, popen:Token, e1:NExpr, pclose:Token, e2:NExpr, elseExpr:Null<NExprElse>, stack:WalkStack) {
		stack = Item("PIf", stack);
		{
			walkToken(_if, Item("_if", stack));
			walkToken(popen, Item("popen", stack));
			walkNExpr(e1, Item("e1", stack));
			walkToken(pclose, Item("pclose", stack));
			walkNExpr(e2, Item("e2", stack));
			if (elseExpr != null) walkNExprElse(elseExpr, Item("elseExpr", stack));
		};
	}
	function walkNDotIdent(node:NDotIdent, stack:WalkStack) switch node {
		case PDotIdent(name):walkNDotIdent_PDotIdent(name, stack);
		case PDot(_dot):walkNDotIdent_PDot(_dot, stack);
	};
	function walkNExpr_PCheckType(popen:Token, e:NExpr, colon:Token, type:NComplexType, pclose:Token, stack:WalkStack) {
		stack = Item("PCheckType", stack);
		{
			walkToken(popen, Item("popen", stack));
			walkNExpr(e, Item("e", stack));
			walkToken(colon, Item("colon", stack));
			walkNComplexType(type, Item("type", stack));
			walkToken(pclose, Item("pclose", stack));
		};
	}
	function walkNDecl_PEnumDecl_fields(elems:Array<NEnumField>, stack:WalkStack) {
		walkArray(elems, stack, walkNEnumField);
	}
	function walkNExpr_PUnaryPostfix(e:NExpr, op:Token, stack:WalkStack) {
		stack = Item("PUnaryPostfix", stack);
		{
			walkNExpr(e, Item("e", stack));
			walkToken(op, Item("op", stack));
		};
	}
	function walkNFieldExpr_PNoFieldExpr(semicolon:Token, stack:WalkStack) {
		stack = Item("PNoFieldExpr", stack);
		{
			walkToken(semicolon, Item("semicolon", stack));
		};
	}
	function walkNTypePathParameter_PTypeTypePathParameter(type:NComplexType, stack:WalkStack) {
		stack = Item("PTypeTypePathParameter", stack);
		{
			walkNComplexType(type, Item("type", stack));
		};
	}
	function walkNTypePathParameters_parameters(elems:NCommaSeparated<NTypePathParameter>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNTypePathParameter);
	}
	function walkNExpr_PMacro(_macro:Token, e:NMacroExpr, stack:WalkStack) {
		stack = Item("PMacro", stack);
		{
			walkToken(_macro, Item("_macro", stack));
			walkNMacroExpr(e, Item("e", stack));
		};
	}
	function walkNModifier_PModifierPublic(token:Token, stack:WalkStack) {
		stack = Item("PModifierPublic", stack);
		{
			walkToken(token, Item("token", stack));
		};
	}
	function walkNExpr_PBlock_elems(elems:Array<NBlockElement>, stack:WalkStack) {
		walkArray(elems, stack, walkNBlockElement);
	}
	function walkNFunction_args(elems:NCommaSeparated<NFunctionArgument>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNFunctionArgument);
	}
	function walkNModifier_PModifierMacro(token:Token, stack:WalkStack) {
		stack = Item("PModifierMacro", stack);
		{
			walkToken(token, Item("token", stack));
		};
	}
	function walkNConstraints_PMultipleConstraints_types(elems:NCommaSeparated<NComplexType>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNComplexType);
	}
	function walkNLiteral_PLiteralInt(token:Token, stack:WalkStack) {
		stack = Item("PLiteralInt", stack);
		{
			walkToken(token, Item("token", stack));
		};
	}
	function walkNBlockElement_PInlineFunction(_inline:Token, _function:Token, f:NFunction, semicolon:Token, stack:WalkStack) {
		stack = Item("PInlineFunction", stack);
		{
			walkToken(_inline, Item("_inline", stack));
			walkToken(_function, Item("_function", stack));
			walkNFunction(f, Item("f", stack));
			walkToken(semicolon, Item("semicolon", stack));
		};
	}
	function walkNCase_PCase_el(elems:Array<NBlockElement>, stack:WalkStack) {
		walkArray(elems, stack, walkNBlockElement);
	}
	function walkNExpr_PIn(e1:NExpr, _in:Token, e2:NExpr, stack:WalkStack) {
		stack = Item("PIn", stack);
		{
			walkNExpr(e1, Item("e1", stack));
			walkToken(_in, Item("_in", stack));
			walkNExpr(e2, Item("e2", stack));
		};
	}
	function walkNClassField_PPropertyField(annotations:NAnnotations, modifiers:Array<NModifier>, _var:Token, name:Token, popen:Token, get:Token, comma:Token, set:Token, pclose:Token, typeHint:Null<NTypeHint>, assignment:Null<NAssignment>, stack:WalkStack) {
		stack = Item("PPropertyField", stack);
		{
			walkNAnnotations(annotations, Item("annotations", stack));
			walkNClassField_PPropertyField_modifiers(modifiers, Item("modifiers", stack));
			walkToken(_var, Item("_var", stack));
			walkToken(name, Item("name", stack));
			walkToken(popen, Item("popen", stack));
			walkToken(get, Item("get", stack));
			walkToken(comma, Item("comma", stack));
			walkToken(set, Item("set", stack));
			walkToken(pclose, Item("pclose", stack));
			if (typeHint != null) walkNTypeHint(typeHint, Item("typeHint", stack));
			if (assignment != null) walkNAssignment(assignment, Item("assignment", stack));
		};
	}
	function walkNAnonymousTypeFields_PAnonymousClassFields(fields:Array<NClassField>, stack:WalkStack) {
		stack = Item("PAnonymousClassFields", stack);
		{
			walkNAnonymousTypeFields_PAnonymousClassFields_fields(fields, Item("fields", stack));
		};
	}
	function walkNAnonymousTypeField(node:NAnonymousTypeField, stack:WalkStack) {
		if (node.questionmark != null) walkToken(node.questionmark, Item("questionmark", stack));
		walkToken(node.name, Item("name", stack));
		walkNTypeHint(node.typeHint, Item("typeHint", stack));
	}
	function walkNUnderlyingType(node:NUnderlyingType, stack:WalkStack) {
		walkToken(node.popen, Item("popen", stack));
		walkNComplexType(node.type, Item("type", stack));
		walkToken(node.pclose, Item("pclose", stack));
	}
	function walkNGuard(node:NGuard, stack:WalkStack) {
		walkToken(node._if, Item("_if", stack));
		walkToken(node.popen, Item("popen", stack));
		walkNExpr(node.e, Item("e", stack));
		walkToken(node.pclose, Item("pclose", stack));
	}
	function walkNMacroExpr(node:NMacroExpr, stack:WalkStack) switch node {
		case PVar(_var, v):walkNMacroExpr_PVar(_var, v, stack);
		case PTypeHint(type):walkNMacroExpr_PTypeHint(type, stack);
		case PClass(c):walkNMacroExpr_PClass(c, stack);
		case PExpr(e):walkNMacroExpr_PExpr(e, stack);
	};
	function walkNEnumField(node:NEnumField, stack:WalkStack) {
		walkNAnnotations(node.annotations, Item("annotations", stack));
		walkToken(node.name, Item("name", stack));
		if (node.params != null) walkNTypeDeclParameters(node.params, Item("params", stack));
		if (node.args != null) walkNEnumFieldArgs(node.args, Item("args", stack));
		if (node.type != null) walkNTypeHint(node.type, Item("type", stack));
		walkToken(node.semicolon, Item("semicolon", stack));
	}
	function walkNDecl(node:NDecl, stack:WalkStack) switch node {
		case PClassDecl(annotations, flags, c):walkNDecl_PClassDecl(annotations, flags, c, stack);
		case PTypedefDecl(annotations, flags, _typedef, name, params, assign, type, semicolon):walkNDecl_PTypedefDecl(annotations, flags, _typedef, name, params, assign, type, semicolon, stack);
		case PUsingDecl(_using, path, semicolon):walkNDecl_PUsingDecl(_using, path, semicolon, stack);
		case PImportDecl(_import, importPath, semicolon):walkNDecl_PImportDecl(_import, importPath, semicolon, stack);
		case PAbstractDecl(annotations, flags, _abstract, name, params, underlyingType, relations, bropen, fields, brclose):walkNDecl_PAbstractDecl(annotations, flags, _abstract, name, params, underlyingType, relations, bropen, fields, brclose, stack);
		case PEnumDecl(annotations, flags, _enum, name, params, bropen, fields, brclose):walkNDecl_PEnumDecl(annotations, flags, _enum, name, params, bropen, fields, brclose, stack);
	};
	function walkNBlockElement(node:NBlockElement, stack:WalkStack) switch node {
		case PVar(_var, vl, semicolon):walkNBlockElement_PVar(_var, vl, semicolon, stack);
		case PExpr(e, semicolon):walkNBlockElement_PExpr(e, semicolon, stack);
		case PInlineFunction(_inline, _function, f, semicolon):walkNBlockElement_PInlineFunction(_inline, _function, f, semicolon, stack);
	};
	function walkNExpr_PSwitch(_switch:Token, e:NExpr, bropen:Token, cases:Array<NCase>, brclose:Token, stack:WalkStack) {
		stack = Item("PSwitch", stack);
		{
			walkToken(_switch, Item("_switch", stack));
			walkNExpr(e, Item("e", stack));
			walkToken(bropen, Item("bropen", stack));
			walkNExpr_PSwitch_cases(cases, Item("cases", stack));
			walkToken(brclose, Item("brclose", stack));
		};
	}
	function walkNExpr_PField(e:NExpr, ident:NDotIdent, stack:WalkStack) {
		stack = Item("PField", stack);
		{
			walkNExpr(e, Item("e", stack));
			walkNDotIdent(ident, Item("ident", stack));
		};
	}
	function walkNExpr_PFor(_for:Token, popen:Token, e1:NExpr, pclose:Token, e2:NExpr, stack:WalkStack) {
		stack = Item("PFor", stack);
		{
			walkToken(_for, Item("_for", stack));
			walkToken(popen, Item("popen", stack));
			walkNExpr(e1, Item("e1", stack));
			walkToken(pclose, Item("pclose", stack));
			walkNExpr(e2, Item("e2", stack));
		};
	}
	function walkNEnumFieldArg(node:NEnumFieldArg, stack:WalkStack) {
		if (node.questionmark != null) walkToken(node.questionmark, Item("questionmark", stack));
		walkToken(node.name, Item("name", stack));
		walkNTypeHint(node.typeHint, Item("typeHint", stack));
	}
	function walkNMetadata(node:NMetadata, stack:WalkStack) switch node {
		case PMetadata(name):walkNMetadata_PMetadata(name, stack);
		case PMetadataWithArgs(name, el, pclose):walkNMetadata_PMetadataWithArgs(name, el, pclose, stack);
	};
	function walkNClassRelation_PImplements(_implements:Token, path:NTypePath, stack:WalkStack) {
		stack = Item("PImplements", stack);
		{
			walkToken(_implements, Item("_implements", stack));
			walkNTypePath(path, Item("path", stack));
		};
	}
	function walkNTypePath(node:NTypePath, stack:WalkStack) {
		walkNPath(node.path, Item("path", stack));
		if (node.params != null) walkNTypePathParameters(node.params, Item("params", stack));
	}
	function walkNExpr_PIs(popen:Token, e:NExpr, _is:Token, path:NTypePath, pclose:Token, stack:WalkStack) {
		stack = Item("PIs", stack);
		{
			walkToken(popen, Item("popen", stack));
			walkNExpr(e, Item("e", stack));
			walkToken(_is, Item("_is", stack));
			walkNTypePath(path, Item("path", stack));
			walkToken(pclose, Item("pclose", stack));
		};
	}
	function walkNExpr_PWhile(_while:Token, popen:Token, e1:NExpr, pclose:Token, e2:NExpr, stack:WalkStack) {
		stack = Item("PWhile", stack);
		{
			walkToken(_while, Item("_while", stack));
			walkToken(popen, Item("popen", stack));
			walkNExpr(e1, Item("e1", stack));
			walkToken(pclose, Item("pclose", stack));
			walkNExpr(e2, Item("e2", stack));
		};
	}
	function walkNCase_PCase(_case:Token, patterns:NCommaSeparated<NExpr>, guard:Null<NGuard>, colon:Token, el:Array<NBlockElement>, stack:WalkStack) {
		stack = Item("PCase", stack);
		{
			walkToken(_case, Item("_case", stack));
			walkNCase_PCase_patterns(patterns, Item("patterns", stack));
			if (guard != null) walkNGuard(guard, Item("guard", stack));
			walkToken(colon, Item("colon", stack));
			walkNCase_PCase_el(el, Item("el", stack));
		};
	}
	function walkNObjectFieldName_PIdent(ident:Token, stack:WalkStack) {
		stack = Item("PIdent", stack);
		{
			walkToken(ident, Item("ident", stack));
		};
	}
	function walkNDecl_PAbstractDecl_relations(elems:Array<NAbstractRelation>, stack:WalkStack) {
		walkArray(elems, stack, walkNAbstractRelation);
	}
	function walkNExpr_PReturnExpr(_return:Token, e:NExpr, stack:WalkStack) {
		stack = Item("PReturnExpr", stack);
		{
			walkToken(_return, Item("_return", stack));
			walkNExpr(e, Item("e", stack));
		};
	}
	function walkNExpr_PTry_catches(elems:Array<NCatch>, stack:WalkStack) {
		walkArray(elems, stack, walkNCatch);
	}
	function walkNMacroExpr_PVar(_var:Token, v:NCommaSeparated<NVarDeclaration>, stack:WalkStack) {
		stack = Item("PVar", stack);
		{
			walkToken(_var, Item("_var", stack));
			walkNMacroExpr_PVar_v(v, Item("v", stack));
		};
	}
	function walkNAnonymousTypeFields(node:NAnonymousTypeFields, stack:WalkStack) switch node {
		case PAnonymousClassFields(fields):walkNAnonymousTypeFields_PAnonymousClassFields(fields, stack);
		case PAnonymousShortFields(fields):walkNAnonymousTypeFields_PAnonymousShortFields(fields, stack);
	};
	function walkNAnonymousTypeFields_PAnonymousShortFields_fields(elems:NCommaSeparatedAllowTrailing<NAnonymousTypeField>, stack:WalkStack) {
		walkCommaSeparatedTrailing(elems, stack, walkNAnonymousTypeField);
	}
	function walkNCommonFlag_PPrivate(token:Token, stack:WalkStack) {
		stack = Item("PPrivate", stack);
		{
			walkToken(token, Item("token", stack));
		};
	}
	function walkNString_PString(s:Token, stack:WalkStack) {
		stack = Item("PString", stack);
		{
			walkToken(s, Item("s", stack));
		};
	}
	function walkNClassField_PFunctionField_args(elems:NCommaSeparated<NFunctionArgument>, stack:WalkStack) {
		walkCommaSeparated(elems, stack, walkNFunctionArgument);
	}
	function walkNFunction(node:NFunction, stack:WalkStack) {
		if (node.ident != null) walkToken(node.ident, Item("ident", stack));
		if (node.params != null) walkNTypeDeclParameters(node.params, Item("params", stack));
		walkToken(node.popen, Item("popen", stack));
		if (node.args != null) walkNFunction_args(node.args, Item("args", stack));
		walkToken(node.pclose, Item("pclose", stack));
		if (node.type != null) walkNTypeHint(node.type, Item("type", stack));
		walkNExpr(node.e, Item("e", stack));
	}
	function walkNExpr_PMacroEscape(ident:Token, bropen:Token, e:NExpr, brclose:Token, stack:WalkStack) {
		stack = Item("PMacroEscape", stack);
		{
			walkToken(ident, Item("ident", stack));
			walkToken(bropen, Item("bropen", stack));
			walkNExpr(e, Item("e", stack));
			walkToken(brclose, Item("brclose", stack));
		};
	}
	function walkNExpr_PReturn(_return:Token, stack:WalkStack) {
		stack = Item("PReturn", stack);
		{
			walkToken(_return, Item("_return", stack));
		};
	}
	function walkNExpr_PDollarIdent(ident:Token, stack:WalkStack) {
		stack = Item("PDollarIdent", stack);
		{
			walkToken(ident, Item("ident", stack));
		};
	}
	function walkNComplexType_PStructuralExtension(bropen:Token, types:Array<NStructuralExtension>, fields:NAnonymousTypeFields, brclose:Token, stack:WalkStack) {
		stack = Item("PStructuralExtension", stack);
		{
			walkToken(bropen, Item("bropen", stack));
			walkNComplexType_PStructuralExtension_types(types, Item("types", stack));
			walkNAnonymousTypeFields(fields, Item("fields", stack));
			walkToken(brclose, Item("brclose", stack));
		};
	}
	function walkNExprElse(node:NExprElse, stack:WalkStack) {
		walkToken(node._else, Item("_else", stack));
		walkNExpr(node.e, Item("e", stack));
	}
}